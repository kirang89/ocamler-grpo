"id","problem","solution","tests","difficulty"
"medium_118","(**Given n points on a 2D plane, find if there is such a line parallel to the y-axis that reflects t...
 * >>> is_reflected [[0; 0]; [1; 0]; [3; 0]; [4; 0]]
 * true
 * >>> is_reflected [[1; 1]; [-1; 1]]
 * true
 * >>> is_reflected [[0; 0]; [0; 1]; [1; 0]; [1; 1]]
 * true
*)
let is_reflected (points : int list list) : bool =","  false","let () =
  assert (is_reflected [[0; 0]; [1; 0]; [3; 0]; [4; 0]] = true);
  assert (is_reflected [[1; 1]; [-1; 1]] = true);
  assert (is_reflected [[0; 0]; [0; 1]; [1; 0]; [1; 1]] = true);
  assert (is_reflected [[0; 0]; [0; 1]; [0; 2]; [0; 3]] = true);
  assert (is_reflected [[1; 1]; [1; -1]; [-1; -1]; [-1; 1]] = true);
  assert (is_reflected [[1; 1]; [2; 2]; [3; 3]; [4; 5]] = false);
  assert (is_reflected [[1; 1]; [2; 2]; [3; 3]] = false);
;;","medium"
"medium_049","(**Given a binary string s, you can split s into 3 non-empty strings s1, s2, and s3 where s1 + s2 + ...
 * >>> num_ways ""101010101""
 * 0
 * >>> num_ways ""10101010101""
 * 4
 * >>> num_ways ""0000""
 * 3
*)
let num_ways (s : string) : int =","  0","let () =
  assert (num_ways ""101010101"" = 0);
  assert (num_ways ""10101010101"" = 4);
  assert (num_ways ""0000"" = 3);
  assert (num_ways ""0000000"" = 15);
  assert (num_ways ""010101010"" = 0);
  assert (num_ways ""111000"" = 1);
  assert (num_ways ""11111111111"" = 0);
;;","medium"
"medium_195","(**You are given a 0-indexed integer array nums. You can apply the following operation any number of...
 * >>> make_pref_sum_non_negative [-1; 2; -3; 4; -5]
 * 2
 * >>> make_pref_sum_non_negative [1; -1; 1; -1; 1]
 * 0
 * >>> make_pref_sum_non_negative [1; 2; 3; 4; 5; -15]
 * 0
*)
let make_pref_sum_non_negative (nums : int list) : int =","  0","let () =
  assert (make_pref_sum_non_negative [-1; 2; -3; 4; -5] = 2);
  assert (make_pref_sum_non_negative [1; -1; 1; -1; 1] = 0);
  assert (make_pref_sum_non_negative [1; 2; 3; 4; 5; -15] = 0);
  assert (make_pref_sum_non_negative [-1; -2; -3; 4; 5; 6] = 3);
  assert (make_pref_sum_non_negative [-5; -4; -3; -2; -1] = 5);
  assert (make_pref_sum_non_negative [0; 0; 0; 0; 0] = 0);
  assert (make_pref_sum_non_negative [2; 3; -5; 4] = 0);
;;","medium"
"medium_185","(**Given two version strings, version1 and version2, compare them. A version string consists of revi...
 * >>> compare_version ""0"" ""0.0.0""
 * 0
 * >>> compare_version ""1.1.1.1"" ""1.1.1.1""
 * 0
 * >>> compare_version ""1.2.3.4"" ""1.2.3""
 * 1
*)
let compare_version (version1 : string) (version2 : string) : int =","  0","let () =
  assert (compare_version ""0"" ""0.0.0"" = 0);
  assert (compare_version ""1.1.1.1"" ""1.1.1.1"" = 0);
  assert (compare_version ""1.2.3.4"" ""1.2.3"" = 1);
  assert (compare_version ""1.1.1.1"" ""1.1.1"" = 1);
  assert (compare_version ""1.0.0"" ""1"" = 0);
  assert (compare_version ""5.0000"" ""5.00000"" = 0);
  assert (compare_version ""0.0.1"" ""0.0.2"" = -1);
;;","medium"
"medium_133","(**You are given an array arr of size n consisting of non-empty strings.
 * >>> shortest_substrings [""abcabc""; ""bcabc""; ""cabc""; ""abcd""]
 * ['abca'; ''; ''; 'd']
 * >>> shortest_substrings [""aaa""; ""aab""; ""aba""; ""abb""]
 * ['aaa'; 'aab'; 'ba'; 'bb']
 * >>> shortest_substrings [""abc""; ""bcd""; ""abcd""]
 * [''; ''; 'abcd']
*)
let shortest_substrings (arr : string list) : string list =","  []","let () =
  assert (shortest_substrings [""abcabc""; ""bcabc""; ""cabc""; ""abcd""] = ['abca'; ''; ''; 'd']);
  assert (shortest_substrings [""aaa""; ""aab""; ""aba""; ""abb""] = ['aaa'; 'aab'; 'ba'; 'bb']);
  assert (shortest_substrings [""abc""; ""bcd""; ""abcd""] = [''; ''; 'abcd']);
  assert (shortest_substrings [""abcd""; ""bcde""; ""cdef""; ""defg""] = ['a'; 'bcde'; 'cdef'; 'g']);
  assert (shortest_substrings [""hello""; ""world""; ""hel""; ""wor""; ""ld""] = ['ll'; 'rl'; ''; ''; '']);
  assert (shortest_substrings [""unique""; ""strings""; ""array""; ""test""] = ['q'; 'g'; 'a'; 'es']);
  assert (shortest_substrings [""cab""; ""ad""; ""bad""; ""c""] = ['ab'; ''; 'ba'; '']);
;;","medium"
"easy_035","(**There is a biker going on a road trip. The road trip consists of n + 1 points at different altitu...
 * >>> largest_altitude [4; 3; 2; 1; 0; -1; -2; -3; -4]
 * 10
 * >>> largest_altitude [-1; -2; -3; -4]
 * 0
 * >>> largest_altitude [-10; -20; -30; -40; -50]
 * 0
*)
let largest_altitude (gain : int list) : int =","  0","let () =
  assert (largest_altitude [4; 3; 2; 1; 0; -1; -2; -3; -4] = 10);
  assert (largest_altitude [-1; -2; -3; -4] = 0);
  assert (largest_altitude [-10; -20; -30; -40; -50] = 0);
  assert (largest_altitude [1; 2; 3; 4; 5; 6; 7; 8; 9; 100] = 145);
  assert (largest_altitude [-1; 1; -1; 1; -1; 1] = 0);
  assert (largest_altitude [0; 0; 0; 0; 0; 0; 0; 0; 0; 0] = 0);
  assert (largest_altitude [-5; -4; -3; -2; -1] = 0);
;;","easy"
"medium_015","(**Perform the following shift operations on a string:
 * >>> group_strings [""aaa""; ""bbb""; ""ccc""; ""zzz""; ""aaa""; ""zzz""]
 * [['aaa'; 'bbb'; 'ccc'; 'zzz'; 'aaa'; 'zzz']]
 * >>> group_strings [""abcdefghijklmnopqrstuvwxyz""; ""bcdefghijklmnopqrstuvwxyza""; ""zabcdefghijklmnopqrstuvwxy""]
 * [['abcdefghijklmnopqrstuvwxyz'; 'bcdefghijklmnopqrstuvwxyza'; 'zabcdefghijklmnopqrstuvwxy']]
 * >>> group_strings [""aaa""; ""bbb""; ""ccc""; ""xyz""; ""zyz""; ""aba""; ""bab""; ""aab""; ""abb""; ""abc""; ""bca""; ""cab""]
 * [['aaa'; 'bbb'; 'ccc']; ['xyz'; 'abc']; ['zyz'; 'bab']; ['aba']; ['aab']; ['abb']; ['bca']; ['cab']]
*)
let group_strings (strings : string list) : string list list =","  [[]]","let () =
  assert (group_strings [""aaa""; ""bbb""; ""ccc""; ""zzz""; ""aaa""; ""zzz""] = [['aaa'; 'bbb'; 'ccc'; 'zzz'; 'aaa'; 'zzz']]);
  assert (group_strings [""abcdefghijklmnopqrstuvwxyz""; ""bcdefghijklmnopqrstuvwxyza""; ""zabcdefghijklmnopqrstuvwxy""] = [['abcdefghijklmnopqrstuvwxyz'; 'bcdefghijklmnopqrstuvwxyza'; 'zabcdefghijklmnopqrstuvwxy']]);
  assert (group_strings [""aaa""; ""bbb""; ""ccc""; ""xyz""; ""zyz""; ""aba""; ""bab""; ""aab""; ""abb""; ""abc""; ""bca""; ""cab""] = [['aaa'; 'bbb'; 'ccc']; ['xyz'; 'abc']; ['zyz'; 'bab']; ['aba']; ['aab']; ['abb']; ['bca']; ['cab']]);
  assert (group_strings [""az""; ""za""; ""ba""; ""ab""; ""yx""; ""xy""] = [['az'; 'ba'; 'yx']; ['za'; 'ab'; 'xy']]);
  assert (group_strings [""az""; ""za""; ""abc""; ""bca""; ""cab""; ""xyz""; ""zyx""] = [['az']; ['za']; ['abc'; 'xyz']; ['bca']; ['cab']; ['zyx']]);
  assert (group_strings [""abc""; ""bcd""; ""cde""; ""def""; ""ghi""; ""jkl""; ""mno""; ""pqr""; ""stu""; ""vwx""; ""yz""; ""zab""; ""abc""] = [['abc'; 'bcd'; 'cde'; 'def'; 'ghi'; 'jkl'; 'mno'; 'pqr'; 'stu'; 'vwx'; 'zab'; 'abc']; ['yz']]);
  assert (group_strings [""a""] = [['a']]);
;;","medium"
"easy_075","(**Given an integer n, return true if n has exactly three positive divisors. Otherwise, return false.
 * >>> is_three 625
 * false
 * >>> is_three 3
 * false
 * >>> is_three 576
 * false
*)
let is_three (n : int) : bool =","  false","let () =
  assert (is_three 625 = false);
  assert (is_three 3 = false);
  assert (is_three 576 = false);
  assert (is_three 729 = false);
  assert (is_three 144 = false);
  assert (is_three 49 = true);
  assert (is_three 900 = false);
;;","easy"
"hard_037","(**Given n orders, each order consists of a pickup and a delivery service.
 * >>> count_orders 3
 * 90
 * >>> count_orders 250
 * 418733499
 * >>> count_orders 100
 * 14159051
*)
let count_orders (n : int) : int =","  0","let () =
  assert (count_orders 3 = 90);
  assert (count_orders 250 = 418733499);
  assert (count_orders 100 = 14159051);
  assert (count_orders 4 = 2520);
  assert (count_orders 2 = 6);
  assert (count_orders 20 = 580270580);
  assert (count_orders 1 = 1);
;;","hard"
"easy_041","(**You are given an array items, where each items[i] = [typei, colori, namei] describes the type, co...
 * >>> count_matches [[""car""; ""red""; ""ferrari""]; [""bike""; ""blue""; ""harley""]; [""car""; ""green""; ""lambo""]] ""color"" ""red""
 * 1
 * >>> count_matches [[""phone""; ""blue""; ""pixel""]; [""computer""; ""silver""; ""phone""]; [""phone""; ""gold""; ""iphone""]] ""type"" ""phone""
 * 2
 * >>> count_matches [[""laptop""; ""black""; ""dell""]; [""phone""; ""black""; ""samsung""]; [""tablet""; ""black""; ""ipad""]] ""color"" ""black""
 * 3
*)
let count_matches (items : string list list) (ruleKey : string) (ruleValue : string) : int =","  0","let () =
  assert (count_matches [[""car""; ""red""; ""ferrari""]; [""bike""; ""blue""; ""harley""]; [""car""; ""green""; ""lambo""]] ""color"" ""red"" = 1);
  assert (count_matches [[""phone""; ""blue""; ""pixel""]; [""computer""; ""silver""; ""phone""]; [""phone""; ""gold""; ""iphone""]] ""type"" ""phone"" = 2);
  assert (count_matches [[""laptop""; ""black""; ""dell""]; [""phone""; ""black""; ""samsung""]; [""tablet""; ""black""; ""ipad""]] ""color"" ""black"" = 3);
  assert (count_matches [[""laptop""; ""black""; ""dell""]; [""phone""; ""white""; ""samsung""]; [""tablet""; ""gray""; ""apple""]] ""name"" ""apple"" = 1);
  assert (count_matches [[""shirt""; ""white""; ""t-shirt""]; [""pants""; ""black""; ""jeans""]; [""shirt""; ""white""; ""dress-shirt""]] ""type"" ""shirt"" = 2);
  assert (count_matches [[""laptop""; ""black""; ""dell""]; [""tablet""; ""white""; ""samsung""]; [""laptop""; ""silver""; ""macbook""]] ""name"" ""dell"" = 1);
  assert (count_matches [[""shoe""; ""white""; ""nike""]; [""shirt""; ""black""; ""adidas""]; [""shoe""; ""black""; ""puma""]] ""type"" ""shoe"" = 2);
;;","easy"
"hard_029","(**There is a long and thin painting that can be represented by a number line. You are given a 0-ind...
 * >>> amount_painted [[0; 10]; [5; 15]; [10; 20]]
 * [10; 5; 5]
 * >>> amount_painted [[1; 2]; [2; 2]; [2; 3]; [3; 4]; [4; 4]]
 * [1; 0; 1; 1; 0]
 * >>> amount_painted [[0; 50000]; [1; 49999]]
 * [50000; 0]
*)
let amount_painted (paint : int list list) : int list =","  []","let () =
  assert (amount_painted [[0; 10]; [5; 15]; [10; 20]] = [10; 5; 5]);
  assert (amount_painted [[1; 2]; [2; 2]; [2; 3]; [3; 4]; [4; 4]] = [1; 0; 1; 1; 0]);
  assert (amount_painted [[0; 50000]; [1; 49999]] = [50000; 0]);
  assert (amount_painted [[1; 2]; [2; 3]; [3; 4]; [4; 5]; [5; 6]] = [1; 1; 1; 1; 1]);
  assert (amount_painted [[1; 2]; [2; 3]; [3; 4]; [4; 5]] = [1; 1; 1; 1]);
  assert (amount_painted [[1; 5]; [2; 4]] = [4; 0]);
  assert (amount_painted [[0; 1]; [1; 2]; [2; 3]; [3; 4]; [4; 5]] = [1; 1; 1; 1; 1]);
;;","hard"
"easy_135","(**You are given an array of distinct integers arr and an array of integer arrays pieces, where the ...
 * >>> can_form_array [10; 20; 30; 40; 50] [[10; 20]; [30; 40; 50]]
 * true
 * >>> can_form_array [1; 2; 3; 4; 5] [[2; 3]; [1; 4]; [5]]
 * false
 * >>> can_form_array [91; 4; 64; 78] [[78]; [4; 64]; [91]]
 * true
*)
let can_form_array (arr : int list) (pieces : int list list) : bool =","  false","let () =
  assert (can_form_array [10; 20; 30; 40; 50] [[10; 20]; [30; 40; 50]] = true);
  assert (can_form_array [1; 2; 3; 4; 5] [[2; 3]; [1; 4]; [5]] = false);
  assert (can_form_array [91; 4; 64; 78] [[78]; [4; 64]; [91]] = true);
  assert (can_form_array [49; 18; 16] [[16; 18; 49]] = false);
  assert (can_form_array [15; 88] [[88]; [15]] = true);
  assert (can_form_array [1; 2; 3; 4; 5] [[2]; [4; 5]; [3]; [1]] = true);
  assert (can_form_array [5; 9; 13; 17; 21; 25] [[5; 9; 13]; [17; 21; 25]] = true);
;;","easy"
"medium_079","(**Given the head of a linked list, we repeatedly delete consecutive sequences of nodes that sum to ...
 * >>> remove_zero_sum_sublists [0; 0; 0; 0]
 * None
 * >>> remove_zero_sum_sublists [1; 0; 1; -1; 2]
 * [1; 2]
 * >>> remove_zero_sum_sublists [1; 2; 3; 4; 5]
 * [1; 2; 3; 4; 5]
*)
let remove_zero_sum_sublists (head : 'a option) : 'a option =","  None","let () =
  assert (remove_zero_sum_sublists [0; 0; 0; 0] = None);
  assert (remove_zero_sum_sublists [1; 0; 1; -1; 2] = [1; 2]);
  assert (remove_zero_sum_sublists [1; 2; 3; 4; 5] = [1; 2; 3; 4; 5]);
  assert (remove_zero_sum_sublists [10; 20; -30; 40; -50; 60; -10; -50] = [40; -50]);
  assert (remove_zero_sum_sublists [1; -1; 1; -1] = None);
  assert (remove_zero_sum_sublists [1; 2; 3; -3; 4] = [1; 2; 4]);
  assert (remove_zero_sum_sublists [1; -1; 2; -2; 3] = [3]);
;;","medium"
"hard_084","(**You are given an array nums consisting of non-negative integers. You are also given a queries arr...
 * >>> maximize_xor [1; 2; 4; 8; 16] [[10; 15]; [30; 20]; [5; 5]]
 * [14; 31; 7]
 * >>> maximize_xor [100; 200; 300; 400] [[150; 250]; [10; 100]; [450; 500]]
 * [242; 110; 422]
 * >>> maximize_xor [7; 8; 9] [[1; 5]; [6; 8]; [10; 12]]
 * [-1; 14; 13]
*)
let maximize_xor (nums : int list) (queries : int list list) : int list =","  []","let () =
  assert (maximize_xor [1; 2; 4; 8; 16] [[10; 15]; [30; 20]; [5; 5]] = [14; 31; 7]);
  assert (maximize_xor [100; 200; 300; 400] [[150; 250]; [10; 100]; [450; 500]] = [242; 110; 422]);
  assert (maximize_xor [7; 8; 9] [[1; 5]; [6; 8]; [10; 12]] = [-1; 14; 13]);
  assert (maximize_xor [1; 1; 1; 1; 1; 1; 1; 1; 1; 1] [[1; 1]; [1; 1]; [1; 1]; [1; 1]; [1; 1]; [1; 1]; [1; 1]; [1; 1]; [1; 1]; [1; 1]] = [0; 0; 0; 0; 0; 0; 0; 0; 0; 0]);
  assert (maximize_xor [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] [[1; 10]; [2; 5]; [3; 3]; [4; 4]; [5; 2]; [6; 6]; [7; 7]; [8; 8]; [9; 9]; [10; 1]] = [11; 7; 2; 7; 7; 7; 6; 15; 15; 11]);
  assert (maximize_xor [1000000000] [[1000000000; 1000000000]; [999999999; 999999999]] = [0; -1]);
  assert (maximize_xor [5; 2; 4; 6; 6; 3] [[12; 4]; [8; 1]; [6; 3]] = [15; -1; 5]);
;;","hard"
"easy_102","(**There is a bag that consists of items, each itemÂ has a number 1, 0, or -1 written on it.
 * >>> k_items_with_maximum_sum 25 25 0 50
 * 25
 * >>> k_items_with_maximum_sum 0 50 0 10
 * 0
 * >>> k_items_with_maximum_sum 3 2 0 2
 * 2
*)
let k_items_with_maximum_sum (numOnes : int) (numZeros : int) (numNegOnes : int) (k : int) : int =","  0","let () =
  assert (k_items_with_maximum_sum 25 25 0 50 = 25);
  assert (k_items_with_maximum_sum 0 50 0 10 = 0);
  assert (k_items_with_maximum_sum 3 2 0 2 = 2);
  assert (k_items_with_maximum_sum 20 20 10 50 = 10);
  assert (k_items_with_maximum_sum 10 10 10 5 = 5);
  assert (k_items_with_maximum_sum 25 0 25 30 = 20);
  assert (k_items_with_maximum_sum 50 50 50 100 = 50);
;;","easy"
"medium_179","(**You have n bags numbered from 0 to n - 1. You are given two 0-indexed integer arrays capacity and...
 * >>> maximum_bags [2; 3; 4; 5] [1; 2; 4; 4] 2
 * 3
 * >>> maximum_bags [1; 2; 3] [0; 0; 0] 5
 * 2
 * >>> maximum_bags [3; 2; 1] [0; 0; 0] 5
 * 2
*)
let maximum_bags (capacity : int list) (rocks : int list) (additionalRocks : int) : int =","  0","let () =
  assert (maximum_bags [2; 3; 4; 5] [1; 2; 4; 4] 2 = 3);
  assert (maximum_bags [1; 2; 3] [0; 0; 0] 5 = 2);
  assert (maximum_bags [3; 2; 1] [0; 0; 0] 5 = 2);
  assert (maximum_bags [1; 1; 1] [0; 0; 0] 3 = 3);
  assert (maximum_bags [3; 9; 8] [0; 2; 5] 6 = 2);
  assert (maximum_bags [5; 5; 5; 5] [0; 0; 0; 0] 10 = 2);
  assert (maximum_bags [1; 1; 1; 1] [1; 1; 1; 1] 1 = 4);
;;","medium"
"easy_030","(**You are given an integer array nums. In one operation, you can add or subtract 1 from any element...
 * >>> minimum_operations [1; 2; 4; 5]
 * 4
 * >>> minimum_operations [1; 1; 1; 1]
 * 4
 * >>> minimum_operations [3; 3; 3; 3]
 * 0
*)
let minimum_operations (nums : int list) : int =","  0","let () =
  assert (minimum_operations [1; 2; 4; 5] = 4);
  assert (minimum_operations [1; 1; 1; 1] = 4);
  assert (minimum_operations [3; 3; 3; 3] = 0);
  assert (minimum_operations [1; 2; 4; 5; 7] = 5);
  assert (minimum_operations [1; 2; 4; 5; 7; 8] = 6);
  assert (minimum_operations [11; 22; 33; 44] = 3);
  assert (minimum_operations [15; 18; 21; 24] = 0);
;;","easy"
"easy_140","(**Given an integer array nums, return the largest perimeter of a triangle with a non-zero area, for...
 * >>> largest_perimeter [10; 5; 7]
 * 22
 * >>> largest_perimeter [10; 5; 1; 8; 12; 10; 5; 15]
 * 37
 * >>> largest_perimeter [7; 10; 5; 2; 8; 7]
 * 25
*)
let largest_perimeter (nums : int list) : int =","  0","let () =
  assert (largest_perimeter [10; 5; 7] = 22);
  assert (largest_perimeter [10; 5; 1; 8; 12; 10; 5; 15] = 37);
  assert (largest_perimeter [7; 10; 5; 2; 8; 7] = 25);
  assert (largest_perimeter [1; 1; 1; 1] = 3);
  assert (largest_perimeter [1; 1; 1] = 3);
  assert (largest_perimeter [1; 1000000; 1000000] = 2000001);
  assert (largest_perimeter [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = 27);
;;","easy"
"hard_018","(**You are given an array of n strings strs, all of the same length.
 * >>> min_deletion_size [""zyx""; ""zyx""; ""zyx""]
 * 2
 * >>> min_deletion_size [""rrjk""; ""furt""; ""guzm""]
 * 2
 * >>> min_deletion_size [""axx""; ""ggs""; ""zzz""]
 * 0
*)
let min_deletion_size (strs : string list) : int =","  0","let () =
  assert (min_deletion_size [""zyx""; ""zyx""; ""zyx""] = 2);
  assert (min_deletion_size [""rrjk""; ""furt""; ""guzm""] = 2);
  assert (min_deletion_size [""axx""; ""ggs""; ""zzz""] = 0);
  assert (min_deletion_size [""ghi""; ""def""; ""abc""] = 0);
  assert (min_deletion_size [""aaa""; ""bbb""; ""ccc""] = 0);
  assert (min_deletion_size [""abc""; ""bcd""; ""cde""] = 0);
  assert (min_deletion_size [""abc""; ""abc""; ""abc""] = 0);
;;","hard"
"easy_037","(**The complement of an integer is the integer you get when you flip all the 0's to 1's and all the ...
 * >>> find_complement 31
 * 0
 * >>> find_complement 10
 * 5
 * >>> find_complement 32
 * 31
*)
let find_complement (num : int) : int =","  0","let () =
  assert (find_complement 31 = 0);
  assert (find_complement 10 = 5);
  assert (find_complement 32 = 31);
  assert (find_complement 5 = 2);
  assert (find_complement 1023 = 0);
  assert (find_complement 1 = 0);
  assert (find_complement 100 = 27);
;;","easy"
