"problem","solution","tests","difficulty","__metadata:id","__metadata:difficulty"
"(**You are given a positive integer 0-indexed array nums.
 * >>> square_free_subsets [1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1]
 * 147483633.0
 * >>> square_free_subsets [2; 3; 5; 7; 11]
 * 31.0
 * >>> square_free_subsets [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
 * 47.0
*)
let square_free_subsets (nums : int list) : int =","  0","let () =
  assert (square_free_subsets [1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1] = 147483633.0);
  assert (square_free_subsets [2; 3; 5; 7; 11] = 31.0);
  assert (square_free_subsets [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = 47.0);
  assert (square_free_subsets [1; 2; 3; 6; 7; 14; 21; 42] = 27.0);
  assert (square_free_subsets [1] = 1.0);
  assert (square_free_subsets [10; 14; 15; 21; 22; 26; 33; 34; 35; 38; 39; 46; 51; 55; 57; 58; 62; 65; 66; 69; 74; 77; 78; 82; 85; 86; 87; 91; 93; 94; 95; 102; 105; 106; 111; 114; 115; 118; 119; 122; 123; 126; 129; 130; 133; 134; 138; 139; 141; 142; 143; 145; 146; 147; 154; 155; 158; 159; 161; 165; 166; 171; 172; 174; 177; 178; 182; 183; 185; 186; 187; 189; 190; 194; 195; 201; 202; 203; 205; 206; 207; 209; 210; 213; 214; 215; 217; 218; 219; 221; 222; 223; 225; 226; 229; 231; 235; 237; 238; 242; 246; 247; 249; 253; 254; 255; 258; 259; 261; 262; 265; 266; 267; 273; 274; 278; 282; 285; 286; 287; 291; 295; 298; 299; 301; 302; 303; 305; 306; 309; 310; 314; 315; 318; 319; 321; 322; 323; 326; 327; 329; 334; 335; 338; 339; 341; 345; 346; 351; 354; 355; 357; 358; 359; 362; 365; 366; 371; 374; 377; 378; 381; 382; 385; 386; 387; 391; 393; 394; 395; 398; 399; 402; 403; 405; 406; 407; 411; 413; 415; 417; 418; 422; 423; 426; 427; 429; 434; 435; 437; 438; 442; 445; 446; 447; 451; 453; 454; 455; 458; 459; 462; 465; 466; 469; 471; 473; 474; 478; 479; 481; 483; 485; 489; 493; 494; 495; 497; 501] = 12.0);
  assert (square_free_subsets [30; 30; 30; 30; 30] = 5.0);
;;","medium","medium_160","medium"
"(**You have two fruit baskets containing n fruits each. You are given two 0-indexed integer arrays b...
 * >>> min_cost [1000000000; 1000000000] [1000000000; 1000000000]
 * 0
 * >>> min_cost [2; 3; 4; 1] [3; 2; 5; 1]
 * -1
 * >>> min_cost [1; 1; 2; 2] [2; 2; 1; 1]
 * 0
*)
let min_cost (basket1 : int list) (basket2 : int list) : int =","  0","let () =
  assert (min_cost [1000000000; 1000000000] [1000000000; 1000000000] = 0);
  assert (min_cost [2; 3; 4; 1] [3; 2; 5; 1] = -1);
  assert (min_cost [1; 1; 2; 2] [2; 2; 1; 1] = 0);
  assert (min_cost [5; 7; 10; 15] [15; 10; 7; 5] = 0);
  assert (min_cost [1; 2; 3] [3; 2; 1] = 0);
  assert (min_cost [1; 2; 3; 4; 5] [5; 4; 3; 2; 1] = 0);
  assert (min_cost [1; 3; 5; 7; 9] [2; 4; 6; 8; 10] = -1);
;;","hard","hard_031","hard"
"(**Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it...
 * >>> smaller_numbers_than_current [0; 0; 0; 0; 0; 0; 0; 0; 0; 0]
 * [0; 0; 0; 0; 0; 0; 0; 0; 0; 0]
 * >>> smaller_numbers_than_current [5; 5; 5; 5; 5; 5; 5; 5]
 * [0; 0; 0; 0; 0; 0; 0; 0]
 * >>> smaller_numbers_than_current [8; 1; 2; 2; 3]
 * [4; 0; 1; 1; 3]
*)
let smaller_numbers_than_current (nums : int list) : int list =","  []","let () =
  assert (smaller_numbers_than_current [0; 0; 0; 0; 0; 0; 0; 0; 0; 0] = [0; 0; 0; 0; 0; 0; 0; 0; 0; 0]);
  assert (smaller_numbers_than_current [5; 5; 5; 5; 5; 5; 5; 5] = [0; 0; 0; 0; 0; 0; 0; 0]);
  assert (smaller_numbers_than_current [8; 1; 2; 2; 3] = [4; 0; 1; 1; 3]);
  assert (smaller_numbers_than_current [100; 99; 98; 97; 96] = [4; 3; 2; 1; 0]);
  assert (smaller_numbers_than_current [0; 0; 1; 1; 2; 2; 3; 3] = [0; 0; 2; 2; 4; 4; 6; 6]);
  assert (smaller_numbers_than_current [100; 99; 98; 97] = [3; 2; 1; 0]);
  assert (smaller_numbers_than_current [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = [0; 1; 2; 3; 4; 5; 6; 7; 8; 9]);
;;","easy","easy_096","easy"
"(**A password is said to be strong if it satisfies all the following criteria:
 * >>> strong_password_checker_ii ""IloveLe3tcode!""
 * true
 * >>> strong_password_checker_ii ""Me+You--IsMyDream""
 * false
 * >>> strong_password_checker_ii ""1aB!""
 * false
*)
let strong_password_checker_ii (password : string) : bool =","  false","let () =
  assert (strong_password_checker_ii ""IloveLe3tcode!"" = true);
  assert (strong_password_checker_ii ""Me+You--IsMyDream"" = false);
  assert (strong_password_checker_ii ""1aB!"" = false);
  assert (strong_password_checker_ii ""OneSpecialChar@"" = false);
  assert (strong_password_checker_ii ""EndsWithSpecialChar!"" = false);
  assert (strong_password_checker_ii ""ValidPass1@"" = false);
  assert (strong_password_checker_ii ""lowercaseonly"" = false);
;;","easy","easy_025","easy"
"(**Given an integer num, return the number of steps to reduce it to zero.
 * >>> number_of_steps 14
 * 6
 * >>> number_of_steps 1000000
 * 26
 * >>> number_of_steps 8
 * 4
*)
let number_of_steps (num : int) : int =","  0","let () =
  assert (number_of_steps 14 = 6);
  assert (number_of_steps 1000000 = 26);
  assert (number_of_steps 8 = 4);
  assert (number_of_steps 65535 = 31);
  assert (number_of_steps 0 = 0);
  assert (number_of_steps 2 = 2);
  assert (number_of_steps 1 = 1);
;;","easy","easy_199","easy"
"(**With respect to a given puzzle string, a word is valid if both the following conditions are satis...
 * >>> find_num_of_valid_words [""apple""; ""pleas""; ""please""] [""aelwxyz""; ""aelpxyz""; ""aelpsxy""; ""saelpxy""; ""xaelpsy""]
 * [0; 1; 3; 2; 0]
 * >>> find_num_of_valid_words [""hello""; ""world""; ""abc""; ""def""; ""ghi""] [""ahelloz""; ""dworldz""; ""abcdefg""; ""xyzghif""; ""mnopqrs""]
 * [0; 1; 1; 0; 0]
 * >>> find_num_of_valid_words [""aaaa""; ""asas""; ""able""; ""ability""; ""actt""; ""actor""; ""access""] [""aboveyz""; ""abrodyz""; ""abslute""; ""absoryz""; ""actresz""; ""gaswxyz""]
 * [1; 1; 3; 2; 4; 0]
*)
let find_num_of_valid_words (words : string list) (puzzles : string list) : int list =","  []","let () =
  assert (find_num_of_valid_words [""apple""; ""pleas""; ""please""] [""aelwxyz""; ""aelpxyz""; ""aelpsxy""; ""saelpxy""; ""xaelpsy""] = [0; 1; 3; 2; 0]);
  assert (find_num_of_valid_words [""hello""; ""world""; ""abc""; ""def""; ""ghi""] [""ahelloz""; ""dworldz""; ""abcdefg""; ""xyzghif""; ""mnopqrs""] = [0; 1; 1; 0; 0]);
  assert (find_num_of_valid_words [""aaaa""; ""asas""; ""able""; ""ability""; ""actt""; ""actor""; ""access""] [""aboveyz""; ""abrodyz""; ""abslute""; ""absoryz""; ""actresz""; ""gaswxyz""] = [1; 1; 3; 2; 4; 0]);
  assert (find_num_of_valid_words [""hello""; ""world""] [""ehlol""; ""dlrow""] = [1; 1]);
  assert (find_num_of_valid_words [""cat""; ""dog""; ""bird""] [""act""; ""dgo""; ""bdir""] = [1; 1; 1]);
  assert (find_num_of_valid_words [""zzzz""; ""zzz""; ""zz""; ""z""] [""zabcdefghijklmnopqrstuvwxy""] = [4]);
  assert (find_num_of_valid_words [""aaaa""; ""aaa""; ""aa""; ""a""] [""abcdefg""; ""gfedcba""; ""agfedcb""; ""bagfedc""; ""cagfedb""] = [4; 0; 4; 0; 0]);
;;","hard","hard_086","hard"
"(**You are given a positive integer arrivalTime denoting the arrival time of a train in hours, and a...
 * >>> find_delayed_arrival_time 5 19
 * 0
 * >>> find_delayed_arrival_time 8 16
 * 0
 * >>> find_delayed_arrival_time 13 11
 * 0
*)
let find_delayed_arrival_time (arrivalTime : int) (delayedTime : int) : int =","  0","let () =
  assert (find_delayed_arrival_time 5 19 = 0);
  assert (find_delayed_arrival_time 8 16 = 0);
  assert (find_delayed_arrival_time 13 11 = 0);
  assert (find_delayed_arrival_time 15 5 = 20);
  assert (find_delayed_arrival_time 1 1 = 2);
  assert (find_delayed_arrival_time 12 12 = 0);
  assert (find_delayed_arrival_time 1 23 = 0);
;;","easy","easy_176","easy"
"(**You are given an integer n indicating the number of people in a network. Each person is labeled f...
 * >>> friend_requests 4 [[0; 2]; [1; 3]] [[0; 1]; [2; 3]; [0; 3]]
 * [true; true; false]
 * >>> friend_requests 4 [] [[0; 1]; [1; 2]; [2; 3]; [3; 0]]
 * [true; true; true; true]
 * >>> friend_requests 4 [[0; 2]; [1; 3]] [[0; 1]; [2; 3]; [1; 2]]
 * [true; true; false]
*)
let friend_requests (n : int) (restrictions : int list list) (requests : int list list) : bool list =","  []","let () =
  assert (friend_requests 4 [[0; 2]; [1; 3]] [[0; 1]; [2; 3]; [0; 3]] = [true; true; false]);
  assert (friend_requests 4 [] [[0; 1]; [1; 2]; [2; 3]; [3; 0]] = [true; true; true; true]);
  assert (friend_requests 4 [[0; 2]; [1; 3]] [[0; 1]; [2; 3]; [1; 2]] = [true; true; false]);
  assert (friend_requests 5 [[0; 1]; [1; 2]; [2; 3]] [[0; 4]; [1; 2]; [3; 1]; [3; 4]] = [true; false; true; false]);
  assert (friend_requests 6 [[1; 4]; [2; 5]] [[0; 3]; [1; 2]; [3; 4]] = [true; true; true]);
  assert (friend_requests 6 [[0; 1]; [2; 3]; [4; 5]] [[0; 2]; [1; 3]; [2; 4]; [3; 5]; [4; 0]; [5; 1]] = [true; true; true; true; true; true]);
  assert (friend_requests 6 [[0; 1]; [2; 3]; [4; 5]] [[0; 2]; [1; 3]; [4; 5]; [2; 4]] = [true; true; false; true]);
;;","hard","hard_072","hard"
"(**You are given a string s and an integer array indices of the same length. The string s will be sh...
 * >>> restore_string ""codeleet"" [4; 5; 6; 7; 0; 2; 1; 3]
 * leetcode
 * >>> restore_string ""aaiougrt"" [4; 0; 2; 6; 7; 3; 1; 5]
 * arigatou
 * >>> restore_string ""aiohn"" [3; 1; 4; 2; 0]
 * nihao
*)
let restore_string (s : string) (indices : int list) : string =","  """"","let () =
  assert (restore_string ""codeleet"" [4; 5; 6; 7; 0; 2; 1; 3] = leetcode);
  assert (restore_string ""aaiougrt"" [4; 0; 2; 6; 7; 3; 1; 5] = arigatou);
  assert (restore_string ""aiohn"" [3; 1; 4; 2; 0] = nihao);
  assert (restore_string ""abc"" [0; 1; 2] = abc);
  assert (restore_string ""art"" [1; 0; 2] = rat);
  assert (restore_string ""abcdefgh"" [7; 6; 5; 4; 3; 2; 1; 0] = hgfedcba);
  assert (restore_string ""permutation"" [8; 5; 4; 10; 0; 9; 2; 6; 3; 1; 7] = uoairetnptm);
;;","easy","easy_150","easy"
"(**You are given two m x n binary matrices grid1 and grid2 containing only 0's (representing water) ...
 * >>> count_sub_islands [[1; 1; 0; 0; 0]; [1; 1; 0; 0; 0]; [0; 0; 1; 1; 1]; [0; 0; 1; 1; 1]; [0; 0; 0; 0; 0]] [[1; 1; 0; 0; 0]; [1; 0; 0; 0; 0]; [0; 0; 1; 1; 1]; [0; 0; 1; 1; 0]; [0; 0; 0; 0; 1]]
 * 2
 * >>> count_sub_islands [[1; 1; 1; 1; 1]; [1; 1; 1; 1; 1]; [1; 1; 1; 1; 1]; [1; 1; 1; 1; 1]; [1; 1; 1; 1; 1]] [[0; 0; 0; 0; 0]; [0; 0; 0; 0; 0]; [0; 0; 0; 0; 0]; [0; 0; 0; 0; 0]; [0; 0; 0; 0; 0]]
 * 0
 * >>> count_sub_islands [[1; 1; 0; 0; 0]; [1; 1; 0; 0; 0]; [0; 0; 0; 1; 1]; [0; 0; 0; 1; 1]] [[1; 1; 0; 0; 0]; [1; 0; 0; 0; 0]; [0; 0; 0; 1; 1]; [0; 0; 0; 0; 0]]
 * 2
*)
let count_sub_islands (grid1 : int list list) (grid2 : int list list) : int =","  0","let () =
  assert (count_sub_islands [[1; 1; 0; 0; 0]; [1; 1; 0; 0; 0]; [0; 0; 1; 1; 1]; [0; 0; 1; 1; 1]; [0; 0; 0; 0; 0]] [[1; 1; 0; 0; 0]; [1; 0; 0; 0; 0]; [0; 0; 1; 1; 1]; [0; 0; 1; 1; 0]; [0; 0; 0; 0; 1]] = 2);
  assert (count_sub_islands [[1; 1; 1; 1; 1]; [1; 1; 1; 1; 1]; [1; 1; 1; 1; 1]; [1; 1; 1; 1; 1]; [1; 1; 1; 1; 1]] [[0; 0; 0; 0; 0]; [0; 0; 0; 0; 0]; [0; 0; 0; 0; 0]; [0; 0; 0; 0; 0]; [0; 0; 0; 0; 0]] = 0);
  assert (count_sub_islands [[1; 1; 0; 0; 0]; [1; 1; 0; 0; 0]; [0; 0; 0; 1; 1]; [0; 0; 0; 1; 1]] [[1; 1; 0; 0; 0]; [1; 0; 0; 0; 0]; [0; 0; 0; 1; 1]; [0; 0; 0; 0; 0]] = 2);
  assert (count_sub_islands [[1; 1; 1]; [0; 0; 0]; [0; 0; 0]] [[1; 1; 1]; [0; 0; 0]; [0; 0; 0]] = 1);
  assert (count_sub_islands [[1; 0; 1; 0; 1]; [1; 1; 1; 1; 1]; [0; 0; 0; 0; 0]; [1; 1; 1; 1; 1]; [1; 0; 1; 0; 1]] [[0; 0; 0; 0; 0]; [1; 1; 1; 1; 1]; [0; 1; 0; 1; 0]; [0; 1; 0; 1; 0]; [1; 0; 0; 0; 1]] = 2);
  assert (count_sub_islands [[0; 0; 0]; [0; 0; 0]] [[0; 0; 0]; [0; 0; 0]] = 0);
  assert (count_sub_islands [[1; 1; 0; 1; 1]; [1; 0; 0; 0; 0]; [0; 0; 0; 0; 1]; [1; 1; 0; 1; 1]] [[1; 1; 0; 0; 0]; [1; 0; 1; 1; 1]; [0; 0; 0; 0; 1]; [1; 1; 0; 1; 1]] = 2);
;;","medium","medium_071","medium"
"(**You are given a 0-indexed integer array nums of length n.
 * >>> ways_to_split_array [-100000; -100000; -100000; -100000; -100000]
 * 2
 * >>> ways_to_split_array [1; -1; 1; -1; 1]
 * 2
 * >>> ways_to_split_array [100; -50; 50; -25; 25]
 * 4
*)
let ways_to_split_array (nums : int list) : int =","  0","let () =
  assert (ways_to_split_array [-100000; -100000; -100000; -100000; -100000] = 2);
  assert (ways_to_split_array [1; -1; 1; -1; 1] = 2);
  assert (ways_to_split_array [100; -50; 50; -25; 25] = 4);
  assert (ways_to_split_array [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = 3);
  assert (ways_to_split_array [1; -1; 1; -1; 1; -1] = 5);
  assert (ways_to_split_array [100000; -100000; 100000; -100000; 100000] = 2);
  assert (ways_to_split_array [100000; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0] = 19);
;;","medium","medium_085","medium"
"(**Given an array of integers nums, calculate the pivot index of this array.
 * >>> pivot_index [10; 9; 8; 7; 6; 5; 4; 3; 2; 1]
 * -1
 * >>> pivot_index [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
 * -1
 * >>> pivot_index [1]
 * 0
*)
let pivot_index (nums : int list) : int =","  0","let () =
  assert (pivot_index [10; 9; 8; 7; 6; 5; 4; 3; 2; 1] = -1);
  assert (pivot_index [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = -1);
  assert (pivot_index [1] = 0);
  assert (pivot_index [-1; -2; -3; -4; -5] = -1);
  assert (pivot_index [1; 2; 1] = 1);
  assert (pivot_index [-1; -1; -1; 0; -1; -1; -1] = 3);
  assert (pivot_index [1000; -1000] = -1);
;;","easy","easy_101","easy"
"(**Given an integer n, return the nth digit of the infinite integer sequence [1, 2, 3, 4, 5, 6, 7, 8...
 * >>> find_nth_digit 3
 * 3
 * >>> find_nth_digit 11
 * 0
 * >>> find_nth_digit 231
 * 3
*)
let find_nth_digit (n : int) : int =","  0","let () =
  assert (find_nth_digit 3 = 3);
  assert (find_nth_digit 11 = 0);
  assert (find_nth_digit 231 = 3);
  assert (find_nth_digit 15 = 2);
  assert (find_nth_digit 2147483647 = 2);
  assert (find_nth_digit 1000000 = 1);
  assert (find_nth_digit 123456789 = 2);
;;","medium","medium_068","medium"
"(**You are given a root, which is the root of a special binary tree with n nodes. The nodes of the s...
 * >>> height_of_tree [1; 2; 3; 4; 5; 6; 7]
 * 2
 * >>> height_of_tree [1; 2; 3; 4; null; null; 5; 6; null; 7]
 * 3
 * >>> height_of_tree [1; 2; 3; null; null; 4; null; 5; 6]
 * 3
*)
let height_of_tree (root : 'a option) : int =","  0","let () =
  assert (height_of_tree [1; 2; 3; 4; 5; 6; 7] = 2);
  assert (height_of_tree [1; 2; 3; 4; null; null; 5; 6; null; 7] = 3);
  assert (height_of_tree [1; 2; 3; null; null; 4; null; 5; 6] = 3);
  assert (height_of_tree [1; 2; 3; 4; null; null; 5; 6; null; 7; 8] = 3);
  assert (height_of_tree [1; 2] = 1);
  assert (height_of_tree [1; 2; 3; 4; 5; null; null; 6; 7; null; null; 8; 9] = 4);
  assert (height_of_tree [1; 2; 3; null; null; 4; 5] = 2);
;;","medium","medium_007","medium"
"(**Given a binary array nums, return the maximum length of a contiguous subarray with an equal numbe...
 * >>> find_max_length [0; 1; 1; 0; 1; 1; 0; 0]
 * 8
 * >>> find_max_length [1; 0; 0; 1; 0; 1; 1]
 * 6
 * >>> find_max_length [1; 0; 1; 0; 1; 0; 1; 0]
 * 8
*)
let find_max_length (nums : int list) : int =","  0","let () =
  assert (find_max_length [0; 1; 1; 0; 1; 1; 0; 0] = 8);
  assert (find_max_length [1; 0; 0; 1; 0; 1; 1] = 6);
  assert (find_max_length [1; 0; 1; 0; 1; 0; 1; 0] = 8);
  assert (find_max_length [0; 1; 1; 1; 1; 1; 0; 0; 0] = 6);
  assert (find_max_length [1; 1; 1; 1; 1; 1; 0; 0; 0; 0] = 8);
  assert (find_max_length [1; 1; 0; 1; 0; 1; 0; 0; 1; 1] = 8);
  assert (find_max_length [1; 1; 0; 0; 1; 1; 0; 0] = 8);
;;","medium","medium_001","medium"
"(**There is a long and thin painting that can be represented by a number line. You are given a 0-ind...
 * >>> amount_painted [[0; 10]; [5; 15]; [10; 20]]
 * [10; 5; 5]
 * >>> amount_painted [[1; 2]; [2; 2]; [2; 3]; [3; 4]; [4; 4]]
 * [1; 0; 1; 1; 0]
 * >>> amount_painted [[0; 50000]; [1; 49999]]
 * [50000; 0]
*)
let amount_painted (paint : int list list) : int list =","  []","let () =
  assert (amount_painted [[0; 10]; [5; 15]; [10; 20]] = [10; 5; 5]);
  assert (amount_painted [[1; 2]; [2; 2]; [2; 3]; [3; 4]; [4; 4]] = [1; 0; 1; 1; 0]);
  assert (amount_painted [[0; 50000]; [1; 49999]] = [50000; 0]);
  assert (amount_painted [[1; 2]; [2; 3]; [3; 4]; [4; 5]; [5; 6]] = [1; 1; 1; 1; 1]);
  assert (amount_painted [[1; 2]; [2; 3]; [3; 4]; [4; 5]] = [1; 1; 1; 1]);
  assert (amount_painted [[1; 5]; [2; 4]] = [4; 0]);
  assert (amount_painted [[0; 1]; [1; 2]; [2; 3]; [3; 4]; [4; 5]] = [1; 1; 1; 1; 1]);
;;","hard","hard_029","hard"
"(**You are given an array items, where each items[i] = [typei, colori, namei] describes the type, co...
 * >>> count_matches [[""car""; ""red""; ""ferrari""]; [""bike""; ""blue""; ""harley""]; [""car""; ""green""; ""lambo""]] ""color"" ""red""
 * 1
 * >>> count_matches [[""phone""; ""blue""; ""pixel""]; [""computer""; ""silver""; ""phone""]; [""phone""; ""gold""; ""iphone""]] ""type"" ""phone""
 * 2
 * >>> count_matches [[""laptop""; ""black""; ""dell""]; [""phone""; ""black""; ""samsung""]; [""tablet""; ""black""; ""ipad""]] ""color"" ""black""
 * 3
*)
let count_matches (items : string list list) (ruleKey : string) (ruleValue : string) : int =","  0","let () =
  assert (count_matches [[""car""; ""red""; ""ferrari""]; [""bike""; ""blue""; ""harley""]; [""car""; ""green""; ""lambo""]] ""color"" ""red"" = 1);
  assert (count_matches [[""phone""; ""blue""; ""pixel""]; [""computer""; ""silver""; ""phone""]; [""phone""; ""gold""; ""iphone""]] ""type"" ""phone"" = 2);
  assert (count_matches [[""laptop""; ""black""; ""dell""]; [""phone""; ""black""; ""samsung""]; [""tablet""; ""black""; ""ipad""]] ""color"" ""black"" = 3);
  assert (count_matches [[""laptop""; ""black""; ""dell""]; [""phone""; ""white""; ""samsung""]; [""tablet""; ""gray""; ""apple""]] ""name"" ""apple"" = 1);
  assert (count_matches [[""shirt""; ""white""; ""t-shirt""]; [""pants""; ""black""; ""jeans""]; [""shirt""; ""white""; ""dress-shirt""]] ""type"" ""shirt"" = 2);
  assert (count_matches [[""laptop""; ""black""; ""dell""]; [""tablet""; ""white""; ""samsung""]; [""laptop""; ""silver""; ""macbook""]] ""name"" ""dell"" = 1);
  assert (count_matches [[""shoe""; ""white""; ""nike""]; [""shirt""; ""black""; ""adidas""]; [""shoe""; ""black""; ""puma""]] ""type"" ""shoe"" = 2);
;;","easy","easy_041","easy"
"(**You are given an array of n strings strs, all of the same length.
 * >>> min_deletion_size [""zyx""; ""zyx""; ""zyx""]
 * 2
 * >>> min_deletion_size [""rrjk""; ""furt""; ""guzm""]
 * 2
 * >>> min_deletion_size [""axx""; ""ggs""; ""zzz""]
 * 0
*)
let min_deletion_size (strs : string list) : int =","  0","let () =
  assert (min_deletion_size [""zyx""; ""zyx""; ""zyx""] = 2);
  assert (min_deletion_size [""rrjk""; ""furt""; ""guzm""] = 2);
  assert (min_deletion_size [""axx""; ""ggs""; ""zzz""] = 0);
  assert (min_deletion_size [""ghi""; ""def""; ""abc""] = 0);
  assert (min_deletion_size [""aaa""; ""bbb""; ""ccc""] = 0);
  assert (min_deletion_size [""abc""; ""bcd""; ""cde""] = 0);
  assert (min_deletion_size [""abc""; ""abc""; ""abc""] = 0);
;;","hard","hard_018","hard"
"(**Given an array of strings nums containing n unique binary strings each of length n, return a bina...
 * >>> find_different_binary_string [""01""; ""10""]
 * 00
 * >>> find_different_binary_string [""1111""; ""1011""; ""0111""; ""0011""; ""1101""; ""1001""; ""0101""; ""0001""]
 * 00000000
 * >>> find_different_binary_string [""00""; ""01""]
 * 11
*)
let find_different_binary_string (nums : string list) : string =","  """"","let () =
  assert (find_different_binary_string [""01""; ""10""] = 00);
  assert (find_different_binary_string [""1111""; ""1011""; ""0111""; ""0011""; ""1101""; ""1001""; ""0101""; ""0001""] = 00000000);
  assert (find_different_binary_string [""00""; ""01""] = 11);
  assert (find_different_binary_string [""111""; ""011""; ""001""] = 000);
  assert (find_different_binary_string [""1101""; ""1011""; ""0111""; ""0011""] = 0000);
  assert (find_different_binary_string [""11110000""; ""00001111""; ""10101010""; ""01010101""; ""11001100""; ""00110011""; ""10000000""; ""01111111""; ""11011011""; ""00100100""; ""10100101""; ""01011010""; ""11100011""; ""00011100""; ""10011001""; ""01100110""] = 0000000000000000);
  assert (find_different_binary_string [""11110000""; ""00001111""; ""10101010""; ""01010101""; ""11001100""; ""00110011""; ""10011001""; ""01100110""; ""11010100""; ""00101011""; ""10111000""; ""01000111""; ""10001011""; ""01110100""; ""11000110""; ""00111001""] = 0000000000000000);
;;","medium","medium_056","medium"
"(**You are given a 2D binary array grid. Find a rectangle with horizontal and vertical sides with th...
 * >>> minimum_area [[0; 0; 0]; [0; 1; 0]; [0; 0; 0]]
 * 1
 * >>> minimum_area [[0; 0; 0]; [0; 0; 0]; [1; 0; 0]]
 * 1
 * >>> minimum_area [[1; 0; 0; 0; 0]; [0; 0; 0; 0; 0]; [0; 0; 0; 0; 0]; [0; 0; 0; 0; 1]]
 * 20
*)
let minimum_area (grid : int list list) : int =","  0","let () =
  assert (minimum_area [[0; 0; 0]; [0; 1; 0]; [0; 0; 0]] = 1);
  assert (minimum_area [[0; 0; 0]; [0; 0; 0]; [1; 0; 0]] = 1);
  assert (minimum_area [[1; 0; 0; 0; 0]; [0; 0; 0; 0; 0]; [0; 0; 0; 0; 0]; [0; 0; 0; 0; 1]] = 20);
  assert (minimum_area [[0; 0; 0; 1]; [0; 1; 0; 0]; [1; 0; 0; 0]] = 12);
  assert (minimum_area [[1; 0]; [0; 0]] = 1);
  assert (minimum_area [[1; 1; 1]; [1; 1; 1]; [1; 1; 1]] = 9);
  assert (minimum_area [[1; 0; 1; 0; 1]] = 5);
;;","medium","medium_132","medium"
"(**You are given two positive integers n and k.
 * >>> min_changes 1 2
 * -1
 * >>> min_changes 31 1
 * 4
 * >>> min_changes 15 9
 * 2
*)
let min_changes (n : int) (k : int) : int =","  0","let () =
  assert (min_changes 1 2 = -1);
  assert (min_changes 31 1 = 4);
  assert (min_changes 15 9 = 2);
  assert (min_changes 8 8 = 0);
  assert (min_changes 1000000 999999 = -1);
  assert (min_changes 7 11 = -1);
  assert (min_changes 7 3 = 1);
;;","easy","easy_179","easy"
"(**Given an array of integers arr, return true if and only if it is a valid mountain array.
 * >>> valid_mountain_array [5; 4; 3; 2; 1]
 * false
 * >>> valid_mountain_array [9; 8; 7; 6; 5; 4; 3; 2; 1; 0]
 * false
 * >>> valid_mountain_array [3; 1; 2]
 * false
*)
let valid_mountain_array (arr : int list) : bool =","  false","let () =
  assert (valid_mountain_array [5; 4; 3; 2; 1] = false);
  assert (valid_mountain_array [9; 8; 7; 6; 5; 4; 3; 2; 1; 0] = false);
  assert (valid_mountain_array [3; 1; 2] = false);
  assert (valid_mountain_array [1; 2; 3; 4; 5; 6; 7; 8; 9; 8; 7; 6; 5; 4; 3; 2; 1] = true);
  assert (valid_mountain_array [1; 2] = false);
  assert (valid_mountain_array [0; 2; 3; 3; 2; 1] = false);
  assert (valid_mountain_array [0; 1; 2; 3; 4; 5; 4; 3; 2; 1] = true);
;;","easy","easy_156","easy"
"(**Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all th...
 * >>> find_disappeared_numbers [5; 4; 3; 2; 1]
 * []
 * >>> find_disappeared_numbers [10; 2; 3; 4; 5; 6; 7; 8; 9; 1]
 * []
 * >>> find_disappeared_numbers [1; 1]
 * [2]
*)
let find_disappeared_numbers (nums : int list) : int list =","  []","let () =
  assert (find_disappeared_numbers [5; 4; 3; 2; 1] = []);
  assert (find_disappeared_numbers [10; 2; 3; 4; 5; 6; 7; 8; 9; 1] = []);
  assert (find_disappeared_numbers [1; 1] = [2]);
  assert (find_disappeared_numbers [4; 3; 2; 7; 8; 2; 3; 1] = [5; 6]);
  assert (find_disappeared_numbers [1; 2; 2; 3; 3; 4; 4; 5; 5] = [6; 7; 8; 9]);
  assert (find_disappeared_numbers [3; 3; 3; 3; 3] = [1; 2; 4; 5]);
  assert (find_disappeared_numbers [10; 9; 8; 7; 6; 5; 4; 3; 2; 1] = []);
;;","easy","easy_009","easy"
"(**An integer divisible by the sum of its digits is said to be a Harshad number. You are given an in...
 * >>> sum_of_the_digits_of_harshad_number 50
 * 5
 * >>> sum_of_the_digits_of_harshad_number 23
 * -1
 * >>> sum_of_the_digits_of_harshad_number 10
 * 1
*)
let sum_of_the_digits_of_harshad_number (x : int) : int =","  0","let () =
  assert (sum_of_the_digits_of_harshad_number 50 = 5);
  assert (sum_of_the_digits_of_harshad_number 23 = -1);
  assert (sum_of_the_digits_of_harshad_number 10 = 1);
  assert (sum_of_the_digits_of_harshad_number 18 = 9);
  assert (sum_of_the_digits_of_harshad_number 1 = 1);
  assert (sum_of_the_digits_of_harshad_number 90 = 9);
  assert (sum_of_the_digits_of_harshad_number 57 = -1);
;;","easy","easy_108","easy"
"(**You are given a 0-indexed 2D integer array of events where events[i] = [startTimei, endTimei, val...
 * >>> max_two_events [[1; 1000000000; 1000000]; [1000000000; 1000000000; 1000000]]
 * 1000000
 * >>> max_two_events [[1; 10; 1]; [2; 3; 2]; [4; 5; 3]; [6; 7; 4]; [8; 9; 5]]
 * 9
 * >>> max_two_events [[1; 1; 1]; [2; 2; 2]; [3; 3; 3]; [4; 4; 4]; [5; 5; 5]; [6; 6; 6]; [7; 7; 7]; [8; 8; 8]; [9; 9; 9]; [10; 10; 10]]
 * 19
*)
let max_two_events (events : int list list) : int =","  0","let () =
  assert (max_two_events [[1; 1000000000; 1000000]; [1000000000; 1000000000; 1000000]] = 1000000);
  assert (max_two_events [[1; 10; 1]; [2; 3; 2]; [4; 5; 3]; [6; 7; 4]; [8; 9; 5]] = 9);
  assert (max_two_events [[1; 1; 1]; [2; 2; 2]; [3; 3; 3]; [4; 4; 4]; [5; 5; 5]; [6; 6; 6]; [7; 7; 7]; [8; 8; 8]; [9; 9; 9]; [10; 10; 10]] = 19);
  assert (max_two_events [[10; 20; 15]; [20; 30; 10]; [1; 10; 5]] = 15);
  assert (max_two_events [[1; 10; 4]; [1; 10; 5]; [5; 10; 3]] = 5);
  assert (max_two_events [[1; 3; 2]; [4; 5; 2]; [2; 4; 3]] = 4);
  assert (max_two_events [[1; 3; 2]; [4; 5; 2]; [1; 5; 5]] = 5);
;;","medium","medium_152","medium"
"(**You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the f...
 * >>> pivot_array [0; 0; 1; 1; 0; 1; 0; 1; 0; 0] 0
 * [0; 0; 0; 0; 0; 0; 1; 1; 1; 1]
 * >>> pivot_array [1; 1; 1; 1; 1] 1
 * [1; 1; 1; 1; 1]
 * >>> pivot_array [0; 0; 1; 1; 0; 1; 0; 1; 0; 0] 1
 * [0; 0; 0; 0; 0; 0; 1; 1; 1; 1]
*)
let pivot_array (nums : int list) (pivot : int) : int list =","  []","let () =
  assert (pivot_array [0; 0; 1; 1; 0; 1; 0; 1; 0; 0] 0 = [0; 0; 0; 0; 0; 0; 1; 1; 1; 1]);
  assert (pivot_array [1; 1; 1; 1; 1] 1 = [1; 1; 1; 1; 1]);
  assert (pivot_array [0; 0; 1; 1; 0; 1; 0; 1; 0; 0] 1 = [0; 0; 0; 0; 0; 0; 1; 1; 1; 1]);
  assert (pivot_array [5; 4; 3; 2; 1] 3 = [2; 1; 3; 5; 4]);
  assert (pivot_array [10; 10; 10; 10] 10 = [10; 10; 10; 10]);
  assert (pivot_array [5; 5; 5; 5; 5] 5 = [5; 5; 5; 5; 5]);
  assert (pivot_array [4; 3; 2; 2; 5; 2; 3] 2 = [2; 2; 2; 4; 3; 5; 3]);
;;","medium","medium_058","medium"
"(**You are given an 8 x 8 matrix representing a chessboard. There is exactly one white rook represen...
 * >>> num_rook_captures [["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; ""p""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; ""p""; "".""; "".""; "".""; "".""]; [""p""; ""p""; "".""; ""R""; "".""; ""p""; ""B""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; ""B""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; ""p""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]]
 * 3
 * >>> num_rook_captures [["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; ""p""; ""p""; ""p""; ""p""; ""p""; "".""; "".""]; ["".""; ""p""; ""p""; ""B""; ""p""; ""p""; "".""; "".""]; ["".""; ""p""; ""B""; ""R""; ""B""; ""p""; "".""; "".""]; ["".""; ""p""; ""p""; ""B""; ""p""; ""p""; "".""; "".""]; ["".""; ""p""; ""p""; ""p""; ""p""; ""p""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]]
 * 0
 * >>> num_rook_captures [["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; ""p""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; ""R""; "".""; "".""; "".""; ""p""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; ""p""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]]
 * 3
*)
let num_rook_captures (board : string list list) : int =","  0","let () =
  assert (num_rook_captures [["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; ""p""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; ""p""; "".""; "".""; "".""; "".""]; [""p""; ""p""; "".""; ""R""; "".""; ""p""; ""B""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; ""B""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; ""p""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]] = 3);
  assert (num_rook_captures [["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; ""p""; ""p""; ""p""; ""p""; ""p""; "".""; "".""]; ["".""; ""p""; ""p""; ""B""; ""p""; ""p""; "".""; "".""]; ["".""; ""p""; ""B""; ""R""; ""B""; ""p""; "".""; "".""]; ["".""; ""p""; ""p""; ""B""; ""p""; ""p""; "".""; "".""]; ["".""; ""p""; ""p""; ""p""; ""p""; ""p""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]] = 0);
  assert (num_rook_captures [["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; ""p""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; ""R""; "".""; "".""; "".""; ""p""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; ""p""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]] = 3);
  assert (num_rook_captures [["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; ""p""; ""p""; ""p""; "".""; "".""; "".""]; [""p""; "".""; ""B""; ""R""; "".""; ""B""; ""p""; "".""]; ["".""; "".""; ""p""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; ""p""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]] = 1);
  assert (num_rook_captures [["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; ""R""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; ""p""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; ""p""]] = 0);
  assert (num_rook_captures [["".""; "".""; ""p""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; ""p""; "".""; "".""; "".""]; [""p""; "".""; "".""; "".""; "".""; "".""; ""p""; "".""]; ["".""; "".""; "".""; ""R""; "".""; "".""; "".""; "".""]; ["".""; "".""; ""p""; "".""; "".""; ""p""; "".""; "".""]; ["".""; ""B""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; ""p""; "".""; "".""; "".""; "".""; "".""; "".""]] = 0);
  assert (num_rook_captures [["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; ""R""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; ""p""; ""p""; ""p""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]] = 0);
;;","easy","easy_052","easy"
"(**Given the coordinates of two rectilinear rectangles in a 2D plane, return the total area covered ...
 * >>> compute_area -2 -2 2 2 -2 -2 2 2
 * 16
 * >>> compute_area 1 1 3 3 2 2 4 4
 * 7
 * >>> compute_area 0 0 5 5 5 5 10 10
 * 50
*)
let compute_area (ax1 : int) (ay1 : int) (ax2 : int) (ay2 : int) (bx1 : int) (by1 : int) (bx2 : int) (by2 : int) : int =","  0","let () =
  assert (compute_area -2 -2 2 2 -2 -2 2 2 = 16);
  assert (compute_area 1 1 3 3 2 2 4 4 = 7);
  assert (compute_area 0 0 5 5 5 5 10 10 = 50);
  assert (compute_area -3 0 3 4 0 -1 9 2 = 45);
  assert (compute_area -5 -5 0 0 -3 -3 3 3 = 52);
  assert (compute_area -5 -5 0 0 -3 -3 -1 -1 = 25);
  assert (compute_area 1 1 4 5 2 2 5 6 = 18);
;;","medium","medium_042","medium"
"(**You are given an integer array nums consisting of 2 * n integers.
 * >>> divide_array [4; 4; 4; 4; 4; 4; 4; 4]
 * true
 * >>> divide_array [1; 1; 1; 1; 2; 2; 2; 2]
 * true
 * >>> divide_array [1; 2; 1; 3; 2; 3]
 * true
*)
let divide_array (nums : int list) : bool =","  false","let () =
  assert (divide_array [4; 4; 4; 4; 4; 4; 4; 4] = true);
  assert (divide_array [1; 1; 1; 1; 2; 2; 2; 2] = true);
  assert (divide_array [1; 2; 1; 3; 2; 3] = true);
  assert (divide_array [1; 1; 2; 2; 3; 3; 4; 4] = true);
  assert (divide_array [100; 100; 200; 200; 300; 300] = true);
  assert (divide_array [100; 200; 100; 200; 100; 200] = false);
  assert (divide_array [4; 4; 5; 5; 6; 6; 7; 7] = true);
;;","easy","easy_097","easy"
"(**There is a 1-indexed 8 x 8 chessboard containing 3 pieces.
 * >>> min_moves_to_capture_the_queen 4 4 7 7 3 3
 * 2
 * >>> min_moves_to_capture_the_queen 3 3 6 6 7 7
 * 1
 * >>> min_moves_to_capture_the_queen 7 2 2 7 4 4
 * 2
*)
let min_moves_to_capture_the_queen (a : int) (b : int) (c : int) (d : int) (e : int) (f : int) : int =","  0","let () =
  assert (min_moves_to_capture_the_queen 4 4 7 7 3 3 = 2);
  assert (min_moves_to_capture_the_queen 3 3 6 6 7 7 = 1);
  assert (min_moves_to_capture_the_queen 7 2 2 7 4 4 = 2);
  assert (min_moves_to_capture_the_queen 1 8 2 7 3 6 = 1);
  assert (min_moves_to_capture_the_queen 8 8 1 1 3 3 = 1);
  assert (min_moves_to_capture_the_queen 8 8 1 1 4 4 = 1);
  assert (min_moves_to_capture_the_queen 8 1 5 4 7 7 = 2);
;;","medium","medium_014","medium"
"(**Given an integer columnNumber, return its corresponding column title as it appears in an Excel sh...
 * >>> convert_to_title 1
 * A
 * >>> convert_to_title 28
 * AB
 * >>> convert_to_title 1045
 * ANE
*)
let convert_to_title (columnNumber : int) : string =","  """"","let () =
  assert (convert_to_title 1 = A);
  assert (convert_to_title 28 = AB);
  assert (convert_to_title 1045 = ANE);
  assert (convert_to_title 2147483647 = FXSHRXW);
  assert (convert_to_title 456976 = YYYZ);
  assert (convert_to_title 52 = AZ);
  assert (convert_to_title 701 = ZY);
;;","easy","easy_171","easy"
"(**There are n couples sitting in 2n seats arranged in a row and want to hold hands.
 * >>> min_swaps_couples [2; 0; 5; 4; 3; 1]
 * 1
 * >>> min_swaps_couples [0; 1; 2; 3]
 * 0
 * >>> min_swaps_couples [0; 2; 1; 3]
 * 1
*)
let min_swaps_couples (row : int list) : int =","  0","let () =
  assert (min_swaps_couples [2; 0; 5; 4; 3; 1] = 1);
  assert (min_swaps_couples [0; 1; 2; 3] = 0);
  assert (min_swaps_couples [0; 2; 1; 3] = 1);
  assert (min_swaps_couples [4; 3; 2; 1; 0; 5] = 2);
  assert (min_swaps_couples [2; 0; 5; 4; 3; 6; 7; 1] = 2);
  assert (min_swaps_couples [0; 2; 4; 6; 7; 1; 3; 5] = 3);
  assert (min_swaps_couples [0; 1; 2; 3; 4; 5] = 0);
;;","hard","hard_052","hard"
"(**You are given two integers n and x. You have to construct an array of positive integers nums of s...
 * >>> min_end 4 8
 * 11
 * >>> min_end 5 1
 * 9
 * >>> min_end 10 1
 * 19
*)
let min_end (n : int) (x : int) : int =","  0","let () =
  assert (min_end 4 8 = 11);
  assert (min_end 5 1 = 9);
  assert (min_end 10 1 = 19);
  assert (min_end 5 3 = 19);
  assert (min_end 2 7 = 15);
  assert (min_end 1 10 = 10);
  assert (min_end 10 16 = 25);
;;","medium","medium_120","medium"
"(**Given an integer numRows, return the first numRows of Pascal's triangle.
 * >>> generate 10
 * [[1]; [1; 1]; [1; 2; 1]; [1; 3; 3; 1]; [1; 4; 6; 4; 1]; [1; 5; 10; 10; 5; 1]; [1; 6; 15; 20; 15; 6; 1]; [1; 7; 21; 35; 35; 21; 7; 1]; [1; 8; 28; 56; 70; 56; 28; 8; 1]; [1; 9; 36; 84; 126; 126; 84; 36; 9; 1]]
 * >>> generate 3
 * [[1]; [1; 1]; [1; 2; 1]]
 * >>> generate 1
 * [[1]]
*)
let generate (numRows : int) : int list list =","  [[]]","let () =
  assert (generate 10 = [[1]; [1; 1]; [1; 2; 1]; [1; 3; 3; 1]; [1; 4; 6; 4; 1]; [1; 5; 10; 10; 5; 1]; [1; 6; 15; 20; 15; 6; 1]; [1; 7; 21; 35; 35; 21; 7; 1]; [1; 8; 28; 56; 70; 56; 28; 8; 1]; [1; 9; 36; 84; 126; 126; 84; 36; 9; 1]]);
  assert (generate 3 = [[1]; [1; 1]; [1; 2; 1]]);
  assert (generate 1 = [[1]]);
  assert (generate 5 = [[1]; [1; 1]; [1; 2; 1]; [1; 3; 3; 1]; [1; 4; 6; 4; 1]]);
  assert (generate 30 = [[1]; [1; 1]; [1; 2; 1]; [1; 3; 3; 1]; [1; 4; 6; 4; 1]; [1; 5; 10; 10; 5; 1]; [1; 6; 15; 20; 15; 6; 1]; [1; 7; 21; 35; 35; 21; 7; 1]; [1; 8; 28; 56; 70; 56; 28; 8; 1]; [1; 9; 36; 84; 126; 126; 84; 36; 9; 1]; [1; 10; 45; 120; 210; 252; 210; 120; 45; 10; 1]; [1; 11; 55; 165; 330; 462; 462; 330; 165; 55; 11; 1]; [1; 12; 66; 220; 495; 792; 924; 792; 495; 220; 66; 12; 1]; [1; 13; 78; 286; 715; 1287; 1716; 1716; 1287; 715; 286; 78; 13; 1]; [1; 14; 91; 364; 1001; 2002; 3003; 3432; 3003; 2002; 1001; 364; 91; 14; 1]; [1; 15; 105; 455; 1365; 3003; 5005; 6435; 6435; 5005; 3003; 1365; 455; 105; 15; 1]; [1; 16; 120; 560; 1820; 4368; 8008; 11440; 12870; 11440; 8008; 4368; 1820; 560; 120; 16; 1]; [1; 17; 136; 680; 2380; 6188; 12376; 19448; 24310; 24310; 19448; 12376; 6188; 2380; 680; 136; 17; 1]; [1; 18; 153; 816; 3060; 8568; 18564; 31824; 43758; 48620; 43758; 31824; 18564; 8568; 3060; 816; 153; 18; 1]; [1; 19; 171; 969; 3876; 11628; 27132; 50388; 75582; 92378; 92378; 75582; 50388; 27132; 11628; 3876; 969; 171; 19; 1]; [1; 20; 190; 1140; 4845; 15504; 38760; 77520; 125970; 167960; 184756; 167960; 125970; 77520; 38760; 15504; 4845; 1140; 190; 20; 1]; [1; 21; 210; 1330; 5985; 20349; 54264; 116280; 203490; 293930; 352716; 352716; 293930; 203490; 116280; 54264; 20349; 5985; 1330; 210; 21; 1]; [1; 22; 231; 1540; 7315; 26334; 74613; 170544; 319770; 497420; 646646; 705432; 646646; 497420; 319770; 170544; 74613; 26334; 7315; 1540; 231; 22; 1]; [1; 23; 253; 1771; 8855; 33649; 100947; 245157; 490314; 817190; 1144066; 1352078; 1352078; 1144066; 817190; 490314; 245157; 100947; 33649; 8855; 1771; 253; 23; 1]; [1; 24; 276; 2024; 10626; 42504; 134596; 346104; 735471; 1307504; 1961256; 2496144; 2704156; 2496144; 1961256; 1307504; 735471; 346104; 134596; 42504; 10626; 2024; 276; 24; 1]; [1; 25; 300; 2300; 12650; 53130; 177100; 480700; 1081575; 2042975; 3268760; 4457400; 5200300; 5200300; 4457400; 3268760; 2042975; 1081575; 480700; 177100; 53130; 12650; 2300; 300; 25; 1]; [1; 26; 325; 2600; 14950; 65780; 230230; 657800; 1562275; 3124550; 5311735; 7726160; 9657700; 10400600; 9657700; 7726160; 5311735; 3124550; 1562275; 657800; 230230; 65780; 14950; 2600; 325; 26; 1]; [1; 27; 351; 2925; 17550; 80730; 296010; 888030; 2220075; 4686825; 8436285; 13037895; 17383860; 20058300; 20058300; 17383860; 13037895; 8436285; 4686825; 2220075; 888030; 296010; 80730; 17550; 2925; 351; 27; 1]; [1; 28; 378; 3276; 20475; 98280; 376740; 1184040; 3108105; 6906900; 13123110; 21474180; 30421755; 37442160; 40116600; 37442160; 30421755; 21474180; 13123110; 6906900; 3108105; 1184040; 376740; 98280; 20475; 3276; 378; 28; 1]; [1; 29; 406; 3654; 23751; 118755; 475020; 1560780; 4292145; 10015005; 20030010; 34597290; 51895935; 67863915; 77558760; 77558760; 67863915; 51895935; 34597290; 20030010; 10015005; 4292145; 1560780; 475020; 118755; 23751; 3654; 406; 29; 1]]);
  assert (generate 17 = [[1]; [1; 1]; [1; 2; 1]; [1; 3; 3; 1]; [1; 4; 6; 4; 1]; [1; 5; 10; 10; 5; 1]; [1; 6; 15; 20; 15; 6; 1]; [1; 7; 21; 35; 35; 21; 7; 1]; [1; 8; 28; 56; 70; 56; 28; 8; 1]; [1; 9; 36; 84; 126; 126; 84; 36; 9; 1]; [1; 10; 45; 120; 210; 252; 210; 120; 45; 10; 1]; [1; 11; 55; 165; 330; 462; 462; 330; 165; 55; 11; 1]; [1; 12; 66; 220; 495; 792; 924; 792; 495; 220; 66; 12; 1]; [1; 13; 78; 286; 715; 1287; 1716; 1716; 1287; 715; 286; 78; 13; 1]; [1; 14; 91; 364; 1001; 2002; 3003; 3432; 3003; 2002; 1001; 364; 91; 14; 1]; [1; 15; 105; 455; 1365; 3003; 5005; 6435; 6435; 5005; 3003; 1365; 455; 105; 15; 1]; [1; 16; 120; 560; 1820; 4368; 8008; 11440; 12870; 11440; 8008; 4368; 1820; 560; 120; 16; 1]]);
  assert (generate 2 = [[1]; [1; 1]]);
;;","easy","easy_002","easy"
"(**You are given an integer num. You will apply the following steps exactly two times:
 * >>> max_diff 1001100
 * 8008800
 * >>> max_diff 9
 * 8
 * >>> max_diff 98789
 * 81018
*)
let max_diff (num : int) : int =","  0","let () =
  assert (max_diff 1001100 = 8008800);
  assert (max_diff 9 = 8);
  assert (max_diff 98789 = 81018);
  assert (max_diff 123456 = 820000);
  assert (max_diff 987654321 = 810000000);
  assert (max_diff 1000000 = 8000000);
  assert (max_diff 1221 = 8228);
;;","medium","medium_093","medium"
"(**You are given a 0-indexed integer array nums representing the contents of a pile, where nums[0] i...
 * >>> maximum_top [7; 7; 7; 7; 7] 2
 * 7
 * >>> maximum_top [9; 8; 7; 6; 5] 5
 * 9
 * >>> maximum_top [10] 2
 * 10
*)
let maximum_top (nums : int list) (k : int) : int =","  0","let () =
  assert (maximum_top [7; 7; 7; 7; 7] 2 = 7);
  assert (maximum_top [9; 8; 7; 6; 5] 5 = 9);
  assert (maximum_top [10] 2 = 10);
  assert (maximum_top [8; 6; 4; 2; 0] 7 = 8);
  assert (maximum_top [7; 7; 7; 7; 7] 3 = 7);
  assert (maximum_top [1000000000] 0 = 1000000000);
  assert (maximum_top [5; 4; 3; 2; 1] 2 = 5);
;;","medium","medium_030","medium"
"(**Given two strings: s1 and s2 with the same size, check if some permutation of string s1 can break...
 * >>> check_if_can_break ""same"" ""same""
 * true
 * >>> check_if_can_break ""abc"" ""bca""
 * true
 * >>> check_if_can_break ""hello"" ""bello""
 * true
*)
let check_if_can_break (s1 : string) (s2 : string) : bool =","  false","let () =
  assert (check_if_can_break ""same"" ""same"" = true);
  assert (check_if_can_break ""abc"" ""bca"" = true);
  assert (check_if_can_break ""hello"" ""bello"" = true);
  assert (check_if_can_break ""aazz"" ""zzaa"" = true);
  assert (check_if_can_break ""abac"" ""baca"" = true);
  assert (check_if_can_break ""xyz"" ""wvu"" = true);
  assert (check_if_can_break ""abc"" ""xya"" = true);
;;","medium","medium_128","medium"
"(**According to Wikipedia's article: ""The Game of Life, also known simply as Life, is a cellular aut...
 * >>> game_of_life [[0; 0; 0; 0]; [0; 1; 1; 0]; [0; 1; 1; 0]; [0; 0; 0; 0]]
 * None
 * >>> game_of_life [[1; 0; 1]; [0; 0; 0]; [1; 1; 1]]
 * None
 * >>> game_of_life [[0]]
 * None
*)
let game_of_life (board : int list list) : unit =","  failwith ""Not implemented""","let () =
  assert (game_of_life [[0; 0; 0; 0]; [0; 1; 1; 0]; [0; 1; 1; 0]; [0; 0; 0; 0]] = None);
  assert (game_of_life [[1; 0; 1]; [0; 0; 0]; [1; 1; 1]] = None);
  assert (game_of_life [[0]] = None);
  assert (game_of_life [[1; 1; 1; 1]; [1; 1; 1; 1]; [1; 1; 1; 1]; [1; 1; 1; 1]] = None);
  assert (game_of_life [[1]] = None);
  assert (game_of_life [[1; 1; 1]; [1; 1; 1]; [1; 1; 1]] = None);
  assert (game_of_life [[1; 1]; [1; 0]] = None);
;;","medium","medium_017","medium"
"(**A self-dividing number is a number that is divisible by every digit it contains.
 * >>> self_dividing_numbers 120 130
 * [122; 124; 126; 128]
 * >>> self_dividing_numbers 47 85
 * [48; 55; 66; 77]
 * >>> self_dividing_numbers 1 100
 * [1; 2; 3; 4; 5; 6; 7; 8; 9; 11; 12; 15; 22; 24; 33; 36; 44; 48; 55; 66; 77; 88; 99]
*)
let self_dividing_numbers (left : int) (right : int) : int list =","  []","let () =
  assert (self_dividing_numbers 120 130 = [122; 124; 126; 128]);
  assert (self_dividing_numbers 47 85 = [48; 55; 66; 77]);
  assert (self_dividing_numbers 1 100 = [1; 2; 3; 4; 5; 6; 7; 8; 9; 11; 12; 15; 22; 24; 33; 36; 44; 48; 55; 66; 77; 88; 99]);
  assert (self_dividing_numbers 9990 10000 = [9999]);
  assert (self_dividing_numbers 500 700 = [515; 555; 612; 624; 636; 648; 666; 672]);
  assert (self_dividing_numbers 10 30 = [11; 12; 15; 22; 24]);
  assert (self_dividing_numbers 10 50 = [11; 12; 15; 22; 24; 33; 36; 44; 48]);
;;","easy","easy_006","easy"
"(**Given a string num that contains only digits and an integer target, return all possibilities to i...
 * >>> add_operators ""232"" 8
 * ['2+3*2'; '2*3+2']
 * >>> add_operators ""123"" 6
 * ['1+2+3'; '1*2*3']
 * >>> add_operators ""00"" 0
 * ['0+0'; '0-0'; '0*0']
*)
let add_operators (num : string) (target : int) : string list =","  []","let () =
  assert (add_operators ""232"" 8 = ['2+3*2'; '2*3+2']);
  assert (add_operators ""123"" 6 = ['1+2+3'; '1*2*3']);
  assert (add_operators ""00"" 0 = ['0+0'; '0-0'; '0*0']);
  assert (add_operators ""105"" 5 = ['1*0+5'; '10-5']);
  assert (add_operators ""3"" 3 = ['3']);
  assert (add_operators ""34"" 14 = []);
  assert (add_operators ""3456237490"" 9191 = []);
;;","hard","hard_005","hard"
"(**You are given a 2D 0-indexed integer array dimensions.
 * >>> area_of_max_diagonal [[5; 12]; [13; 88]; [20; 21]]
 * 1144
 * >>> area_of_max_diagonal [[6; 8]; [8; 6]; [10; 24]]
 * 240
 * >>> area_of_max_diagonal [[9; 3]; [8; 6]]
 * 48
*)
let area_of_max_diagonal (dimensions : int list list) : int =","  0","let () =
  assert (area_of_max_diagonal [[5; 12]; [13; 88]; [20; 21]] = 1144);
  assert (area_of_max_diagonal [[6; 8]; [8; 6]; [10; 24]] = 240);
  assert (area_of_max_diagonal [[9; 3]; [8; 6]] = 48);
  assert (area_of_max_diagonal [[7; 24]; [24; 7]; [10; 10]] = 168);
  assert (area_of_max_diagonal [[1; 1]; [1; 1]; [1; 1]] = 1);
  assert (area_of_max_diagonal [[100; 1]; [1; 100]] = 100);
  assert (area_of_max_diagonal [[1; 2]; [2; 1]; [3; 4]; [4; 3]] = 12);
;;","easy","easy_120","easy"
"(**At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you an...
 * >>> lemonade_change [5; 5; 5; 5; 20; 20; 5; 5; 20; 5]
 * false
 * >>> lemonade_change [5; 5; 10; 10; 5; 20]
 * true
 * >>> lemonade_change [5; 5; 5; 5; 5; 5; 10; 10; 10; 20; 20; 20]
 * true
*)
let lemonade_change (bills : int list) : bool =","  false","let () =
  assert (lemonade_change [5; 5; 5; 5; 20; 20; 5; 5; 20; 5] = false);
  assert (lemonade_change [5; 5; 10; 10; 5; 20] = true);
  assert (lemonade_change [5; 5; 5; 5; 5; 5; 10; 10; 10; 20; 20; 20] = true);
  assert (lemonade_change [5; 5; 5; 5; 20; 5; 5; 5; 10; 5; 20] = true);
  assert (lemonade_change [5; 5; 10; 10; 20] = false);
  assert (lemonade_change [5; 5; 10; 10; 5; 20; 10; 5; 5; 20] = false);
  assert (lemonade_change [5; 10; 5; 5; 20] = true);
;;","easy","easy_064","easy"
"(**There are several stones arranged in a row, and each stone has an associated value which is an in...
 * >>> stone_game_v [1; 2; 3; 4; 5]
 * 10
 * >>> stone_game_v [5; 3; 1; 4; 2]
 * 9
 * >>> stone_game_v [1; 3; 5; 7; 9; 11; 13]
 * 35
*)
let stone_game_v (stoneValue : int list) : int =","  0","let () =
  assert (stone_game_v [1; 2; 3; 4; 5] = 10);
  assert (stone_game_v [5; 3; 1; 4; 2] = 9);
  assert (stone_game_v [1; 3; 5; 7; 9; 11; 13] = 35);
  assert (stone_game_v [3; 6; 2; 8; 7; 4; 5] = 23);
  assert (stone_game_v [3; 2; 4; 1; 4; 1; 3; 2] = 17);
  assert (stone_game_v [5; 5; 5; 5; 5; 5; 5; 5; 5; 5] = 40);
  assert (stone_game_v [3; 1; 5; 4; 2] = 8);
;;","hard","hard_026","hard"
"(**A word is considered valid if:
 * >>> is_valid ""234Adas""
 * true
 * >>> is_valid ""b3""
 * false
 * >>> is_valid ""a3$e""
 * false
*)
let is_valid (word : string) : bool =","  false","let () =
  assert (is_valid ""234Adas"" = true);
  assert (is_valid ""b3"" = false);
  assert (is_valid ""a3$e"" = false);
  assert (is_valid ""N0C0ns0n4nts"" = false);
  assert (is_valid ""Zebra123"" = true);
  assert (is_valid ""1234567890"" = false);
  assert (is_valid ""Aeiou9"" = false);
;;","easy","easy_018","easy"
"(**A Fibonacci tree is a binary tree created using the order function order(n):
 * >>> find_game_winner 3
 * true
 * >>> find_game_winner 45
 * true
 * >>> find_game_winner 53
 * true
*)
let find_game_winner (n : int) : bool =","  false","let () =
  assert (find_game_winner 3 = true);
  assert (find_game_winner 45 = true);
  assert (find_game_winner 53 = true);
  assert (find_game_winner 70 = true);
  assert (find_game_winner 43 = false);
  assert (find_game_winner 68 = true);
  assert (find_game_winner 5 = true);
;;","hard","hard_035","hard"
"(**Given an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order.
 * >>> lucky_numbers [[5; 9; 11]; [9; 4; 8]; [3; 15; 17]]
 * []
 * >>> lucky_numbers [[1; 2; 3; 4]; [5; 6; 7; 8]; [9; 10; 11; 12]; [13; 14; 15; 16]]
 * [13]
 * >>> lucky_numbers [[33; 18; 46; 39]; [68; 35; 41; 26]; [55; 87; 52; 37]; [17; 47; 99; 22]]
 * []
*)
let lucky_numbers (matrix : int list list) : int list =","  []","let () =
  assert (lucky_numbers [[5; 9; 11]; [9; 4; 8]; [3; 15; 17]] = []);
  assert (lucky_numbers [[1; 2; 3; 4]; [5; 6; 7; 8]; [9; 10; 11; 12]; [13; 14; 15; 16]] = [13]);
  assert (lucky_numbers [[33; 18; 46; 39]; [68; 35; 41; 26]; [55; 87; 52; 37]; [17; 47; 99; 22]] = []);
  assert (lucky_numbers [[3; 7; 8]; [9; 11; 13]; [15; 16; 17]] = [15]);
  assert (lucky_numbers [[5; 1; 4]; [1; 5; 7]; [8; 3; 2]] = []);
  assert (lucky_numbers [[3; 6]; [7; 1]; [5; 9]] = []);
  assert (lucky_numbers [[40; 10]; [24; 30]] = []);
;;","easy","easy_068","easy"
"(**A stepping number is an integer such that all of its adjacent digits have an absolute difference ...
 * >>> count_stepping_numbers 200 250
 * [210; 212; 232; 234]
 * >>> count_stepping_numbers 0 2000000000
 * Execution timed out
 * >>> count_stepping_numbers 123 456
 * [123; 210; 212; 232; 234; 321; 323; 343; 345; 432; 434; 454; 456]
*)
let count_stepping_numbers (low : int) (high : int) : int list =","  []","let () =
  assert (count_stepping_numbers 200 250 = [210; 212; 232; 234]);
  assert (count_stepping_numbers 0 2000000000 = Execution timed out);
  assert (count_stepping_numbers 123 456 = [123; 210; 212; 232; 234; 321; 323; 343; 345; 432; 434; 454; 456]);
  assert (count_stepping_numbers 1234 5678 = [1234; 2101; 2121; 2123; 2321; 2323; 2343; 2345; 3210; 3212; 3232; 3234; 3432; 3434; 3454; 3456; 4321; 4323; 4343; 4345; 4543; 4545; 4565; 4567; 5432; 5434; 5454; 5456; 5654; 5656; 5676; 5678]);
  assert (count_stepping_numbers 5 15 = [5; 6; 7; 8; 9; 10; 12]);
  assert (count_stepping_numbers 0 21 = [0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 12; 21]);
  assert (count_stepping_numbers 5 5 = [5]);
;;","medium","medium_170","medium"
"(**You are given a 1-indexed integer array nums of length n.
 * >>> sum_of_squares [1]
 * 1
 * >>> sum_of_squares [5; 10; 15; 20; 25]
 * 650
 * >>> sum_of_squares [1; 1; 1; 1; 1; 1; 1; 1; 1; 1]
 * 4
*)
let sum_of_squares (nums : int list) : int =","  0","let () =
  assert (sum_of_squares [1] = 1);
  assert (sum_of_squares [5; 10; 15; 20; 25] = 650);
  assert (sum_of_squares [1; 1; 1; 1; 1; 1; 1; 1; 1; 1] = 4);
  assert (sum_of_squares [1; 2; 3; 4] = 21);
  assert (sum_of_squares [49; 49; 49; 49; 49; 49; 49; 49; 49; 49; 49; 49; 49; 49; 49; 49; 49; 49; 49; 49] = 14406);
  assert (sum_of_squares [49; 25; 9; 4; 1] = 2402);
  assert (sum_of_squares [5; 10; 15; 20; 25; 30; 35; 40; 45; 50] = 3250);
;;","easy","easy_045","easy"
"(**You are given a positive integer n which is the number of nodes of a 0-indexed directed weighted ...
 * >>> minimum_distance 4 [[0; 1; 1]; [1; 2; 3]; [2; 3; 2]; [0; 3; 4]] 0 [2; 3]
 * 4
 * >>> minimum_distance 6 [[0; 1; 5]; [0; 2; 3]; [1; 3; 2]; [2; 3; 1]; [3; 4; 2]; [4; 5; 1]] 0 [4; 5]
 * 6
 * >>> minimum_distance 6 [[0; 1; 10]; [0; 2; 5]; [1; 3; 1]; [2; 3; 10]; [3; 4; 2]; [4; 5; 1]] 0 [4; 5]
 * 13
*)
let minimum_distance (n : int) (edges : int list list) (s : int) (marked : int list) : int =","  0","let () =
  assert (minimum_distance 4 [[0; 1; 1]; [1; 2; 3]; [2; 3; 2]; [0; 3; 4]] 0 [2; 3] = 4);
  assert (minimum_distance 6 [[0; 1; 5]; [0; 2; 3]; [1; 3; 2]; [2; 3; 1]; [3; 4; 2]; [4; 5; 1]] 0 [4; 5] = 6);
  assert (minimum_distance 6 [[0; 1; 10]; [0; 2; 5]; [1; 3; 1]; [2; 3; 10]; [3; 4; 2]; [4; 5; 1]] 0 [4; 5] = 13);
  assert (minimum_distance 7 [[0; 1; 1]; [1; 2; 2]; [2; 3; 3]; [3; 4; 4]; [4; 5; 5]; [5; 6; 6]] 0 [6] = 21);
  assert (minimum_distance 4 [[0; 1; 1]; [1; 2; 3]; [2; 3; 2]] 3 [0; 1] = -1);
  assert (minimum_distance 3 [[0; 1; 1]; [1; 2; 2]; [2; 0; 3]] 0 [1; 2] = 1);
  assert (minimum_distance 3 [[0; 1; 2]; [1; 2; 3]] 0 [2] = 5);
;;","medium","medium_091","medium"
"(**You are given a 0-indexed array of integers nums.
 * >>> missing_integer [1; 3; 2; 4; 5]
 * 6
 * >>> missing_integer [10; 11; 12; 8; 9; 13]
 * 33
 * >>> missing_integer [10; 11; 12; 13; 14]
 * 60
*)
let missing_integer (nums : int list) : int =","  0","let () =
  assert (missing_integer [1; 3; 2; 4; 5] = 6);
  assert (missing_integer [10; 11; 12; 8; 9; 13] = 33);
  assert (missing_integer [10; 11; 12; 13; 14] = 60);
  assert (missing_integer [1; 3; 5; 7; 9] = 2);
  assert (missing_integer [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = 55);
  assert (missing_integer [50; 49; 48; 47; 46] = 51);
  assert (missing_integer [5; 6; 7; 8; 9; 10; 11; 12; 13; 14] = 95);
;;","easy","easy_099","easy"
"(**The appeal of a string is the number of distinct characters found in the string.
 * >>> appeal_sum ""abcdefghijklmnopqrstuvwxyz""
 * 3276
 * >>> appeal_sum ""zzzaaa""
 * 30
 * >>> appeal_sum ""a""
 * 1
*)
let appeal_sum (s : string) : int =","  0","let () =
  assert (appeal_sum ""abcdefghijklmnopqrstuvwxyz"" = 3276);
  assert (appeal_sum ""zzzaaa"" = 30);
  assert (appeal_sum ""a"" = 1);
  assert (appeal_sum ""abacabadabacaba"" = 357);
  assert (appeal_sum ""abcabcabc"" = 109);
  assert (appeal_sum ""abbca"" = 28);
  assert (appeal_sum ""ababababab"" = 100);
;;","hard","hard_083","hard"
"(**You are given a 0-indexed integer array nums. In one operation, you may do the following:
 * >>> number_of_pairs [0; 0; 0; 0; 0; 0; 0; 0; 0; 0]
 * [5; 0]
 * >>> number_of_pairs [100; 0; 50; 50; 0; 100]
 * [3; 0]
 * >>> number_of_pairs [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
 * [0; 10]
*)
let number_of_pairs (nums : int list) : int list =","  []","let () =
  assert (number_of_pairs [0; 0; 0; 0; 0; 0; 0; 0; 0; 0] = [5; 0]);
  assert (number_of_pairs [100; 0; 50; 50; 0; 100] = [3; 0]);
  assert (number_of_pairs [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = [0; 10]);
  assert (number_of_pairs [1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1] = [5; 1]);
  assert (number_of_pairs [42] = [0; 1]);
  assert (number_of_pairs [1] = [0; 1]);
  assert (number_of_pairs [1; 3; 2; 1; 3; 2; 2] = [3; 1]);
;;","easy","easy_129","easy"
"(**You are given an n x n integer matrix grid.
 * >>> largest_local [[1; 5; 9; 1; 5; 9]; [2; 6; 0; 2; 6; 0]; [3; 7; 1; 3; 7; 1]; [4; 8; 2; 4; 8; 2]; [5; 9; 3; 5; 9; 3]; [6; 0; 4; 6; 0; 4]]
 * [[9; 9; 9; 9]; [8; 8; 8; 8]; [9; 9; 9; 9]; [9; 9; 9; 9]]
 * >>> largest_local [[5; 8; 4; 3]; [3; 5; 9; 5]; [7; 6; 7; 9]; [4; 8; 5; 3]]
 * [[9; 9]; [9; 9]]
 * >>> largest_local [[1; 1; 1; 1; 1]; [1; 1; 1; 1; 1]; [1; 1; 2; 1; 1]; [1; 1; 1; 1; 1]; [1; 1; 1; 1; 1]]
 * [[2; 2; 2]; [2; 2; 2]; [2; 2; 2]]
*)
let largest_local (grid : int list list) : int list list =","  [[]]","let () =
  assert (largest_local [[1; 5; 9; 1; 5; 9]; [2; 6; 0; 2; 6; 0]; [3; 7; 1; 3; 7; 1]; [4; 8; 2; 4; 8; 2]; [5; 9; 3; 5; 9; 3]; [6; 0; 4; 6; 0; 4]] = [[9; 9; 9; 9]; [8; 8; 8; 8]; [9; 9; 9; 9]; [9; 9; 9; 9]]);
  assert (largest_local [[5; 8; 4; 3]; [3; 5; 9; 5]; [7; 6; 7; 9]; [4; 8; 5; 3]] = [[9; 9]; [9; 9]]);
  assert (largest_local [[1; 1; 1; 1; 1]; [1; 1; 1; 1; 1]; [1; 1; 2; 1; 1]; [1; 1; 1; 1; 1]; [1; 1; 1; 1; 1]] = [[2; 2; 2]; [2; 2; 2]; [2; 2; 2]]);
  assert (largest_local [[3; 0; 0; 5]; [0; 7; 3; 2]; [0; 2; 9; 7]; [5; 1; 0; 0]] = [[9; 9]; [9; 9]]);
  assert (largest_local [[100; 100; 100]; [100; 100; 100]; [100; 100; 100]] = [[100]]);
  assert (largest_local [[3; 0; 0; 5]; [0; 5; 0; 0]; [0; 0; 0; 5]; [5; 0; 5; 0]] = [[5; 5]; [5; 5]]);
  assert (largest_local [[9; 9; 8; 1]; [5; 6; 2; 6]; [8; 2; 6; 4]; [6; 2; 2; 2]] = [[9; 9]; [8; 6]]);
;;","easy","easy_074","easy"
"(**Alice and Bob take turns playing a game, with Alice starting first.
 * >>> divisor_game 8
 * true
 * >>> divisor_game 3
 * false
 * >>> divisor_game 4
 * true
*)
let divisor_game (n : int) : bool =","  false","let () =
  assert (divisor_game 8 = true);
  assert (divisor_game 3 = false);
  assert (divisor_game 4 = true);
  assert (divisor_game 9 = false);
  assert (divisor_game 6 = true);
  assert (divisor_game 2 = true);
  assert (divisor_game 1000 = true);
;;","easy","easy_194","easy"
"(**Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence wh...
 * >>> word_break ""aaaaaaa"" [""aa""; ""aaa""]
 * ['aa aa aaa'; 'aa aaa aa'; 'aaa aa aa']
 * >>> word_break ""pineapplepenapple"" [""apple""; ""pen""; ""applepen""; ""pine""; ""pineapple""]
 * ['pine apple pen apple'; 'pine applepen apple'; 'pineapple pen apple']
 * >>> word_break ""a"" [""a""]
 * ['a']
*)
let word_break (s : string) (wordDict : string list) : string list =","  []","let () =
  assert (word_break ""aaaaaaa"" [""aa""; ""aaa""] = ['aa aa aaa'; 'aa aaa aa'; 'aaa aa aa']);
  assert (word_break ""pineapplepenapple"" [""apple""; ""pen""; ""applepen""; ""pine""; ""pineapple""] = ['pine apple pen apple'; 'pine applepen apple'; 'pineapple pen apple']);
  assert (word_break ""a"" [""a""] = ['a']);
  assert (word_break ""catsanddog"" [""cat""; ""cats""; ""and""; ""sand""; ""dog""] = ['cat sand dog'; 'cats and dog']);
  assert (word_break ""catsandog"" [""cats""; ""dog""; ""sand""; ""and""; ""cat""] = []);
  assert (word_break ""abcd"" [""a""; ""abc""; ""b""; ""cd""] = ['a b cd']);
  assert (word_break ""leetcodeleet"" [""leet""; ""code""] = ['leet code leet']);
;;","hard","hard_021","hard"
"(**Given an integer array arr, return the length of a maximum size turbulent subarray of arr.
 * >>> max_turbulence_size [9; 9]
 * 1
 * >>> max_turbulence_size [9; 4; 2; 10; 7; 8; 8; 1; 9]
 * 5
 * >>> max_turbulence_size [9; 8; 7; 6; 7; 8; 9; 8; 7; 6]
 * 3
*)
let max_turbulence_size (arr : int list) : int =","  0","let () =
  assert (max_turbulence_size [9; 9] = 1);
  assert (max_turbulence_size [9; 4; 2; 10; 7; 8; 8; 1; 9] = 5);
  assert (max_turbulence_size [9; 8; 7; 6; 7; 8; 9; 8; 7; 6] = 3);
  assert (max_turbulence_size [1; 2; 1; 2; 1; 2; 1; 2; 3] = 8);
  assert (max_turbulence_size [1; 2; 1; 2; 1; 2; 1; 2; 1] = 9);
  assert (max_turbulence_size [9; 4; 2; 10; 7; 8; 7; 1; 9; 4; 2; 10; 7; 8; 8; 1; 9] = 6);
  assert (max_turbulence_size [10; 9; 4; 5; 4; 8; 9; 3; 5] = 5);
;;","medium","medium_011","medium"
"(**You are given an array nums of length n and a positive integer k.
 * >>> maximum_subarray_sum [1000000000; -1000000000] 2000000000
 * 0
 * >>> maximum_subarray_sum [-1; 3; 2; 4; 5] 3
 * 11
 * >>> maximum_subarray_sum [10; 20; 30; 40; 50] 20
 * 120
*)
let maximum_subarray_sum (nums : int list) (k : int) : int =","  0","let () =
  assert (maximum_subarray_sum [1000000000; -1000000000] 2000000000 = 0);
  assert (maximum_subarray_sum [-1; 3; 2; 4; 5] 3 = 11);
  assert (maximum_subarray_sum [10; 20; 30; 40; 50] 20 = 120);
  assert (maximum_subarray_sum [1000000000; 1000000000; 1000000000] 0 = 3000000000);
  assert (maximum_subarray_sum [1; 1; 1; 1; 1; 1; 1; 1; 1; 1] 0 = 10);
  assert (maximum_subarray_sum [-1000000000; 1000000000; -1000000000; 1000000000] 2000000000 = 0);
  assert (maximum_subarray_sum [1; 3; 5; 7; 9] 8 = 25);
;;","medium","medium_189","medium"
"(**A sentence is a list of words that are separated by a single space with no leading or trailing sp...
 * >>> sort_sentence ""eight8 seven7 six6 five5 four4 three3 two2 one1""
 * one two three four five six seven eight
 * >>> sort_sentence ""seven7 six6 five5 four4 three3 two2 one1""
 * one two three four five six seven
 * >>> sort_sentence ""nine9 eight8 seven7 six6 five5 four4 three3 two2 one1""
 * one two three four five six seven eight nine
*)
let sort_sentence (s : string) : string =","  """"","let () =
  assert (sort_sentence ""eight8 seven7 six6 five5 four4 three3 two2 one1"" = one two three four five six seven eight);
  assert (sort_sentence ""seven7 six6 five5 four4 three3 two2 one1"" = one two three four five six seven);
  assert (sort_sentence ""nine9 eight8 seven7 six6 five5 four4 three3 two2 one1"" = one two three four five six seven eight nine);
  assert (sort_sentence ""three3 two2 one1"" = one two three);
  assert (sort_sentence ""is2 sentence4 This1 a3"" = This is a sentence);
  assert (sort_sentence ""five5 four4 three3 two2 one1"" = one two three four five);
  assert (sort_sentence ""A9 B8 C7 D6 E5 F4 G3 H2 I1"" = I H G F E D C B A);
;;","easy","easy_051","easy"
"(**There are n availabe seats and n students standing in a room. You are given an array seats of len...
 * >>> min_moves_to_seat [5; 5; 5; 5] [5; 5; 5; 5]
 * 0
 * >>> min_moves_to_seat [10; 20; 30] [5; 15; 25]
 * 15
 * >>> min_moves_to_seat [4; 1; 5; 9] [1; 3; 2; 6]
 * 7
*)
let min_moves_to_seat (seats : int list) (students : int list) : int =","  0","let () =
  assert (min_moves_to_seat [5; 5; 5; 5] [5; 5; 5; 5] = 0);
  assert (min_moves_to_seat [10; 20; 30] [5; 15; 25] = 15);
  assert (min_moves_to_seat [4; 1; 5; 9] [1; 3; 2; 6] = 7);
  assert (min_moves_to_seat [1; 1; 1; 1] [1; 1; 1; 1] = 0);
  assert (min_moves_to_seat [3; 1; 5] [2; 7; 4] = 4);
  assert (min_moves_to_seat [1; 1; 1] [1; 1; 1] = 0);
  assert (min_moves_to_seat [50; 50; 50] [49; 50; 51] = 2);
;;","easy","easy_090","easy"
"(**You are given a 0-indexed integer array nums containing positive integers.
 * >>> minimum_array_length [3; 3; 3; 3; 3; 3]
 * 3
 * >>> minimum_array_length [5; 5; 5; 10; 5]
 * 2
 * >>> minimum_array_length [1; 1; 1; 1; 1; 1; 1; 1; 1; 1]
 * 5
*)
let minimum_array_length (nums : int list) : int =","  0","let () =
  assert (minimum_array_length [3; 3; 3; 3; 3; 3] = 3);
  assert (minimum_array_length [5; 5; 5; 10; 5] = 2);
  assert (minimum_array_length [1; 1; 1; 1; 1; 1; 1; 1; 1; 1] = 5);
  assert (minimum_array_length [9; 9; 9; 9; 9; 9; 9; 9; 9; 9; 9] = 6);
  assert (minimum_array_length [3; 9; 27; 81; 243] = 1);
  assert (minimum_array_length [7; 7; 7; 7; 7] = 3);
  assert (minimum_array_length [9; 9; 9; 9; 9; 9; 9; 9; 9; 9] = 5);
;;","medium","medium_176","medium"
"(**You have n bags numbered from 0 to n - 1. You are given two 0-indexed integer arrays capacity and...
 * >>> maximum_bags [2; 3; 4; 5] [1; 2; 4; 4] 2
 * 3
 * >>> maximum_bags [1; 2; 3] [0; 0; 0] 5
 * 2
 * >>> maximum_bags [3; 2; 1] [0; 0; 0] 5
 * 2
*)
let maximum_bags (capacity : int list) (rocks : int list) (additionalRocks : int) : int =","  0","let () =
  assert (maximum_bags [2; 3; 4; 5] [1; 2; 4; 4] 2 = 3);
  assert (maximum_bags [1; 2; 3] [0; 0; 0] 5 = 2);
  assert (maximum_bags [3; 2; 1] [0; 0; 0] 5 = 2);
  assert (maximum_bags [1; 1; 1] [0; 0; 0] 3 = 3);
  assert (maximum_bags [3; 9; 8] [0; 2; 5] 6 = 2);
  assert (maximum_bags [5; 5; 5; 5] [0; 0; 0; 0] 10 = 2);
  assert (maximum_bags [1; 1; 1; 1] [1; 1; 1; 1] 1 = 4);
;;","medium","medium_179","medium"
"(**Given a string s, return the maximum length of a substring such that it contains at most two occu...
 * >>> maximum_length_substring ""zzzzzzzzz""
 * 2
 * >>> maximum_length_substring ""aaabbbccc""
 * 4
 * >>> maximum_length_substring ""aabbaa""
 * 4
*)
let maximum_length_substring (s : string) : int =","  0","let () =
  assert (maximum_length_substring ""zzzzzzzzz"" = 2);
  assert (maximum_length_substring ""aaabbbccc"" = 4);
  assert (maximum_length_substring ""aabbaa"" = 4);
  assert (maximum_length_substring ""abababab"" = 4);
  assert (maximum_length_substring ""aabacbebebe"" = 6);
  assert (maximum_length_substring ""abacabadabacaba"" = 5);
  assert (maximum_length_substring ""abab"" = 4);
;;","easy","easy_118","easy"
"(**Given n orders, each order consists of a pickup and a delivery service.
 * >>> count_orders 3
 * 90
 * >>> count_orders 250
 * 418733499
 * >>> count_orders 100
 * 14159051
*)
let count_orders (n : int) : int =","  0","let () =
  assert (count_orders 3 = 90);
  assert (count_orders 250 = 418733499);
  assert (count_orders 100 = 14159051);
  assert (count_orders 4 = 2520);
  assert (count_orders 2 = 6);
  assert (count_orders 20 = 580270580);
  assert (count_orders 1 = 1);
;;","hard","hard_037","hard"
"(**There is a biker going on a road trip. The road trip consists of n + 1 points at different altitu...
 * >>> largest_altitude [4; 3; 2; 1; 0; -1; -2; -3; -4]
 * 10
 * >>> largest_altitude [-1; -2; -3; -4]
 * 0
 * >>> largest_altitude [-10; -20; -30; -40; -50]
 * 0
*)
let largest_altitude (gain : int list) : int =","  0","let () =
  assert (largest_altitude [4; 3; 2; 1; 0; -1; -2; -3; -4] = 10);
  assert (largest_altitude [-1; -2; -3; -4] = 0);
  assert (largest_altitude [-10; -20; -30; -40; -50] = 0);
  assert (largest_altitude [1; 2; 3; 4; 5; 6; 7; 8; 9; 100] = 145);
  assert (largest_altitude [-1; 1; -1; 1; -1; 1] = 0);
  assert (largest_altitude [0; 0; 0; 0; 0; 0; 0; 0; 0; 0] = 0);
  assert (largest_altitude [-5; -4; -3; -2; -1] = 0);
;;","easy","easy_035","easy"
"(**You are given an array nums of length n and an integer m. You need to determine if it is possible...
 * >>> can_split_array [10; 20; 30; 40] 50
 * true
 * >>> can_split_array [2; 3; 3; 2; 3] 6
 * true
 * >>> can_split_array [50; 50] 100
 * true
*)
let can_split_array (nums : int list) (m : int) : bool =","  false","let () =
  assert (can_split_array [10; 20; 30; 40] 50 = true);
  assert (can_split_array [2; 3; 3; 2; 3] 6 = true);
  assert (can_split_array [50; 50] 100 = true);
  assert (can_split_array [1; 2; 3; 4; 5] 9 = true);
  assert (can_split_array [1; 1; 1; 1; 1; 1] 2 = true);
  assert (can_split_array [2; 1; 3] 5 = false);
  assert (can_split_array [10; 10; 10; 10; 10; 10; 10; 10; 10; 10] 20 = true);
;;","medium","medium_115","medium"
"(**Given an integer array nums, return the greatest common divisor of the smallest number and larges...
 * >>> find_gcd [42; 56; 14]
 * 14
 * >>> find_gcd [1; 1000]
 * 1
 * >>> find_gcd [17; 23; 37; 41]
 * 1
*)
let find_gcd (nums : int list) : int =","  0","let () =
  assert (find_gcd [42; 56; 14] = 14);
  assert (find_gcd [1; 1000] = 1);
  assert (find_gcd [17; 23; 37; 41] = 1);
  assert (find_gcd [3; 3] = 3);
  assert (find_gcd [7; 5; 6; 8; 3] = 1);
  assert (find_gcd [1000; 1000] = 1000);
  assert (find_gcd [48; 18; 30] = 6);
;;","easy","easy_111","easy"
"(**You are given a string s of even length consisting of digits from 0 to 9, and two integers a and b.
 * >>> find_lex_smallest_string ""5525"" 9 2
 * 2050
 * >>> find_lex_smallest_string ""9876543210"" 7 4
 * 1098765432
 * >>> find_lex_smallest_string ""74"" 5 1
 * 24
*)
let find_lex_smallest_string (s : string) (a : int) (b : int) : string =","  """"","let () =
  assert (find_lex_smallest_string ""5525"" 9 2 = 2050);
  assert (find_lex_smallest_string ""9876543210"" 7 4 = 1098765432);
  assert (find_lex_smallest_string ""74"" 5 1 = 24);
  assert (find_lex_smallest_string ""8900"" 3 3 = 0018);
  assert (find_lex_smallest_string ""1234567890"" 7 3 = 0022446688);
  assert (find_lex_smallest_string ""3456"" 5 1 = 0189);
  assert (find_lex_smallest_string ""0011"" 4 2 = 0011);
;;","medium","medium_147","medium"
"(**You are given 2 integer arrays nums1 and nums2 of lengths n and m respectively. You are also give...
 * >>> number_of_pairs [7; 14; 21] [1; 7] 3
 * 2
 * >>> number_of_pairs [1; 3; 4] [1; 3; 4] 1
 * 5
 * >>> number_of_pairs [7; 14; 21] [1; 7; 14] 1
 * 7
*)
let number_of_pairs (nums1 : int list) (nums2 : int list) (k : int) : int =","  0","let () =
  assert (number_of_pairs [7; 14; 21] [1; 7] 3 = 2);
  assert (number_of_pairs [1; 3; 4] [1; 3; 4] 1 = 5);
  assert (number_of_pairs [7; 14; 21] [1; 7; 14] 1 = 7);
  assert (number_of_pairs [7; 14; 21] [1; 7; 14] 3 = 2);
  assert (number_of_pairs [7; 14; 21] [7; 14] 1 = 4);
  assert (number_of_pairs [20; 40; 60] [5; 10] 4 = 4);
  assert (number_of_pairs [5; 10; 15] [1; 2; 3] 5 = 5);
;;","easy","easy_131","easy"
"(**You are given two binary trees root1 and root2.
 * >>> merge_trees [5; 3; 2; 1] [2; 4; 6; 8]
 * [7; 7; 8; 9]
 * >>> merge_trees [3; 4; 5; 1; 2] [4; 5; 6]
 * [7; 9; 11; 1; 2]
 * >>> merge_trees [5; 3; 6; 2; 4; null; null; 1; null; null; null; null; null; null; 8] [7; 4; 5; null; null; null; null; 3; 6; 9]
 * [12; 7; 11; 2; 4; None; None; 1]
*)
let merge_trees (root1 : 'a option) (root2 : 'a option) : 'a option =","  None","let () =
  assert (merge_trees [5; 3; 2; 1] [2; 4; 6; 8] = [7; 7; 8; 9]);
  assert (merge_trees [3; 4; 5; 1; 2] [4; 5; 6] = [7; 9; 11; 1; 2]);
  assert (merge_trees [5; 3; 6; 2; 4; null; null; 1; null; null; null; null; null; null; 8] [7; 4; 5; null; null; null; null; 3; 6; 9] = [12; 7; 11; 2; 4; None; None; 1]);
  assert (merge_trees [3; 4; 5; 1; 2] [0; -1; -2; -3; -4] = [3; 3; 3; -2; -2]);
  assert (merge_trees [1; 2; null; 3] [1; null; 2; null; 3] = [2; 2; 2; 3; None; None; 3]);
  assert (merge_trees [1; -2; 3] [-4; 5; -6] = [-3; 3; -3]);
  assert (merge_trees [] [1] = [1]);
;;","easy","easy_161","easy"
"(**You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once yo...
 * >>> min_cost_climbing_stairs [999; 999; 999; 999]
 * 1998
 * >>> min_cost_climbing_stairs [1; 2; 3; 4; 5]
 * 6
 * >>> min_cost_climbing_stairs [1; 100; 1; 1; 1; 100; 1; 1; 100; 1]
 * 6
*)
let min_cost_climbing_stairs (cost : int list) : int =","  0","let () =
  assert (min_cost_climbing_stairs [999; 999; 999; 999] = 1998);
  assert (min_cost_climbing_stairs [1; 2; 3; 4; 5] = 6);
  assert (min_cost_climbing_stairs [1; 100; 1; 1; 1; 100; 1; 1; 100; 1] = 6);
  assert (min_cost_climbing_stairs [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = 25);
  assert (min_cost_climbing_stairs [0; 0; 0; 0] = 0);
  assert (min_cost_climbing_stairs [1; 2] = 1);
  assert (min_cost_climbing_stairs [999; 999; 999; 999; 999; 999] = 2997);
;;","easy","easy_092","easy"
"(**You are given an integer n representing an array colors of length n where all elements are set to...
 * >>> color_the_array 3 [[0; 2]; [1; 2]; [2; 2]]
 * [0; 1; 2]
 * >>> color_the_array 1 [[0; 100000]]
 * [0]
 * >>> color_the_array 10 [[5; 3]; [6; 3]; [5; 3]; [4; 3]; [3; 3]; [2; 3]; [1; 3]; [0; 3]; [8; 3]; [9; 3]]
 * [0; 1; 1; 2; 3; 4; 5; 6; 6; 7]
*)
let color_the_array (n : int) (queries : int list list) : int list =","  []","let () =
  assert (color_the_array 3 [[0; 2]; [1; 2]; [2; 2]] = [0; 1; 2]);
  assert (color_the_array 1 [[0; 100000]] = [0]);
  assert (color_the_array 10 [[5; 3]; [6; 3]; [5; 3]; [4; 3]; [3; 3]; [2; 3]; [1; 3]; [0; 3]; [8; 3]; [9; 3]] = [0; 1; 1; 2; 3; 4; 5; 6; 6; 7]);
  assert (color_the_array 6 [[1; 2]; [2; 2]; [3; 2]; [4; 2]; [5; 2]; [0; 2]] = [0; 1; 2; 3; 4; 5]);
  assert (color_the_array 3 [[0; 1]; [1; 2]; [2; 1]; [1; 1]] = [0; 0; 0; 2]);
  assert (color_the_array 10 [[0; 5]; [1; 5]; [2; 5]; [3; 5]; [4; 5]; [5; 5]; [6; 5]; [7; 5]; [8; 5]; [9; 5]] = [0; 1; 2; 3; 4; 5; 6; 7; 8; 9]);
  assert (color_the_array 3 [[0; 1]; [1; 2]; [2; 3]] = [0; 0; 0]);
;;","medium","medium_028","medium"
"(**Given a 0-indexed m x n integer matrix matrix, create a new 0-indexed matrix called answer. Make ...
 * >>> modified_matrix [[3; -1]; [5; 2]]
 * [[3; 2]; [5; 2]]
 * >>> modified_matrix [[1; 2; -1]; [4; -1; 6]; [7; 8; 9]]
 * [[1; 2; 9]; [4; 8; 6]; [7; 8; 9]]
 * >>> modified_matrix [[-1; -1]; [-1; -1]; [-1; -1]; [2; 2]]
 * [[2; 2]; [2; 2]; [2; 2]; [2; 2]]
*)
let modified_matrix (matrix : int list list) : int list list =","  [[]]","let () =
  assert (modified_matrix [[3; -1]; [5; 2]] = [[3; 2]; [5; 2]]);
  assert (modified_matrix [[1; 2; -1]; [4; -1; 6]; [7; 8; 9]] = [[1; 2; 9]; [4; 8; 6]; [7; 8; 9]]);
  assert (modified_matrix [[-1; -1]; [-1; -1]; [-1; -1]; [2; 2]] = [[2; 2]; [2; 2]; [2; 2]; [2; 2]]);
  assert (modified_matrix [[10; -1; 10]; [-1; -1; -1]; [10; 10; 10]] = [[10; 10; 10]; [10; 10; 10]; [10; 10; 10]]);
  assert (modified_matrix [[10; 20; -1]; [30; -1; 40]; [50; 60; 70]] = [[10; 20; 70]; [30; 60; 40]; [50; 60; 70]]);
  assert (modified_matrix [[100; -1; -1]; [-1; -1; -1]; [-1; -1; -1]] = [[100; -1; -1]; [100; -1; -1]; [100; -1; -1]]);
  assert (modified_matrix [[-1; 4; 5]; [-1; 6; 7]; [8; 9; -1]] = [[8; 4; 5]; [8; 6; 7]; [8; 9; 7]]);
;;","easy","easy_182","easy"
"(**A string s can be partitioned into groups of size k using the following procedure:
 * >>> divide_string ""abcdefghij"" 3 ""x""
 * ['abc'; 'def'; 'ghi'; 'jxx']
 * >>> divide_string ""abcdefg"" 2 ""z""
 * ['ab'; 'cd'; 'ef'; 'gz']
 * >>> divide_string ""abcdefghi"" 3 ""x""
 * ['abc'; 'def'; 'ghi']
*)
let divide_string (s : string) (k : int) (fill : string) : string list =","  []","let () =
  assert (divide_string ""abcdefghij"" 3 ""x"" = ['abc'; 'def'; 'ghi'; 'jxx']);
  assert (divide_string ""abcdefg"" 2 ""z"" = ['ab'; 'cd'; 'ef'; 'gz']);
  assert (divide_string ""abcdefghi"" 3 ""x"" = ['abc'; 'def'; 'ghi']);
  assert (divide_string ""a"" 1 ""y"" = ['a']);
  assert (divide_string ""python"" 6 ""q"" = ['python']);
  assert (divide_string ""hello world"" 4 ""_"" = ['hell'; 'o wo'; 'rld_']);
  assert (divide_string ""programming"" 1 ""a"" = ['p'; 'r'; 'o'; 'g'; 'r'; 'a'; 'm'; 'm'; 'i'; 'n'; 'g']);
;;","easy","easy_158","easy"
"(**You are given an integer array nums and a positive integer k. You can choose any subsequence of t...
 * >>> k_sum [10; 20; 30; 40; 50] 10
 * 100
 * >>> k_sum [1000000000; -1000000000; 500000000; -500000000] 7
 * 0
 * >>> k_sum [1000000000; -1000000000; 1000000000] 3
 * 1000000000
*)
let k_sum (nums : int list) (k : int) : int =","  0","let () =
  assert (k_sum [10; 20; 30; 40; 50] 10 = 100);
  assert (k_sum [1000000000; -1000000000; 500000000; -500000000] 7 = 0);
  assert (k_sum [1000000000; -1000000000; 1000000000] 3 = 1000000000);
  assert (k_sum [1; 2; 3] 1 = 6);
  assert (k_sum [5; 8; 3; 1] 8 = 9);
  assert (k_sum [0; 0; 0; 0] 10 = 0);
  assert (k_sum [0; 0; 0; 0] 1 = 0);
;;","hard","hard_003","hard"
"(**The complement of an integer is the integer you get when you flip all the 0's to 1's and all the ...
 * >>> find_complement 31
 * 0
 * >>> find_complement 10
 * 5
 * >>> find_complement 32
 * 31
*)
let find_complement (num : int) : int =","  0","let () =
  assert (find_complement 31 = 0);
  assert (find_complement 10 = 5);
  assert (find_complement 32 = 31);
  assert (find_complement 5 = 2);
  assert (find_complement 1023 = 0);
  assert (find_complement 1 = 0);
  assert (find_complement 100 = 27);
;;","easy","easy_037","easy"
"(**You are given a 0-indexed integer array nums of size n, and a 0-indexed integer array pattern of ...
 * >>> count_matching_subarrays [1; 3; 2; 3; 1; 4; 3; 2] [1; -1; 1; -1]
 * 2
 * >>> count_matching_subarrays [1; 2; 2; 3; 4; 5] [1; 0; 1]
 * 1
 * >>> count_matching_subarrays [1; 4; 4; 1; 3; 5; 5; 3] [1; 0; -1]
 * 2
*)
let count_matching_subarrays (nums : int list) (pattern : int list) : int =","  0","let () =
  assert (count_matching_subarrays [1; 3; 2; 3; 1; 4; 3; 2] [1; -1; 1; -1] = 2);
  assert (count_matching_subarrays [1; 2; 2; 3; 4; 5] [1; 0; 1] = 1);
  assert (count_matching_subarrays [1; 4; 4; 1; 3; 5; 5; 3] [1; 0; -1] = 2);
  assert (count_matching_subarrays [5; 5; 5; 5; 5; 5] [0; 0; 0] = 3);
  assert (count_matching_subarrays [1; 2; 2; 3; 4] [1; 0; 1] = 1);
  assert (count_matching_subarrays [1; 2; 2; 3; 3; 4] [1; 0; 1; 0] = 1);
  assert (count_matching_subarrays [1; 2; 3; 4; 5; 6] [1; 1] = 4);
;;","hard","hard_001","hard"
"(**You have n boxes labeled from 0 to n - 1. You are given four arrays: status, candies, keys, and c...
 * >>> max_candies [0; 0; 0] [100; 200; 300] [[1; 2]; [0; 2]; [0; 1]] [[1; 2]; [0; 2]; [0; 1]] [0]
 * 0
 * >>> max_candies [0; 0; 0] [10; 20; 30] [[1]; [2]; []] [[]; []; []] [0]
 * 0
 * >>> max_candies [1; 1; 0; 0; 1] [5; 15; 25; 35; 45] [[2; 3]; []; [4]; []; []] [[1; 2]; [3]; []; []; []] [0]
 * 80
*)
let max_candies (status : int list) (candies : int list) (keys : int list list) (containedBoxes : int list list) (initialBoxes : int list) : int =","  0","let () =
  assert (max_candies [0; 0; 0] [100; 200; 300] [[1; 2]; [0; 2]; [0; 1]] [[1; 2]; [0; 2]; [0; 1]] [0] = 0);
  assert (max_candies [0; 0; 0] [10; 20; 30] [[1]; [2]; []] [[]; []; []] [0] = 0);
  assert (max_candies [1; 1; 0; 0; 1] [5; 15; 25; 35; 45] [[2; 3]; []; [4]; []; []] [[1; 2]; [3]; []; []; []] [0] = 80);
  assert (max_candies [1; 1; 0; 0] [10; 20; 30; 40] [[]; []; [2]; [3]] [[2; 3]; []; []; []] [0; 1] = 30);
  assert (max_candies [1; 1; 0; 0] [10; 20; 30; 40] [[2]; [3]; []; []] [[]; []; [1; 3]; []] [0; 1] = 30);
  assert (max_candies [1; 0; 1; 0; 1] [3; 5; 2; 7; 6] [[2]; [1; 4]; [0]; []; [3]] [[4]; [3]; []; [1]; [2]] [0] = 11);
  assert (max_candies [0; 0; 1; 1] [10; 20; 30; 40] [[1; 3]; [0]; []; []] [[2]; [3]; []; []] [2] = 30);
;;","hard","hard_096","hard"
"(**The variance of a string is defined as the largest difference between the number of occurrences o...
 * >>> largest_variance ""zzzzzzy""
 * 5
 * >>> largest_variance ""zyzzyzyzy""
 * 2
 * >>> largest_variance ""abcdefghijklmnopqrstuvwxyz""
 * 0
*)
let largest_variance (s : string) : int =","  0","let () =
  assert (largest_variance ""zzzzzzy"" = 5);
  assert (largest_variance ""zyzzyzyzy"" = 2);
  assert (largest_variance ""abcdefghijklmnopqrstuvwxyz"" = 0);
  assert (largest_variance ""abbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz"" = 1);
  assert (largest_variance ""abbaabbaabba"" = 2);
  assert (largest_variance ""abababab"" = 1);
  assert (largest_variance ""aaaaa"" = 0);
;;","hard","hard_091","hard"
"(**Given a string s, find any substring of length 2 which is also present in the reverse of s.
 * >>> is_substring_present ""abcba""
 * true
 * >>> is_substring_present ""deified""
 * true
 * >>> is_substring_present ""abab""
 * true
*)
let is_substring_present (s : string) : bool =","  false","let () =
  assert (is_substring_present ""abcba"" = true);
  assert (is_substring_present ""deified"" = true);
  assert (is_substring_present ""abab"" = true);
  assert (is_substring_present ""ab"" = false);
  assert (is_substring_present ""mnopqr"" = false);
  assert (is_substring_present ""aa"" = true);
  assert (is_substring_present ""rotor"" = true);
;;","easy","easy_061","easy"
"(**Given an integer n, return any array containing n unique integers such that they add up to 0.
 * >>> sum_zero 3
 * [1; -1; 0]
 * >>> sum_zero 100
 * [1; -1; 2; -2; 3; -3; 4; -4; 5; -5; 6; -6; 7; -7; 8; -8; 9; -9; 10; -10; 11; -11; 12; -12; 13; -13; 14; -14; 15; -15; 16; -16; 17; -17; 18; -18; 19; -19; 20; -20; 21; -21; 22; -22; 23; -23; 24; -24; 25; -25; 26; -26; 27; -27; 28; -28; 29; -29; 30; -30; 31; -31; 32; -32; 33; -33; 34; -34; 35; -35; 36; -36; 37; -37; 38; -38; 39; -39; 40; -40; 41; -41; 42; -42; 43; -43; 44; -44; 45; -45; 46; -46; 47; -47; 48; -48; 49; -49; 50; -50]
 * >>> sum_zero 2
 * [1; -1]
*)
let sum_zero (n : int) : int list =","  []","let () =
  assert (sum_zero 3 = [1; -1; 0]);
  assert (sum_zero 100 = [1; -1; 2; -2; 3; -3; 4; -4; 5; -5; 6; -6; 7; -7; 8; -8; 9; -9; 10; -10; 11; -11; 12; -12; 13; -13; 14; -14; 15; -15; 16; -16; 17; -17; 18; -18; 19; -19; 20; -20; 21; -21; 22; -22; 23; -23; 24; -24; 25; -25; 26; -26; 27; -27; 28; -28; 29; -29; 30; -30; 31; -31; 32; -32; 33; -33; 34; -34; 35; -35; 36; -36; 37; -37; 38; -38; 39; -39; 40; -40; 41; -41; 42; -42; 43; -43; 44; -44; 45; -45; 46; -46; 47; -47; 48; -48; 49; -49; 50; -50]);
  assert (sum_zero 2 = [1; -1]);
  assert (sum_zero 1 = [0]);
  assert (sum_zero 1000 = [1; -1; 2; -2; 3; -3; 4; -4; 5; -5; 6; -6; 7; -7; 8; -8; 9; -9; 10; -10; 11; -11; 12; -12; 13; -13; 14; -14; 15; -15; 16; -16; 17; -17; 18; -18; 19; -19; 20; -20; 21; -21; 22; -22; 23; -23; 24; -24; 25; -25; 26; -26; 27; -27; 28; -28; 29; -29; 30; -30; 31; -31; 32; -32; 33; -33; 34; -34; 35; -35; 36; -36; 37; -37; 38; -38; 39; -39; 40; -40; 41; -41; 42; -42; 43; -43; 44; -44; 45; -45; 46; -46; 47; -47; 48; -48; 49; -49; 50; -50; 51; -51; 52; -52; 53; -53; 54; -54; 55; -55; 56; -56; 57; -57; 58; -58; 59; -59; 60; -60; 61; -61; 62; -62; 63; -63; 64; -64; 65; -65; 66; -66; 67; -67; 68; -68; 69; -69; 70; -70; 71; -71; 72; -72; 73; -73; 74; -74; 75; -75; 76; -76; 77; -77; 78; -78; 79; -79; 80; -80; 81; -81; 82; -82; 83; -83; 84; -84; 85; -85; 86; -86; 87; -87; 88; -88; 89; -89; 90; -90; 91; -91; 92; -92; 93; -93; 94; -94; 95; -95; 96; -96; 97; -97; 98; -98; 99; -99; 100; -100; 101; -101; 102; -102; 103; -103; 104; -104; 105; -105; 106; -106; 107; -107; 108; -108; 109; -109; 110; -110; 111; -111; 112; -112; 113; -113; 114; -114; 115; -115; 116; -116; 117; -117; 118; -118; 119; -119; 120; -120; 121; -121; 122; -122; 123; -123; 124; -124; 125; -125; 126; -126; 127; -127; 128; -128; 129; -129; 130; -130; 131; -131; 132; -132; 133; -133; 134; -134; 135; -135; 136; -136; 137; -137; 138; -138; 139; -139; 140; -140; 141; -141; 142; -142; 143; -143; 144; -144; 145; -145; 146; -146; 147; -147; 148; -148; 149; -149; 150; -150; 151; -151; 152; -152; 153; -153; 154; -154; 155; -155; 156; -156; 157; -157; 158; -158; 159; -159; 160; -160; 161; -161; 162; -162; 163; -163; 164; -164; 165; -165; 166; -166; 167; -167; 168; -168; 169; -169; 170; -170; 171; -171; 172; -172; 173; -173; 174; -174; 175; -175; 176; -176; 177; -177; 178; -178; 179; -179; 180; -180; 181; -181; 182; -182; 183; -183; 184; -184; 185; -185; 186; -186; 187; -187; 188; -188; 189; -189; 190; -190; 191; -191; 192; -192; 193; -193; 194; -194; 195; -195; 196; -196; 197; -197; 198; -198; 199; -199; 200; -200; 201; -201; 202; -202; 203; -203; 204; -204; 205; -205; 206; -206; 207; -207; 208; -208; 209; -209; 210; -210; 211; -211; 212; -212; 213; -213; 214; -214; 215; -215; 216; -216; 217; -217; 218; -218; 219; -219; 220; -220; 221; -221; 222; -222; 223; -223; 224; -224; 225; -225; 226; -226; 227; -227; 228; -228; 229; -229; 230; -230; 231; -231; 232; -232; 233; -233; 234; -234; 235; -235; 236; -236; 237; -237; 238; -238; 239; -239; 240; -240; 241; -241; 242; -242; 243; -243; 244; -244; 245; -245; 246; -246; 247; -247; 248; -248; 249; -249; 250; -250; 251; -251; 252; -252; 253; -253; 254; -254; 255; -255; 256; -256; 257; -257; 258; -258; 259; -259; 260; -260; 261; -261; 262; -262; 263; -263; 264; -264; 265; -265; 266; -266; 267; -267; 268; -268; 269; -269; 270; -270; 271; -271; 272; -272; 273; -273; 274; -274; 275; -275; 276; -276; 277; -277; 278; -278; 279; -279; 280; -280; 281; -281; 282; -282; 283; -283; 284; -284; 285; -285; 286; -286; 287; -287; 288; -288; 289; -289; 290; -290; 291; -291; 292; -292; 293; -293; 294; -294; 295; -295; 296; -296; 297; -297; 298; -298; 299; -299; 300; -300; 301; -301; 302; -302; 303; -303; 304; -304; 305; -305; 306; -306; 307; -307; 308; -308; 309; -309; 310; -310; 311; -311; 312; -312; 313; -313; 314; -314; 315; -315; 316; -316; 317; -317; 318; -318; 319; -319; 320; -320; 321; -321; 322; -322; 323; -323; 324; -324; 325; -325; 326; -326; 327; -327; 328; -328; 329; -329; 330; -330; 331; -331; 332; -332; 333; -333; 334; -334; 335; -335; 336; -336; 337; -337; 338; -338; 339; -339; 340; -340; 341; -341; 342; -342; 343; -343; 344; -344; 345; -345; 346; -346; 347; -347; 348; -348; 349; -349; 350; -350; 351; -351; 352; -352; 353; -353; 354; -354; 355; -355; 356; -356; 357; -357; 358; -358; 359; -359; 360; -360; 361; -361; 362; -362; 363; -363; 364; -364; 365; -365; 366; -366; 367; -367; 368; -368; 369; -369; 370; -370; 371; -371; 372; -372; 373; -373; 374; -374; 375; -375; 376; -376; 377; -377; 378; -378; 379; -379; 380; -380; 381; -381; 382; -382; 383; -383; 384; -384; 385; -385; 386; -386; 387; -387; 388; -388; 389; -389; 390; -390; 391; -391; 392; -392; 393; -393; 394; -394; 395; -395; 396; -396; 397; -397; 398; -398; 399; -399; 400; -400; 401; -401; 402; -402; 403; -403; 404; -404; 405; -405; 406; -406; 407; -407; 408; -408; 409; -409; 410; -410; 411; -411; 412; -412; 413; -413; 414; -414; 415; -415; 416; -416; 417; -417; 418; -418; 419; -419; 420; -420; 421; -421; 422; -422; 423; -423; 424; -424; 425; -425; 426; -426; 427; -427; 428; -428; 429; -429; 430; -430; 431; -431; 432; -432; 433; -433; 434; -434; 435; -435; 436; -436; 437; -437; 438; -438; 439; -439; 440; -440; 441; -441; 442; -442; 443; -443; 444; -444; 445; -445; 446; -446; 447; -447; 448; -448; 449; -449; 450; -450; 451; -451; 452; -452; 453; -453; 454; -454; 455; -455; 456; -456; 457; -457; 458; -458; 459; -459; 460; -460; 461; -461; 462; -462; 463; -463; 464; -464; 465; -465; 466; -466; 467; -467; 468; -468; 469; -469; 470; -470; 471; -471; 472; -472; 473; -473; 474; -474; 475; -475; 476; -476; 477; -477; 478; -478; 479; -479; 480; -480; 481; -481; 482; -482; 483; -483; 484; -484; 485; -485; 486; -486; 487; -487; 488; -488; 489; -489; 490; -490; 491; -491; 492; -492; 493; -493; 494; -494; 495; -495; 496; -496; 497; -497; 498; -498; 499; -499; 500; -500]);
  assert (sum_zero 10 = [1; -1; 2; -2; 3; -3; 4; -4; 5; -5]);
  assert (sum_zero 5 = [1; -1; 2; -2; 0]);
;;","easy","easy_114","easy"
"(**International Morse Code defines a standard encoding where each letter is mapped to a series of d...
 * >>> unique_morse_representations [""s""; ""u""; ""n""]
 * 3
 * >>> unique_morse_representations [""mnop""; ""qrst""; ""uvwx""; ""yz""]
 * 4
 * >>> unique_morse_representations [""hello""; ""world""]
 * 2
*)
let unique_morse_representations (words : string list) : int =","  0","let () =
  assert (unique_morse_representations [""s""; ""u""; ""n""] = 3);
  assert (unique_morse_representations [""mnop""; ""qrst""; ""uvwx""; ""yz""] = 4);
  assert (unique_morse_representations [""hello""; ""world""] = 2);
  assert (unique_morse_representations [""a""] = 1);
  assert (unique_morse_representations [""morse""; ""coding""; ""challenge""] = 3);
  assert (unique_morse_representations [""hello""; ""world""] = 2);
  assert (unique_morse_representations [""test""; ""code""; ""abcd""] = 3);
;;","easy","easy_107","easy"
"(**Given the head of a linked list, we repeatedly delete consecutive sequences of nodes that sum to ...
 * >>> remove_zero_sum_sublists [0; 0; 0; 0]
 * None
 * >>> remove_zero_sum_sublists [1; 0; 1; -1; 2]
 * [1; 2]
 * >>> remove_zero_sum_sublists [1; 2; 3; 4; 5]
 * [1; 2; 3; 4; 5]
*)
let remove_zero_sum_sublists (head : 'a option) : 'a option =","  None","let () =
  assert (remove_zero_sum_sublists [0; 0; 0; 0] = None);
  assert (remove_zero_sum_sublists [1; 0; 1; -1; 2] = [1; 2]);
  assert (remove_zero_sum_sublists [1; 2; 3; 4; 5] = [1; 2; 3; 4; 5]);
  assert (remove_zero_sum_sublists [10; 20; -30; 40; -50; 60; -10; -50] = [40; -50]);
  assert (remove_zero_sum_sublists [1; -1; 1; -1] = None);
  assert (remove_zero_sum_sublists [1; 2; 3; -3; 4] = [1; 2; 4]);
  assert (remove_zero_sum_sublists [1; -1; 2; -2; 3] = [3]);
;;","medium","medium_079","medium"
"(**Given the root of a binary tree, return the sum of every tree node's tilt.
 * >>> find_tilt [1; 2; 3]
 * 1
 * >>> find_tilt [21; 7; 14; 1; 1; 2; 2; 3; 3]
 * 9
 * >>> find_tilt [10; 5; 15; 3; 7; null; 18]
 * 40
*)
let find_tilt (root : 'a option) : int =","  0","let () =
  assert (find_tilt [1; 2; 3] = 1);
  assert (find_tilt [21; 7; 14; 1; 1; 2; 2; 3; 3] = 9);
  assert (find_tilt [10; 5; 15; 3; 7; null; 18] = 40);
  assert (find_tilt [1; 2; 3; 4; null; 5; 6; null; null; 7; null; 8; 9] = 55);
  assert (find_tilt [4; 2; 9; 3; 5; null; 7] = 15);
  assert (find_tilt [1; 2] = 2);
  assert (find_tilt [1; null; 2; null; 3] = 8);
;;","easy","easy_001","easy"
"(**Given a string s containing an out-of-order English representation of digits 0-9, return the digi...
 * >>> original_digits ""sevensixfivefourthree""
 * 34567
 * >>> original_digits ""fivefivethree""
 * 355
 * >>> original_digits ""oneonetwothreefourfivesixseveneightnine""
 * 1123456789
*)
let original_digits (s : string) : string =","  """"","let () =
  assert (original_digits ""sevensixfivefourthree"" = 34567);
  assert (original_digits ""fivefivethree"" = 355);
  assert (original_digits ""oneonetwothreefourfivesixseveneightnine"" = 1123456789);
  assert (original_digits ""fivefivesixsix"" = 5566);
  assert (original_digits ""sixseveneightnine"" = 6789);
  assert (original_digits ""nieseve"" = 79);
  assert (original_digits ""onetwothree"" = 123);
;;","medium","medium_063","medium"
"(**You are given a 0-indexed integer array arr, and an m x n integer matrix mat. arr and mat both co...
 * >>> first_complete_index [15; 13; 14; 12; 10; 11; 8; 9; 6; 7; 4; 5; 2; 3; 1] [[13; 14; 15]; [10; 11; 12]; [7; 8; 9]; [4; 5; 6]; [1; 2; 3]]
 * 2
 * >>> first_complete_index [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12] [[1; 2; 3; 4]; [5; 6; 7; 8]; [9; 10; 11; 12]]
 * 3
 * >>> first_complete_index [6; 5; 4; 3; 2; 1] [[1; 2]; [3; 4]; [5; 6]]
 * 1
*)
let first_complete_index (arr : int list) (mat : int list list) : int =","  0","let () =
  assert (first_complete_index [15; 13; 14; 12; 10; 11; 8; 9; 6; 7; 4; 5; 2; 3; 1] [[13; 14; 15]; [10; 11; 12]; [7; 8; 9]; [4; 5; 6]; [1; 2; 3]] = 2);
  assert (first_complete_index [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12] [[1; 2; 3; 4]; [5; 6; 7; 8]; [9; 10; 11; 12]] = 3);
  assert (first_complete_index [6; 5; 4; 3; 2; 1] [[1; 2]; [3; 4]; [5; 6]] = 1);
  assert (first_complete_index [5; 1; 9; 11; 2; 6; 3; 10; 7; 4; 8; 12] [[5; 1; 9; 11]; [2; 6; 3; 10]; [7; 4; 8; 12]] = 3);
  assert (first_complete_index [1; 2; 3; 4; 5; 6; 7; 8; 9] [[9; 8; 7]; [6; 5; 4]; [3; 2; 1]] = 2);
  assert (first_complete_index [5; 1; 9; 3; 2; 6; 8; 7; 4] [[1; 2; 3]; [4; 5; 6]; [7; 8; 9]] = 4);
  assert (first_complete_index [2; 8; 7; 4; 1; 3; 5; 6; 9] [[3; 2; 5]; [1; 4; 6]; [8; 7; 9]] = 3);
;;","medium","medium_112","medium"
"(**You are given an integer hoursBefore, the number of hours you have to travel to your meeting. To ...
 * >>> min_skips [10; 10; 10] 5 6
 * 0
 * >>> min_skips [1; 1; 1; 1; 1] 1 3
 * -1
 * >>> min_skips [5; 5; 5; 5; 5] 10 2
 * -1
*)
let min_skips (dist : int list) (speed : int) (hoursBefore : int) : int =","  0","let () =
  assert (min_skips [10; 10; 10] 5 6 = 0);
  assert (min_skips [1; 1; 1; 1; 1] 1 3 = -1);
  assert (min_skips [5; 5; 5; 5; 5] 10 2 = -1);
  assert (min_skips [1; 1; 1; 1] 1 4 = 0);
  assert (min_skips [1; 1; 1; 1; 1; 1; 1; 1; 1; 1] 1 10 = 0);
  assert (min_skips [7; 3; 5; 5] 1 10 = -1);
  assert (min_skips [1; 2; 3; 4; 5] 1 20 = 0);
;;","hard","hard_100","hard"
"(**There are n people in a social group labeled from 0 to n - 1. You are given an array logs where l...
 * >>> earliest_acq [[3; 0; 3]; [11; 0; 1]; [0; 1; 2]; [5; 1; 0]; [8; 3; 0]; [12; 1; 3]; [10; 1; 0]] 4
 * 5
 * >>> earliest_acq [[1; 0; 2]; [2; 2; 1]; [3; 0; 1]] 3
 * 2
 * >>> earliest_acq [[0; 2; 3]; [1; 0; 1]; [4; 0; 2]; [2; 3; 1]; [3; 0; 3]; [5; 1; 3]; [6; 3; 4]] 5
 * 6
*)
let earliest_acq (logs : int list list) (n : int) : int =","  0","let () =
  assert (earliest_acq [[3; 0; 3]; [11; 0; 1]; [0; 1; 2]; [5; 1; 0]; [8; 3; 0]; [12; 1; 3]; [10; 1; 0]] 4 = 5);
  assert (earliest_acq [[1; 0; 2]; [2; 2; 1]; [3; 0; 1]] 3 = 2);
  assert (earliest_acq [[0; 2; 3]; [1; 0; 1]; [4; 0; 2]; [2; 3; 1]; [3; 0; 3]; [5; 1; 3]; [6; 3; 4]] 5 = 6);
  assert (earliest_acq [[8; 1; 2]; [9; 1; 3]; [10; 2; 3]] 4 = -1);
  assert (earliest_acq [[10; 1; 2]; [1; 0; 1]; [8; 1; 0]; [5; 2; 1]] 3 = 5);
  assert (earliest_acq [[0; 2; 0]; [1; 0; 1]; [3; 0; 3]; [4; 1; 2]; [7; 3; 1]] 4 = 3);
  assert (earliest_acq [[20190101; 0; 1]; [20190104; 3; 4]; [20190107; 2; 3]; [20190211; 1; 5]; [20190224; 2; 4]; [20190301; 0; 3]; [20190312; 1; 2]; [20190322; 4; 5]] 6 = 20190301);
;;","medium","medium_180","medium"
"(**You are given an array tasks where tasks[i] = [actuali, minimumi]:
 * >>> minimum_effort [[10; 15]; [20; 25]; [30; 35]]
 * 65
 * >>> minimum_effort [[10; 15]; [5; 10]; [3; 7]]
 * 22
 * >>> minimum_effort [[10; 10]; [15; 15]; [5; 5]]
 * 30
*)
let minimum_effort (tasks : int list list) : int =","  0","let () =
  assert (minimum_effort [[10; 15]; [20; 25]; [30; 35]] = 65);
  assert (minimum_effort [[10; 15]; [5; 10]; [3; 7]] = 22);
  assert (minimum_effort [[10; 10]; [15; 15]; [5; 5]] = 30);
  assert (minimum_effort [[1; 7]; [2; 8]; [3; 9]; [4; 10]; [5; 11]; [6; 12]] = 27);
  assert (minimum_effort [[5; 10]; [1; 2]; [3; 4]] = 10);
  assert (minimum_effort [[1; 2]; [2; 4]; [4; 8]] = 8);
  assert (minimum_effort [[3; 3]; [2; 5]; [1; 4]] = 6);
;;","hard","hard_094","hard"
"(**You are given a 0-indexed 2D matrix grid of size n x n, where (r, c) represents:
 * >>> maximum_safeness_factor [[0; 0; 0; 0; 1]; [0; 0; 0; 0; 0]; [0; 0; 0; 0; 0]; [0; 0; 0; 0; 0]; [1; 0; 0; 0; 0]]
 * 3
 * >>> maximum_safeness_factor [[0; 0; 0; 0; 0]; [0; 1; 0; 1; 0]; [0; 0; 0; 0; 0]; [0; 1; 0; 1; 0]; [0; 0; 0; 0; 1]]
 * 0
 * >>> maximum_safeness_factor [[1; 0; 0; 0]; [0; 0; 0; 0]; [0; 0; 0; 0]; [0; 0; 0; 1]]
 * 0
*)
let maximum_safeness_factor (grid : int list list) : int =","  0","let () =
  assert (maximum_safeness_factor [[0; 0; 0; 0; 1]; [0; 0; 0; 0; 0]; [0; 0; 0; 0; 0]; [0; 0; 0; 0; 0]; [1; 0; 0; 0; 0]] = 3);
  assert (maximum_safeness_factor [[0; 0; 0; 0; 0]; [0; 1; 0; 1; 0]; [0; 0; 0; 0; 0]; [0; 1; 0; 1; 0]; [0; 0; 0; 0; 1]] = 0);
  assert (maximum_safeness_factor [[1; 0; 0; 0]; [0; 0; 0; 0]; [0; 0; 0; 0]; [0; 0; 0; 1]] = 0);
  assert (maximum_safeness_factor [[1; 0; 1; 0]; [0; 0; 0; 0]; [0; 0; 0; 0]; [0; 1; 0; 1]] = 0);
  assert (maximum_safeness_factor [[1; 1; 0; 0]; [0; 0; 0; 0]; [0; 0; 0; 0]; [0; 0; 1; 1]] = 0);
  assert (maximum_safeness_factor [[0; 0; 0; 1]; [0; 0; 0; 0]; [0; 0; 0; 0]; [1; 0; 0; 0]] = 2);
  assert (maximum_safeness_factor [[0; 0; 1]; [0; 0; 0]; [0; 0; 0]] = 2);
;;","medium","medium_106","medium"
"(**Given an integer array arr, return true if there are three consecutive odd numbers in the array. ...
 * >>> three_consecutive_odds [1; 3; 2; 5; 7; 9]
 * true
 * >>> three_consecutive_odds [2; 4; 6; 8; 10]
 * false
 * >>> three_consecutive_odds [1; 1; 1; 1; 1; 1]
 * true
*)
let three_consecutive_odds (arr : int list) : bool =","  false","let () =
  assert (three_consecutive_odds [1; 3; 2; 5; 7; 9] = true);
  assert (three_consecutive_odds [2; 4; 6; 8; 10] = false);
  assert (three_consecutive_odds [1; 1; 1; 1; 1; 1] = true);
  assert (three_consecutive_odds [1000; 999; 998; 997] = false);
  assert (three_consecutive_odds [2; 3; 5; 7; 11; 13] = true);
  assert (three_consecutive_odds [2; 6; 4; 1] = false);
  assert (three_consecutive_odds [999; 997; 995; 993; 991] = true);
;;","easy","easy_184","easy"
"(**You are given an m x n grid where each cell can have one of three values:
 * >>> oranges_rotting [[1; 1; 1]; [1; 1; 1]; [1; 1; 1]]
 * -1
 * >>> oranges_rotting [[1; 2; 1; 1; 2; 1; 1]]
 * 2
 * >>> oranges_rotting [[2; 2; 2]; [2; 1; 2]; [2; 2; 2]]
 * 1
*)
let oranges_rotting (grid : int list list) : int =","  0","let () =
  assert (oranges_rotting [[1; 1; 1]; [1; 1; 1]; [1; 1; 1]] = -1);
  assert (oranges_rotting [[1; 2; 1; 1; 2; 1; 1]] = 2);
  assert (oranges_rotting [[2; 2; 2]; [2; 1; 2]; [2; 2; 2]] = 1);
  assert (oranges_rotting [[2; 1; 1]; [0; 1; 1]; [1; 0; 1]] = -1);
  assert (oranges_rotting [[2; 1; 1]; [1; 1; 0]; [0; 1; 1]] = 4);
  assert (oranges_rotting [[1]; [2]] = 1);
  assert (oranges_rotting [[0; 2]] = 0);
;;","medium","medium_003","medium"
"(**Given a valid (IPv4) IP address, return a defanged version of that IP address.\r
 * >>> defang_ipaddr ""255.100.50.0""
 * 255[.]100[.]50[.]0
 * >>> defang_ipaddr ""255.255.255.255""
 * 255[.]255[.]255[.]255
 * >>> defang_ipaddr ""192.168.1.1""
 * 192[.]168[.]1[.]1
*)
let defang_ipaddr (address : string) : string =","  """"","let () =
  assert (defang_ipaddr ""255.100.50.0"" = 255[.]100[.]50[.]0);
  assert (defang_ipaddr ""255.255.255.255"" = 255[.]255[.]255[.]255);
  assert (defang_ipaddr ""192.168.1.1"" = 192[.]168[.]1[.]1);
  assert (defang_ipaddr ""0.0.0.0"" = 0[.]0[.]0[.]0);
  assert (defang_ipaddr ""1.1.1.1"" = 1[.]1[.]1[.]1);
  assert (defang_ipaddr ""198.18.0.0"" = 198[.]18[.]0[.]0);
  assert (defang_ipaddr ""010.020.030.040"" = 010[.]020[.]030[.]040);
;;","easy","easy_034","easy"
"(**Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such t...
 * >>> remove_duplicates [0; 0; 0; 0; 0; 0; 0; 0; 0; 0]
 * 1
 * >>> remove_duplicates [-100; 0; 100]
 * 3
 * >>> remove_duplicates [1; 2; 2; 3; 4; 4; 4; 5]
 * 5
*)
let remove_duplicates (nums : int list) : int =","  0","let () =
  assert (remove_duplicates [0; 0; 0; 0; 0; 0; 0; 0; 0; 0] = 1);
  assert (remove_duplicates [-100; 0; 100] = 3);
  assert (remove_duplicates [1; 2; 2; 3; 4; 4; 4; 5] = 5);
  assert (remove_duplicates [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = 10);
  assert (remove_duplicates [1] = 1);
  assert (remove_duplicates [0; 1; 1; 2; 2; 2; 3; 3; 3; 3; 4; 4; 4; 4; 4] = 5);
  assert (remove_duplicates [-1; -1; -1; -1; -1] = 1);
;;","easy","easy_028","easy"
"(**You are given a string s and a positive integer k.
 * >>> beautiful_substrings ""aeaeaeae"" 8
 * 0
 * >>> beautiful_substrings ""bcdfghjklmnpqrstvwxyz"" 2
 * 0
 * >>> beautiful_substrings ""aebcdfe"" 3
 * 0
*)
let beautiful_substrings (s : string) (k : int) : int =","  0","let () =
  assert (beautiful_substrings ""aeaeaeae"" 8 = 0);
  assert (beautiful_substrings ""bcdfghjklmnpqrstvwxyz"" 2 = 0);
  assert (beautiful_substrings ""aebcdfe"" 3 = 0);
  assert (beautiful_substrings """" 1 = 0);
  assert (beautiful_substrings ""baeyh"" 2 = 2);
  assert (beautiful_substrings ""aebcdeedaa"" 4 = 6);
  assert (beautiful_substrings ""bcdf"" 1 = 0);
;;","medium","medium_139","medium"
"(**You are given two arrays of strings that represent two inclusive events that happened on the same...
 * >>> have_conflict [""10:00""; ""11:00""] [""14:00""; ""15:00""]
 * false
 * >>> have_conflict [""00:00""; ""23:59""] [""12:00""; ""12:01""]
 * true
 * >>> have_conflict [""00:00""; ""23:59""] [""12:00""; ""12:00""]
 * true
*)
let have_conflict (event1 : string list) (event2 : string list) : bool =","  false","let () =
  assert (have_conflict [""10:00""; ""11:00""] [""14:00""; ""15:00""] = false);
  assert (have_conflict [""00:00""; ""23:59""] [""12:00""; ""12:01""] = true);
  assert (have_conflict [""00:00""; ""23:59""] [""12:00""; ""12:00""] = true);
  assert (have_conflict [""00:00""; ""23:59""] [""12:00""; ""12:30""] = true);
  assert (have_conflict [""01:15""; ""02:00""] [""02:00""; ""03:00""] = true);
  assert (have_conflict [""09:30""; ""10:30""] [""10:00""; ""11:00""] = true);
  assert (have_conflict [""05:45""; ""06:45""] [""06:45""; ""07:45""] = true);
;;","easy","easy_144","easy"
"(**Given an input string s and a pattern p, implement regular expression matching with support for '...
 * >>> is_match ""aa"" ""a*""
 * true
 * >>> is_match ""aab"" ""c*a*b""
 * true
 * >>> is_match ""ab"" "".*""
 * true
*)
let is_match (s : string) (p : string) : bool =","  false","let () =
  assert (is_match ""aa"" ""a*"" = true);
  assert (is_match ""aab"" ""c*a*b"" = true);
  assert (is_match ""ab"" "".*"" = true);
  assert (is_match ""aa"" ""a"" = false);
  assert (is_match ""mississippi"" ""mis*is*p*."" = false);
  assert (is_match ""aabbccddeeff"" ""a*b*c*d*e*f*f*"" = true);
  assert (is_match ""abababa"" ""(ab)*a"" = false);
;;","hard","hard_069","hard"
"(**You are given an array of strings ideas that represents a list of names to be used in the process...
 * >>> distinct_names [""coffee""; ""donuts""; ""time""; ""toffee""]
 * 6
 * >>> distinct_names [""aaa""; ""bbb""; ""ccc""]
 * 6
 * >>> distinct_names [""aaa""; ""bbb""; ""ccc""; ""aab""; ""abb""; ""acc""; ""baa""; ""bab""; ""bac""; ""bba""; ""bbb""; ""bbc""; ""caa""; ""cab""; ""cac""; ""cba""; ""cbb""; ""cbc""]
 * 6
*)
let distinct_names (ideas : string list) : int =","  0","let () =
  assert (distinct_names [""coffee""; ""donuts""; ""time""; ""toffee""] = 6);
  assert (distinct_names [""aaa""; ""bbb""; ""ccc""] = 6);
  assert (distinct_names [""aaa""; ""bbb""; ""ccc""; ""aab""; ""abb""; ""acc""; ""baa""; ""bab""; ""bac""; ""bba""; ""bbb""; ""bbc""; ""caa""; ""cab""; ""cac""; ""cba""; ""cbb""; ""cbc""] = 6);
  assert (distinct_names [""abc""; ""bcd""; ""cde""; ""dec""] = 12);
  assert (distinct_names [""abcd""; ""dcba""; ""ddda""; ""dccd""] = 6);
  assert (distinct_names [""aaa""; ""aab""; ""aac""; ""aba""; ""abb""; ""abc""; ""aca""; ""acb""; ""acc""; ""baa""; ""bab""; ""bac""; ""bba""; ""bbb""; ""bbc""; ""bca""; ""bcb""; ""bcc""; ""caa""; ""cab""; ""cac""; ""cba""; ""cbb""; ""cbc""; ""cca""; ""ccb""; ""ccc""] = 0);
  assert (distinct_names [""aaa""; ""bbb""; ""ccc""; ""ddd""] = 12);
;;","hard","hard_024","hard"
"(**For a binary tree T, we can define a flip operation as follows: choose any node, and swap the lef...
 * >>> flip_equiv [1; 2; 3] [1; 3; 2]
 * true
 * >>> flip_equiv [1; 2; 3; 4; 5] [1; 3; 2; 5; 4]
 * false
 * >>> flip_equiv [] [1]
 * false
*)
let flip_equiv (root1 : 'a option) (root2 : 'a option) : bool =","  false","let () =
  assert (flip_equiv [1; 2; 3] [1; 3; 2] = true);
  assert (flip_equiv [1; 2; 3; 4; 5] [1; 3; 2; 5; 4] = false);
  assert (flip_equiv [] [1] = false);
  assert (flip_equiv [1; 2; 3; 4; 5; 6; 7] [1; 3; 2; 7; 6; 5; 4] = true);
  assert (flip_equiv [] [] = true);
  assert (flip_equiv [1; 2; 3; 4; 5; 6; null; null; null; 7; 8] [1; 3; 2; null; 6; 4; 5; null; null; null; null; 8; 7] = true);
  assert (flip_equiv [1; 2; 3; 4] [1; 3; 2; 4] = false);
;;","medium","medium_144","medium"
"(**The width of a sequence is the difference between the maximum and minimum elements in the sequence.
 * >>> sum_subseq_widths [10; 20; 30]
 * 60
 * >>> sum_subseq_widths [9; 7; 5; 3; 1]
 * 144
 * >>> sum_subseq_widths [1; 2; 4; 8; 16]
 * 261
*)
let sum_subseq_widths (nums : int list) : int =","  0","let () =
  assert (sum_subseq_widths [10; 20; 30] = 60);
  assert (sum_subseq_widths [9; 7; 5; 3; 1] = 144);
  assert (sum_subseq_widths [1; 2; 4; 8; 16] = 261);
  assert (sum_subseq_widths [9; 8; 7; 6; 5; 4; 3; 2; 1] = 3084);
  assert (sum_subseq_widths [1; 3; 5; 7; 9] = 144);
  assert (sum_subseq_widths [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = 7181);
  assert (sum_subseq_widths [1] = 0);
;;","hard","hard_002","hard"
"(**In combinatorial mathematics, a derangement is a permutation of the elements of a set, such that ...
 * >>> find_derangement 3
 * 2
 * >>> find_derangement 100000
 * 183389504
 * >>> find_derangement 100
 * 944828409
*)
let find_derangement (n : int) : int =","  0","let () =
  assert (find_derangement 3 = 2);
  assert (find_derangement 100000 = 183389504);
  assert (find_derangement 100 = 944828409);
  assert (find_derangement 4 = 9);
  assert (find_derangement 10000 = 381587473);
  assert (find_derangement 1000000 = 102701088);
  assert (find_derangement 2 = 1);
;;","medium","medium_055","medium"
"(**Given the head of a singly linked list, reverse the list, and return the reversed list.
 * >>> reverse_list [5000; -5000; 0; 1000; -1000]
 * [-1000; 1000; 0; -5000; 5000]
 * >>> reverse_list [1; 2; 3; 4; 5]
 * [5; 4; 3; 2; 1]
 * >>> reverse_list []
 * None
*)
let reverse_list (head : 'a option) : 'a option =","  None","let () =
  assert (reverse_list [5000; -5000; 0; 1000; -1000] = [-1000; 1000; 0; -5000; 5000]);
  assert (reverse_list [1; 2; 3; 4; 5] = [5; 4; 3; 2; 1]);
  assert (reverse_list [] = None);
  assert (reverse_list [1; 2] = [2; 1]);
  assert (reverse_list [1] = [1]);
  assert (reverse_list [-1; -2; -3; -4; -5] = [-5; -4; -3; -2; -1]);
  assert (reverse_list [3] = [3]);
;;","easy","easy_167","easy"
"(**There are n cities numbered from 1 to n. You are given an array edges of size n-1, where edges[i]...
 * >>> count_subgraphs_for_each_diameter 6 [[1; 2]; [1; 3]; [1; 4]; [2; 5]; [2; 6]]
 * [5; 8; 9; 0; 0]
 * >>> count_subgraphs_for_each_diameter 5 [[1; 2]; [2; 3]; [3; 4]; [4; 5]]
 * [4; 3; 2; 1]
 * >>> count_subgraphs_for_each_diameter 10 [[1; 2]; [1; 3]; [2; 4]; [2; 5]; [3; 6]; [3; 7]; [4; 8]; [4; 9]; [5; 10]]
 * [9; 14; 18; 26; 33; 0; 0; 0; 0]
*)
let count_subgraphs_for_each_diameter (n : int) (edges : int list list) : int list =","  []","let () =
  assert (count_subgraphs_for_each_diameter 6 [[1; 2]; [1; 3]; [1; 4]; [2; 5]; [2; 6]] = [5; 8; 9; 0; 0]);
  assert (count_subgraphs_for_each_diameter 5 [[1; 2]; [2; 3]; [3; 4]; [4; 5]] = [4; 3; 2; 1]);
  assert (count_subgraphs_for_each_diameter 10 [[1; 2]; [1; 3]; [2; 4]; [2; 5]; [3; 6]; [3; 7]; [4; 8]; [4; 9]; [5; 10]] = [9; 14; 18; 26; 33; 0; 0; 0; 0]);
  assert (count_subgraphs_for_each_diameter 7 [[1; 2]; [1; 3]; [1; 4]; [2; 5]; [3; 6]; [4; 7]] = [6; 7; 9; 7; 0; 0]);
  assert (count_subgraphs_for_each_diameter 6 [[1; 2]; [1; 3]; [2; 4]; [2; 5]; [3; 6]] = [5; 6; 4; 3; 0]);
  assert (count_subgraphs_for_each_diameter 5 [[1; 2]; [1; 3]; [1; 4]; [1; 5]] = [4; 11; 0; 0]);
  assert (count_subgraphs_for_each_diameter 5 [[1; 2]; [1; 3]; [2; 4]; [2; 5]] = [4; 5; 3; 0]);
;;","hard","hard_043","hard"
"(**There is a 1 million by 1 million grid on an XY-plane, and the coordinates of each grid square ar...
 * >>> is_escape_possible [[1; 1]; [1; 2]; [1; 3]; [2; 1]; [2; 2]; [2; 3]; [3; 1]; [3; 2]; [3; 3]] [0; 0] [6; 6]
 * true
 * >>> is_escape_possible [[5; 5]] [4; 4] [6; 6]
 * true
 * >>> is_escape_possible [] [0; 0] [999999; 999999]
 * true
*)
let is_escape_possible (blocked : int list list) (source : int list) (target : int list) : bool =","  false","let () =
  assert (is_escape_possible [[1; 1]; [1; 2]; [1; 3]; [2; 1]; [2; 2]; [2; 3]; [3; 1]; [3; 2]; [3; 3]] [0; 0] [6; 6] = true);
  assert (is_escape_possible [[5; 5]] [4; 4] [6; 6] = true);
  assert (is_escape_possible [] [0; 0] [999999; 999999] = true);
  assert (is_escape_possible [[1; 2]; [2; 1]; [2; 3]; [3; 2]] [0; 0] [4; 4] = true);
  assert (is_escape_possible [[10; 10]; [11; 10]; [12; 10]; [13; 10]] [9; 9] [14; 14] = true);
  assert (is_escape_possible [[500000; 500000]] [499999; 499999] [500001; 500001] = true);
  assert (is_escape_possible [[10; 10]; [10; 11]; [10; 12]; [11; 10]; [11; 11]; [11; 12]; [12; 10]; [12; 11]; [12; 12]] [9; 9] [13; 13] = true);
;;","hard","hard_019","hard"
"(**You are given a 0-indexed integer array nums and an integer k.
 * >>> min_or_after_operations [30; 20; 10; 0] 2
 * 0
 * >>> min_or_after_operations [5; 5; 5; 5; 5; 5] 5
 * 5
 * >>> min_or_after_operations [0; 0; 0; 0; 0] 0
 * 0
*)
let min_or_after_operations (nums : int list) (k : int) : int =","  0","let () =
  assert (min_or_after_operations [30; 20; 10; 0] 2 = 0);
  assert (min_or_after_operations [5; 5; 5; 5; 5; 5] 5 = 5);
  assert (min_or_after_operations [0; 0; 0; 0; 0] 0 = 0);
  assert (min_or_after_operations [1; 0; 1; 0; 1] 2 = 1);
  assert (min_or_after_operations [31; 31; 31; 31; 31] 3 = 31);
  assert (min_or_after_operations [1; 2; 3; 4; 5] 3 = 0);
  assert (min_or_after_operations [0; 0; 0; 0; 0] 2 = 0);
;;","hard","hard_074","hard"
"(**You are given two integer arrays nums1 and nums2 of length n.
 * >>> minimum_xorsum [3; 4; 2] [4; 2; 2]
 * 1
 * >>> minimum_xorsum [1; 2] [2; 3]
 * 2
 * >>> minimum_xorsum [2; 3; 4; 5] [5; 4; 3; 2]
 * 0
*)
let minimum_xorsum (nums1 : int list) (nums2 : int list) : int =","  0","let () =
  assert (minimum_xorsum [3; 4; 2] [4; 2; 2] = 1);
  assert (minimum_xorsum [1; 2] [2; 3] = 2);
  assert (minimum_xorsum [2; 3; 4; 5] [5; 4; 3; 2] = 0);
  assert (minimum_xorsum [4; 6; 2] [9; 3; 5] = 17);
  assert (minimum_xorsum [5; 10; 15] [15; 10; 5] = 0);
  assert (minimum_xorsum [10; 20; 30] [30; 20; 10] = 0);
  assert (minimum_xorsum [1; 2; 3; 4] [4; 3; 2; 1] = 0);
;;","hard","hard_082","hard"
"(**You are given three positive integers n, x, and y.
 * >>> count_of_pairs 10 4 9
 * [20; 24; 22; 14; 8; 2; 0; 0; 0; 0]
 * >>> count_of_pairs 10 4 6
 * [20; 18; 16; 14; 10; 6; 4; 2; 0; 0]
 * >>> count_of_pairs 10 3 7
 * [20; 24; 20; 16; 8; 2; 0; 0; 0; 0]
*)
let count_of_pairs (n : int) (x : int) (y : int) : int list =","  []","let () =
  assert (count_of_pairs 10 4 9 = [20; 24; 22; 14; 8; 2; 0; 0; 0; 0]);
  assert (count_of_pairs 10 4 6 = [20; 18; 16; 14; 10; 6; 4; 2; 0; 0]);
  assert (count_of_pairs 10 3 7 = [20; 24; 20; 16; 8; 2; 0; 0; 0; 0]);
  assert (count_of_pairs 10 3 8 = [20; 24; 24; 16; 6; 0; 0; 0; 0; 0]);
  assert (count_of_pairs 4 1 1 = [6; 4; 2; 0]);
  assert (count_of_pairs 100 1 100 = [200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 200; 100; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0]);
  assert (count_of_pairs 5 2 4 = [10; 8; 2; 0; 0]);
;;","medium","medium_183","medium"
"(**You are given a string s. Simulate events at each second i:
 * >>> minimum_chairs ""ELEELEELLL""
 * 3
 * >>> minimum_chairs ""EEEEEEE""
 * 7
 * >>> minimum_chairs ""EELLEELLL""
 * 2
*)
let minimum_chairs (s : string) : int =","  0","let () =
  assert (minimum_chairs ""ELEELEELLL"" = 3);
  assert (minimum_chairs ""EEEEEEE"" = 7);
  assert (minimum_chairs ""EELLEELLL"" = 2);
  assert (minimum_chairs ""E"" = 1);
  assert (minimum_chairs ""EELLEL"" = 2);
  assert (minimum_chairs ""ELE"" = 1);
  assert (minimum_chairs ""LE"" = 0);
;;","easy","easy_058","easy"
"(**You are given a 0-indexed string s having an even length n.
 * >>> can_make_palindrome_queries ""abbcdecbba"" [[0; 2; 7; 9]]
 * [false]
 * >>> can_make_palindrome_queries ""abcabc"" [[1; 1; 3; 5]; [0; 2; 5; 5]]
 * [true; true]
 * >>> can_make_palindrome_queries ""abcdefgfedcba"" [[1; 2; 11; 12]; [3; 4; 8; 9]]
 * [true; true]
*)
let can_make_palindrome_queries (s : string) (queries : int list list) : bool list =","  []","let () =
  assert (can_make_palindrome_queries ""abbcdecbba"" [[0; 2; 7; 9]] = [false]);
  assert (can_make_palindrome_queries ""abcabc"" [[1; 1; 3; 5]; [0; 2; 5; 5]] = [true; true]);
  assert (can_make_palindrome_queries ""abcdefgfedcba"" [[1; 2; 11; 12]; [3; 4; 8; 9]] = [true; true]);
  assert (can_make_palindrome_queries ""acbcab"" [[1; 2; 4; 5]] = [true]);
  assert (can_make_palindrome_queries ""aabbaa"" [[0; 2; 3; 5]] = [true]);
  assert (can_make_palindrome_queries ""abcdedcba"" [[0; 1; 7; 8]; [2; 3; 5; 6]] = [true; true]);
  assert (can_make_palindrome_queries ""aabbccdd"" [[0; 1; 6; 7]; [2; 3; 4; 5]] = [false; false]);
;;","hard","hard_063","hard"
"(**On a social network consisting of m users and some friendships between users, two users can commu...
 * >>> minimum_teachings 4 [[1]; [2]; [3]; [4]] [[1; 2]; [2; 3]; [3; 4]; [4; 1]]
 * 3
 * >>> minimum_teachings 3 [[1; 2]; [2; 3]; [3; 1]] [[1; 2]; [2; 3]; [3; 1]]
 * 0
 * >>> minimum_teachings 5 [[1; 2]; [2; 3]; [3; 4]; [4; 5]; [1; 5]] [[1; 2]; [2; 3]; [3; 4]; [4; 5]]
 * 0
*)
let minimum_teachings (n : int) (languages : int list list) (friendships : int list list) : int =","  0","let () =
  assert (minimum_teachings 4 [[1]; [2]; [3]; [4]] [[1; 2]; [2; 3]; [3; 4]; [4; 1]] = 3);
  assert (minimum_teachings 3 [[1; 2]; [2; 3]; [3; 1]] [[1; 2]; [2; 3]; [3; 1]] = 0);
  assert (minimum_teachings 5 [[1; 2]; [2; 3]; [3; 4]; [4; 5]; [1; 5]] [[1; 2]; [2; 3]; [3; 4]; [4; 5]] = 0);
  assert (minimum_teachings 2 [[1]; [2]; [1; 2]] [[1; 2]; [1; 3]; [2; 3]] = 1);
  assert (minimum_teachings 4 [[1; 3]; [2; 4]; [1; 2]; [3; 4]] [[1; 2]; [2; 3]; [3; 4]] = 2);
  assert (minimum_teachings 4 [[1]; [2]; [3]; [4]] [[1; 2]; [2; 3]; [3; 4]; [1; 4]] = 3);
  assert (minimum_teachings 5 [[1]; [2]; [3]; [4]; [5]] [[1; 2]; [2; 3]; [3; 4]; [4; 5]] = 4);
;;","medium","medium_149","medium"
"(**You are given an array points representing integer coordinates of some points on a 2D plane, wher...
 * >>> minimum_distance [[1; 2]; [2; 3]; [3; 4]; [4; 5]]
 * 4
 * >>> minimum_distance [[1; 9]; [9; 1]; [2; 8]; [8; 2]; [3; 7]; [7; 3]; [4; 6]; [6; 4]; [5; 5]]
 * 14
 * >>> minimum_distance [[1; 2]; [4; 6]; [8; 10]; [15; 18]]
 * 15
*)
let minimum_distance (points : int list list) : int =","  0","let () =
  assert (minimum_distance [[1; 2]; [2; 3]; [3; 4]; [4; 5]] = 4);
  assert (minimum_distance [[1; 9]; [9; 1]; [2; 8]; [8; 2]; [3; 7]; [7; 3]; [4; 6]; [6; 4]; [5; 5]] = 14);
  assert (minimum_distance [[1; 2]; [4; 6]; [8; 10]; [15; 18]] = 15);
  assert (minimum_distance [[1; 3]; [2; 2]; [3; 1]; [6; 6]; [7; 7]; [8; 8]] = 10);
  assert (minimum_distance [[1; 2]; [2; 3]; [3; 4]; [4; 5]; [5; 6]] = 6);
  assert (minimum_distance [[1; 1]; [2; 2]; [3; 3]; [4; 4]; [5; 5]; [6; 6]; [7; 7]; [8; 8]; [9; 9]] = 14);
  assert (minimum_distance [[1; 100000000]; [100000000; 1]; [1; 1]; [100000000; 100000000]] = 199999998);
;;","hard","hard_056","hard"
"(**An axis-aligned rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) is the coordi...
 * >>> is_rectangle_overlap [-5; -5; -3; -3] [-4; -4; -2; -2]
 * true
 * >>> is_rectangle_overlap [1; 1; 5; 5] [4; 4; 8; 8]
 * true
 * >>> is_rectangle_overlap [-5; -5; -2; -2] [-4; -4; -1; -1]
 * true
*)
let is_rectangle_overlap (rec1 : int list) (rec2 : int list) : bool =","  false","let () =
  assert (is_rectangle_overlap [-5; -5; -3; -3] [-4; -4; -2; -2] = true);
  assert (is_rectangle_overlap [1; 1; 5; 5] [4; 4; 8; 8] = true);
  assert (is_rectangle_overlap [-5; -5; -2; -2] [-4; -4; -1; -1] = true);
  assert (is_rectangle_overlap [-2; -2; 0; 0] [-1; -1; 1; 1] = true);
  assert (is_rectangle_overlap [1; 1; 4; 4] [0; 0; 3; 3] = true);
  assert (is_rectangle_overlap [5; 5; 10; 10] [1; 1; 6; 6] = true);
  assert (is_rectangle_overlap [5; 5; 10; 10] [8; 8; 15; 15] = true);
;;","easy","easy_029","easy"
"(**Given a string s, return the number of substrings that have only one distinct letter.
 * >>> count_letters ""aabbcc""
 * 9
 * >>> count_letters ""bbccdd""
 * 9
 * >>> count_letters ""zzzzz""
 * 15
*)
let count_letters (s : string) : int =","  0","let () =
  assert (count_letters ""aabbcc"" = 9);
  assert (count_letters ""bbccdd"" = 9);
  assert (count_letters ""zzzzz"" = 15);
  assert (count_letters ""aaaba"" = 8);
  assert (count_letters ""abcdabcdabcd"" = 12);
  assert (count_letters ""ababab"" = 6);
  assert (count_letters ""zzz"" = 6);
;;","easy","easy_080","easy"
"(**You are given two 0-indexed binary arrays nums1 and nums2. Find the widest pair of indices (i, j)...
 * >>> widest_pair_of_indices [0; 1] [1; 1]
 * 1
 * >>> widest_pair_of_indices [0; 1; 0; 1; 0; 1; 0; 1] [1; 0; 1; 0; 1; 0; 1; 0]
 * 8
 * >>> widest_pair_of_indices [1; 0; 0; 1; 0] [0; 1; 1; 0; 1]
 * 4
*)
let widest_pair_of_indices (nums1 : int list) (nums2 : int list) : int =","  0","let () =
  assert (widest_pair_of_indices [0; 1] [1; 1] = 1);
  assert (widest_pair_of_indices [0; 1; 0; 1; 0; 1; 0; 1] [1; 0; 1; 0; 1; 0; 1; 0] = 8);
  assert (widest_pair_of_indices [1; 0; 0; 1; 0] [0; 1; 1; 0; 1] = 4);
  assert (widest_pair_of_indices [0; 1; 0; 1; 0] [1; 0; 1; 0; 1] = 4);
  assert (widest_pair_of_indices [0; 0; 1; 1; 1] [1; 1; 1; 0; 0] = 5);
  assert (widest_pair_of_indices [1; 0; 0; 0; 0] [0; 0; 0; 0; 1] = 5);
  assert (widest_pair_of_indices [1; 1; 1; 0; 0] [0; 0; 1; 1; 1] = 5);
;;","medium","medium_082","medium"
"(**Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only ...
 * >>> num_equiv_domino_pairs [[7; 8]; [8; 7]; [9; 10]; [10; 9]; [11; 12]]
 * 2
 * >>> num_equiv_domino_pairs [[7; 8]; [8; 7]; [7; 8]; [7; 8]; [8; 7]]
 * 10
 * >>> num_equiv_domino_pairs [[1; 1]; [1; 1]; [1; 1]; [1; 1]; [1; 1]]
 * 10
*)
let num_equiv_domino_pairs (dominoes : int list list) : int =","  0","let () =
  assert (num_equiv_domino_pairs [[7; 8]; [8; 7]; [9; 10]; [10; 9]; [11; 12]] = 2);
  assert (num_equiv_domino_pairs [[7; 8]; [8; 7]; [7; 8]; [7; 8]; [8; 7]] = 10);
  assert (num_equiv_domino_pairs [[1; 1]; [1; 1]; [1; 1]; [1; 1]; [1; 1]] = 10);
  assert (num_equiv_domino_pairs [[1; 2]; [2; 1]; [3; 4]; [5; 6]] = 1);
  assert (num_equiv_domino_pairs [[1; 1]; [2; 2]; [3; 3]; [4; 4]; [5; 5]] = 0);
  assert (num_equiv_domino_pairs [[1; 2]; [2; 3]; [3; 4]; [4; 5]] = 0);
  assert (num_equiv_domino_pairs [[1; 1]; [2; 2]; [1; 2]; [2; 1]] = 1);
;;","easy","easy_077","easy"
"(**Given an array of positive integers nums, remove the smallest subarray (possibly empty) such that...
 * >>> min_subarray [5; 5; 5; 5; 5; 5] 3
 * 0
 * >>> min_subarray [1; 2; 3; 4; 5] 2
 * 1
 * >>> min_subarray [7; 8; 9; 10; 11] 11
 * 4
*)
let min_subarray (nums : int list) (p : int) : int =","  0","let () =
  assert (min_subarray [5; 5; 5; 5; 5; 5] 3 = 0);
  assert (min_subarray [1; 2; 3; 4; 5] 2 = 1);
  assert (min_subarray [7; 8; 9; 10; 11] 11 = 4);
  assert (min_subarray [1; 2; 3; 4; 5] 10 = 1);
  assert (min_subarray [1; 1; 1; 1; 1; 1; 1; 1; 1; 1] 5 = 0);
  assert (min_subarray [9; 8; 7; 6; 5; 4; 3; 2; 1] 11 = 1);
  assert (min_subarray [1000000000] 1000000000 = 0);
;;","medium","medium_174","medium"
"(**Given the root of a complete binary tree, return the number of the nodes in the tree.
 * >>> count_nodes [1; 2; 3; 4; 5; 6; 7]
 * 7
 * >>> count_nodes [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15]
 * 15
 * >>> count_nodes [1; 2; 3; 4; 5; null; 7]
 * 6
*)
let count_nodes (root : 'a option) : int =","  0","let () =
  assert (count_nodes [1; 2; 3; 4; 5; 6; 7] = 7);
  assert (count_nodes [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15] = 15);
  assert (count_nodes [1; 2; 3; 4; 5; null; 7] = 6);
  assert (count_nodes [1; 2; 3; 4; 5; 6] = 6);
  assert (count_nodes [1] = 1);
  assert (count_nodes [] = 0);
  assert (count_nodes [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; null; null; 16; 17] = 15);
;;","easy","easy_054","easy"
"(**Given an m x n matrix board where each cell is a battleship 'X' or empty '.', return the number o...
 * >>> count_battleships [['X'; '.'; '.'; 'X']; ['.'; '.'; '.'; 'X']; ['.'; '.'; '.'; 'X']]
 * 2
 * >>> count_battleships [['X'; 'X'; 'X']; ['.'; '.'; '.']; ['X'; 'X'; 'X']]
 * 2
 * >>> count_battleships [['.']]
 * 0
*)
let count_battleships (board : string list list) : int =","  0","let () =
  assert (count_battleships [['X'; '.'; '.'; 'X']; ['.'; '.'; '.'; 'X']; ['.'; '.'; '.'; 'X']] = 2);
  assert (count_battleships [['X'; 'X'; 'X']; ['.'; '.'; '.']; ['X'; 'X'; 'X']] = 2);
  assert (count_battleships [['.']] = 0);
  assert (count_battleships [['X'; '.'; '.']; ['.'; 'X'; '.']; ['.'; '.'; 'X']] = 3);
  assert (count_battleships [['X'; '.'; '.']; ['X'; 'X'; '.']; ['.'; '.'; 'X']] = 2);
  assert (count_battleships [['.'; '.'; '.'; '.'; '.']; ['.'; '.'; '.'; '.'; '.']; ['.'; '.'; '.'; '.'; '.']; ['.'; '.'; '.'; '.'; '.']; ['X'; '.'; 'X'; '.'; 'X']] = 3);
  assert (count_battleships [['.'; '.'; '.'; '.']; ['.'; 'X'; 'X'; 'X']; ['.'; 'X'; '.'; '.']; ['.'; '.'; '.'; '.']] = 1);
;;","medium","medium_035","medium"
"(**You are given an array nums consisting of non-negative integers. You are also given a queries arr...
 * >>> maximize_xor [1; 2; 4; 8; 16] [[10; 15]; [30; 20]; [5; 5]]
 * [14; 31; 7]
 * >>> maximize_xor [100; 200; 300; 400] [[150; 250]; [10; 100]; [450; 500]]
 * [242; 110; 422]
 * >>> maximize_xor [7; 8; 9] [[1; 5]; [6; 8]; [10; 12]]
 * [-1; 14; 13]
*)
let maximize_xor (nums : int list) (queries : int list list) : int list =","  []","let () =
  assert (maximize_xor [1; 2; 4; 8; 16] [[10; 15]; [30; 20]; [5; 5]] = [14; 31; 7]);
  assert (maximize_xor [100; 200; 300; 400] [[150; 250]; [10; 100]; [450; 500]] = [242; 110; 422]);
  assert (maximize_xor [7; 8; 9] [[1; 5]; [6; 8]; [10; 12]] = [-1; 14; 13]);
  assert (maximize_xor [1; 1; 1; 1; 1; 1; 1; 1; 1; 1] [[1; 1]; [1; 1]; [1; 1]; [1; 1]; [1; 1]; [1; 1]; [1; 1]; [1; 1]; [1; 1]; [1; 1]] = [0; 0; 0; 0; 0; 0; 0; 0; 0; 0]);
  assert (maximize_xor [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] [[1; 10]; [2; 5]; [3; 3]; [4; 4]; [5; 2]; [6; 6]; [7; 7]; [8; 8]; [9; 9]; [10; 1]] = [11; 7; 2; 7; 7; 7; 6; 15; 15; 11]);
  assert (maximize_xor [1000000000] [[1000000000; 1000000000]; [999999999; 999999999]] = [0; -1]);
  assert (maximize_xor [5; 2; 4; 6; 6; 3] [[12; 4]; [8; 1]; [6; 3]] = [15; -1; 5]);
;;","hard","hard_084","hard"
"(**Given an integer array nums, return the number of non-empty subarrays with the leftmost element o...
 * >>> valid_subarrays [10; 5; 10; 4; 15]
 * 7
 * >>> valid_subarrays [0; 1; 2; 3; 4; 5]
 * 21
 * >>> valid_subarrays [1; 2; 2; 1]
 * 8
*)
let valid_subarrays (nums : int list) : int =","  0","let () =
  assert (valid_subarrays [10; 5; 10; 4; 15] = 7);
  assert (valid_subarrays [0; 1; 2; 3; 4; 5] = 21);
  assert (valid_subarrays [1; 2; 2; 1] = 8);
  assert (valid_subarrays [1] = 1);
  assert (valid_subarrays [2; 2; 2] = 6);
  assert (valid_subarrays [0; 0; 0; 0; 0] = 15);
  assert (valid_subarrays [1; 2; 3; 4; 5] = 15);
;;","hard","hard_022","hard"
"(**You are given a list of equivalent string pairs synonyms where synonyms[i] = [si, ti] indicates t...
 * >>> generate_sentences [[""cat""; ""feline""]; [""dog""; ""canine""]] ""cat and dog are friends""
 * ['cat and canine are friends'; 'cat and dog are friends'; 'feline and canine are friends'; 'feline and dog are friends']
 * >>> generate_sentences [[""big""; ""large""]; [""small""; ""tiny""]] ""the big red ball is not small""
 * ['the big red ball is not small'; 'the big red ball is not tiny'; 'the large red ball is not small'; 'the large red ball is not tiny']
 * >>> generate_sentences [] ""hello world""
 * ['hello world']
*)
let generate_sentences (synonyms : string list list) (text : string) : string list =","  []","let () =
  assert (generate_sentences [[""cat""; ""feline""]; [""dog""; ""canine""]] ""cat and dog are friends"" = ['cat and canine are friends'; 'cat and dog are friends'; 'feline and canine are friends'; 'feline and dog are friends']);
  assert (generate_sentences [[""big""; ""large""]; [""small""; ""tiny""]] ""the big red ball is not small"" = ['the big red ball is not small'; 'the big red ball is not tiny'; 'the large red ball is not small'; 'the large red ball is not tiny']);
  assert (generate_sentences [] ""hello world"" = ['hello world']);
  assert (generate_sentences [[""love""; ""adore""]; [""hate""; ""detest""]] ""I love to hate"" = ['I adore to detest'; 'I adore to hate'; 'I love to detest'; 'I love to hate']);
  assert (generate_sentences [[""cold""; ""chilly""]; [""hot""; ""warm""]] ""The cold weather turned hot quickly"" = ['The chilly weather turned hot quickly'; 'The chilly weather turned warm quickly'; 'The cold weather turned hot quickly'; 'The cold weather turned warm quickly']);
  assert (generate_sentences [[""fast""; ""quick""]] ""the fast brown fox jumps over the lazy dog"" = ['the fast brown fox jumps over the lazy dog'; 'the quick brown fox jumps over the lazy dog']);
  assert (generate_sentences [[""happy""; ""joy""]; [""cheerful""; ""glad""]] ""I am happy today but was sad yesterday"" = ['I am happy today but was sad yesterday'; 'I am joy today but was sad yesterday']);
;;","medium","medium_171","medium"
"(**You are given a 0-indexed string pattern of length n consisting of the characters 'I' meaning inc...
 * >>> smallest_number ""DDD""
 * 4321
 * >>> smallest_number ""IIIDIDDD""
 * 123549876
 * >>> smallest_number ""ID""
 * 132
*)
let smallest_number (pattern : string) : string =","  """"","let () =
  assert (smallest_number ""DDD"" = 4321);
  assert (smallest_number ""IIIDIDDD"" = 123549876);
  assert (smallest_number ""ID"" = 132);
  assert (smallest_number ""IIDDD"" = 126543);
  assert (smallest_number ""DDIII"" = 321456);
  assert (smallest_number ""IDID"" = 13254);
  assert (smallest_number ""IIII"" = 12345);
;;","medium","medium_102","medium"
"(**We call a string s of even length n an anti-palindrome if for each index 0 <= i < n, s[i] != s[n ...
 * >>> make_anti_palindrome ""aaabbbccc""
 * aaabccbbc
 * >>> make_anti_palindrome ""cccd""
 * -1
 * >>> make_anti_palindrome ""aabbaa""
 * -1
*)
let make_anti_palindrome (s : string) : string =","  """"","let () =
  assert (make_anti_palindrome ""aaabbbccc"" = aaabccbbc);
  assert (make_anti_palindrome ""cccd"" = -1);
  assert (make_anti_palindrome ""aabbaa"" = -1);
  assert (make_anti_palindrome ""abcdef"" = abcdef);
  assert (make_anti_palindrome ""abcdcba"" = aabccbd);
  assert (make_anti_palindrome ""abcdefgihj"" = abcdefghij);
  assert (make_anti_palindrome ""abcdefgihjklmnopqrstuvwxyz"" = abcdefghijklmnopqrstuvwxyz);
;;","hard","hard_014","hard"
"(**Given an array of positive integers nums, return the number of distinct prime factors in the prod...
 * >>> distinct_prime_factors [100; 200; 300; 400]
 * 3
 * >>> distinct_prime_factors [2; 2; 2; 2; 2; 2; 2; 2; 2; 2]
 * 1
 * >>> distinct_prime_factors [256; 512; 1024; 2048]
 * 1
*)
let distinct_prime_factors (nums : int list) : int =","  0","let () =
  assert (distinct_prime_factors [100; 200; 300; 400] = 3);
  assert (distinct_prime_factors [2; 2; 2; 2; 2; 2; 2; 2; 2; 2] = 1);
  assert (distinct_prime_factors [256; 512; 1024; 2048] = 1);
  assert (distinct_prime_factors [1000; 500; 250; 125] = 2);
  assert (distinct_prime_factors [2; 3; 5; 7; 11; 13] = 6);
  assert (distinct_prime_factors [60; 120; 180; 240; 300] = 3);
  assert (distinct_prime_factors [31; 37; 41; 43; 47; 53] = 6);
;;","medium","medium_092","medium"
"(**An ant is on a boundary. It sometimes goes left and sometimes right.
 * >>> return_to_boundary_count [-1; 1; -1; 1]
 * 2
 * >>> return_to_boundary_count [10]
 * 0
 * >>> return_to_boundary_count [1]
 * 0
*)
let return_to_boundary_count (nums : int list) : int =","  0","let () =
  assert (return_to_boundary_count [-1; 1; -1; 1] = 2);
  assert (return_to_boundary_count [10] = 0);
  assert (return_to_boundary_count [1] = 0);
  assert (return_to_boundary_count [-2; 2; -2; 2] = 2);
  assert (return_to_boundary_count [1; -1; 1; -1] = 2);
  assert (return_to_boundary_count [2; 3; -5] = 1);
  assert (return_to_boundary_count [5; 5; -10] = 1);
;;","easy","easy_148","easy"
"(**You are given two positive integers low and high.
 * >>> count_symmetric_integers 10 20
 * 1
 * >>> count_symmetric_integers 1 9999
 * 624
 * >>> count_symmetric_integers 500 1500
 * 20
*)
let count_symmetric_integers (low : int) (high : int) : int =","  0","let () =
  assert (count_symmetric_integers 10 20 = 1);
  assert (count_symmetric_integers 1 9999 = 624);
  assert (count_symmetric_integers 500 1500 = 20);
  assert (count_symmetric_integers 1000 1000 = 0);
  assert (count_symmetric_integers 500 550 = 0);
  assert (count_symmetric_integers 1 100 = 9);
  assert (count_symmetric_integers 1 10000 = 624);
;;","easy","easy_196","easy"
"(**The minimum absolute difference of an array a is defined as the minimum value of |a[i] - a[j]|, w...
 * >>> min_difference [10; 20; 30; 40; 50] [[0; 0]; [1; 1]; [2; 2]; [0; 4]]
 * [-1; -1; -1; 10]
 * >>> min_difference [1; 1; 1; 1; 1] [[0; 4]; [1; 3]]
 * [-1; -1]
 * >>> min_difference [5; 5; 5; 5] [[0; 3]; [1; 2]; [2; 3]; [0; 1]]
 * [-1; -1; -1; -1]
*)
let min_difference (nums : int list) (queries : int list list) : int list =","  []","let () =
  assert (min_difference [10; 20; 30; 40; 50] [[0; 0]; [1; 1]; [2; 2]; [0; 4]] = [-1; -1; -1; 10]);
  assert (min_difference [1; 1; 1; 1; 1] [[0; 4]; [1; 3]] = [-1; -1]);
  assert (min_difference [5; 5; 5; 5] [[0; 3]; [1; 2]; [2; 3]; [0; 1]] = [-1; -1; -1; -1]);
  assert (min_difference [100; 1; 2; 3; 4; 5; 6; 7; 8; 9] [[0; 9]; [1; 8]; [2; 7]; [3; 6]; [4; 5]] = [1; 1; 1; 1; 1]);
  assert (min_difference [5; 5; 5; 5] [[0; 3]; [1; 2]] = [-1; -1]);
  assert (min_difference [1; 2; 3; 4; 5] [[0; 4]; [1; 3]; [2; 2]] = [1; 1; -1]);
  assert (min_difference [4; 5; 2; 2; 7; 10] [[2; 3]; [0; 2]; [0; 5]; [3; 5]] = [-1; 1; 1; 3]);
;;","medium","medium_032","medium"
"(**There are n teams numbered from 0 to n - 1 in a tournament.
 * >>> find_champion [[0; 1; 1; 1]; [0; 0; 0; 0]; [0; 1; 0; 1]; [0; 1; 0; 0]]
 * 0
 * >>> find_champion [[0; 0; 0; 1]; [1; 0; 0; 1]; [1; 1; 0; 1]; [0; 0; 0; 0]]
 * 2
 * >>> find_champion [[0; 1; 0]; [0; 0; 1]; [1; 0; 0]]
 * None
*)
let find_champion (grid : int list list) : int =","  0","let () =
  assert (find_champion [[0; 1; 1; 1]; [0; 0; 0; 0]; [0; 1; 0; 1]; [0; 1; 0; 0]] = 0);
  assert (find_champion [[0; 0; 0; 1]; [1; 0; 0; 1]; [1; 1; 0; 1]; [0; 0; 0; 0]] = 2);
  assert (find_champion [[0; 1; 0]; [0; 0; 1]; [1; 0; 0]] = None);
  assert (find_champion [[0; 0; 1]; [1; 0; 1]; [0; 0; 0]] = 1);
  assert (find_champion [[0; 1; 1]; [0; 0; 0]; [0; 1; 0]] = 0);
  assert (find_champion [[0; 0; 0; 1]; [1; 0; 1; 1]; [1; 0; 0; 1]; [0; 0; 0; 0]] = 1);
  assert (find_champion [[0; 1; 1]; [0; 0; 1]; [0; 0; 0]] = 0);
;;","easy","easy_020","easy"
"(**A valid cut in a circle can be:
 * >>> number_of_cuts 3
 * 3
 * >>> number_of_cuts 100
 * 50
 * >>> number_of_cuts 4
 * 2
*)
let number_of_cuts (n : int) : int =","  0","let () =
  assert (number_of_cuts 3 = 3);
  assert (number_of_cuts 100 = 50);
  assert (number_of_cuts 4 = 2);
  assert (number_of_cuts 99 = 99);
  assert (number_of_cuts 17 = 17);
  assert (number_of_cuts 2 = 1);
  assert (number_of_cuts 1 = 0);
;;","easy","easy_187","easy"
"(**You are given an array prices where prices[i] is the price of a given stock on the ith day.
 * >>> max_profit [10; 9; 8; 2]
 * 0
 * >>> max_profit [1]
 * 0
 * >>> max_profit [2; 1; 2; 1; 0; 1; 2]
 * 2
*)
let max_profit (prices : int list) : int =","  0","let () =
  assert (max_profit [10; 9; 8; 2] = 0);
  assert (max_profit [1] = 0);
  assert (max_profit [2; 1; 2; 1; 0; 1; 2] = 2);
  assert (max_profit [2; 1] = 0);
  assert (max_profit [7; 6; 4; 3; 1] = 0);
  assert (max_profit [3; 3; 5; 0; 0; 3; 1; 4] = 4);
  assert (max_profit [7; 1; 5; 3; 6; 4] = 5);
;;","easy","easy_019","easy"
"(**Given a 0-indexed string word and a character ch, reverse the segment of word that starts at inde...
 * >>> reverse_prefix ""abcdef"" ""f""
 * fedcba
 * >>> reverse_prefix ""madam"" ""d""
 * damam
 * >>> reverse_prefix ""abcdefd"" ""d""
 * dcbaefd
*)
let reverse_prefix (word : string) (ch : string) : string =","  """"","let () =
  assert (reverse_prefix ""abcdef"" ""f"" = fedcba);
  assert (reverse_prefix ""madam"" ""d"" = damam);
  assert (reverse_prefix ""abcdefd"" ""d"" = dcbaefd);
  assert (reverse_prefix ""abcd"" ""z"" = abcd);
  assert (reverse_prefix ""a"" ""a"" = a);
  assert (reverse_prefix ""python"" ""y"" = ypthon);
  assert (reverse_prefix ""operation"" ""p"" = poeration);
;;","easy","easy_145","easy"
"(**Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the ...
 * >>> integer_break 11
 * 54
 * >>> integer_break 30
 * 59049
 * >>> integer_break 20
 * 1458
*)
let integer_break (n : int) : int =","  0","let () =
  assert (integer_break 11 = 54);
  assert (integer_break 30 = 59049);
  assert (integer_break 20 = 1458);
  assert (integer_break 2 = 1);
  assert (integer_break 10 = 36);
  assert (integer_break 58 = 1549681956);
  assert (integer_break 29 = 39366);
;;","medium","medium_103","medium"
"(**There are n people standing in a line labeled from 1 to n. The first person in the line is holdin...
 * >>> pass_the_pillow 2 5
 * 2
 * >>> pass_the_pillow 10 15
 * 4
 * >>> pass_the_pillow 500 750
 * 249
*)
let pass_the_pillow (n : int) (time : int) : int =","  0","let () =
  assert (pass_the_pillow 2 5 = 2);
  assert (pass_the_pillow 10 15 = 4);
  assert (pass_the_pillow 500 750 = 249);
  assert (pass_the_pillow 2 1 = 2);
  assert (pass_the_pillow 7 20 = 5);
  assert (pass_the_pillow 8 20 = 7);
  assert (pass_the_pillow 5 7 = 2);
;;","easy","easy_017","easy"
"(**You are given an integer array nums. In one operation, you can add or subtract 1 from any element...
 * >>> minimum_operations [1; 2; 4; 5]
 * 4
 * >>> minimum_operations [1; 1; 1; 1]
 * 4
 * >>> minimum_operations [3; 3; 3; 3]
 * 0
*)
let minimum_operations (nums : int list) : int =","  0","let () =
  assert (minimum_operations [1; 2; 4; 5] = 4);
  assert (minimum_operations [1; 1; 1; 1] = 4);
  assert (minimum_operations [3; 3; 3; 3] = 0);
  assert (minimum_operations [1; 2; 4; 5; 7] = 5);
  assert (minimum_operations [1; 2; 4; 5; 7; 8] = 6);
  assert (minimum_operations [11; 22; 33; 44] = 3);
  assert (minimum_operations [15; 18; 21; 24] = 0);
;;","easy","easy_030","easy"
"(**Given two integers tomatoSlices and cheeseSlices. The ingredients of different burgers are as fol...
 * >>> num_of_burgers 10000000 5000000
 * [0; 5000000]
 * >>> num_of_burgers 16 7
 * [1; 6]
 * >>> num_of_burgers 14 5
 * [2; 3]
*)
let num_of_burgers (tomatoSlices : int) (cheeseSlices : int) : int list =","  []","let () =
  assert (num_of_burgers 10000000 5000000 = [0; 5000000]);
  assert (num_of_burgers 16 7 = [1; 6]);
  assert (num_of_burgers 14 5 = [2; 3]);
  assert (num_of_burgers 8 2 = [2; 0]);
  assert (num_of_burgers 20 5 = [5; 0]);
  assert (num_of_burgers 0 0 = [0; 0]);
  assert (num_of_burgers 10 3 = [2; 1]);
;;","medium","medium_150","medium"
"(**You are given an m x n integer matrix matrix with the following two properties:
 * >>> search_matrix [[1; 3; 5; 7]; [10; 11; 16; 20]] 10
 * true
 * >>> search_matrix [[-10; -5; -3]; [0; 3; 10]; [15; 20; 25]] 3
 * true
 * >>> search_matrix [[-10; -5; -3; -1]; [0; 2; 3; 5]; [7; 8; 11; 13]; [15; 16; 18; 20]] 0
 * true
*)
let search_matrix (matrix : int list list) (target : int) : bool =","  false","let () =
  assert (search_matrix [[1; 3; 5; 7]; [10; 11; 16; 20]] 10 = true);
  assert (search_matrix [[-10; -5; -3]; [0; 3; 10]; [15; 20; 25]] 3 = true);
  assert (search_matrix [[-10; -5; -3; -1]; [0; 2; 3; 5]; [7; 8; 11; 13]; [15; 16; 18; 20]] 0 = true);
  assert (search_matrix [[1; 2; 3]; [4; 5; 6]; [7; 8; 9]] 5 = true);
  assert (search_matrix [[1]] 1 = true);
  assert (search_matrix [[-10; -8; -6; -4]; [-3; -1; 1; 3]; [5; 7; 9; 11]] 10 = false);
  assert (search_matrix [[1; 2; 3; 4; 5]; [6; 7; 8; 9; 10]] 0 = false);
;;","medium","medium_006","medium"
"(**Given an integer num, return a string of its base 7 representation.
 * >>> convert_to_base7 -1000000
 * -11333311
 * >>> convert_to_base7 49
 * 100
 * >>> convert_to_base7 165
 * 324
*)
let convert_to_base7 (num : int) : string =","  """"","let () =
  assert (convert_to_base7 -1000000 = -11333311);
  assert (convert_to_base7 49 = 100);
  assert (convert_to_base7 165 = 324);
  assert (convert_to_base7 -10000000 = -150666343);
  assert (convert_to_base7 0 = 0);
  assert (convert_to_base7 10000000 = 150666343);
  assert (convert_to_base7 16807 = 100000);
;;","easy","easy_191","easy"
"(**A pangram is a sentence where every letter of the English alphabet appears at least once.
 * >>> check_if_pangram ""aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz""
 * true
 * >>> check_if_pangram ""quickbrownfoxjumpsoverthelazydog""
 * true
 * >>> check_if_pangram ""aaaaabbbbbccccc""
 * false
*)
let check_if_pangram (sentence : string) : bool =","  false","let () =
  assert (check_if_pangram ""aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz"" = true);
  assert (check_if_pangram ""quickbrownfoxjumpsoverthelazydog"" = true);
  assert (check_if_pangram ""aaaaabbbbbccccc"" = false);
  assert (check_if_pangram ""a"" = false);
  assert (check_if_pangram ""thequickbrownfoxjumpsoverthelazydogandmorelettersjusttoextendthelengthofthesentenceevenmorejustformeasurements"" = true);
  assert (check_if_pangram ""hellothere"" = false);
  assert (check_if_pangram ""hello"" = false);
;;","easy","easy_192","easy"
"(**You are given an elevation map represents as an integer array heights where heights[i] representi...
 * >>> pour_water [1; 1; 1; 1; 1] 5 2
 * [2; 2; 2; 2; 2]
 * >>> pour_water [2; 1; 1; 2; 1; 2; 2] 4 3
 * [2; 2; 2; 3; 2; 2; 2]
 * >>> pour_water [1; 1; 1; 1; 1] 3 2
 * [2; 2; 2; 1; 1]
*)
let pour_water (heights : int list) (volume : int) (k : int) : int list =","  []","let () =
  assert (pour_water [1; 1; 1; 1; 1] 5 2 = [2; 2; 2; 2; 2]);
  assert (pour_water [2; 1; 1; 2; 1; 2; 2] 4 3 = [2; 2; 2; 3; 2; 2; 2]);
  assert (pour_water [1; 1; 1; 1; 1] 3 2 = [2; 2; 2; 1; 1]);
  assert (pour_water [1; 2; 3; 2; 1] 4 2 = [3; 3; 3; 2; 2]);
  assert (pour_water [0; 2; 1; 2; 0] 5 2 = [2; 2; 2; 2; 2]);
  assert (pour_water [5; 5; 5; 5; 5] 3 2 = [6; 6; 6; 5; 5]);
  assert (pour_water [0; 0; 0; 0; 0; 0; 0] 15 3 = [2; 2; 2; 3; 2; 2; 2]);
;;","medium","medium_070","medium"
"(**You are given an array prices where prices[i] is the price of a given stock on the ith day, and a...
 * >>> max_profit [10; 20; 30; 40; 50] 5
 * 35
 * >>> max_profit [1; 3; 2; 8; 4; 9] 2
 * 8
 * >>> max_profit [1; 2; 3; 4; 5] 1
 * 3
*)
let max_profit (prices : int list) (fee : int) : int =","  0","let () =
  assert (max_profit [10; 20; 30; 40; 50] 5 = 35);
  assert (max_profit [1; 3; 2; 8; 4; 9] 2 = 8);
  assert (max_profit [1; 2; 3; 4; 5] 1 = 3);
  assert (max_profit [50; 40; 30; 20; 10] 5 = 0);
  assert (max_profit [5; 4; 3; 2; 1] 1 = 0);
  assert (max_profit [1; 2; 3; 4; 5] 0 = 4);
  assert (max_profit [10; 22; 5; 75; 65; 80] 3 = 88);
;;","medium","medium_151","medium"
"(**You are playing a game involving a circular array of non-zero integers nums. Each nums[i] denotes...
 * >>> circular_array_loop [-5; 1; 1; 4; 2]
 * true
 * >>> circular_array_loop [-1; 2; -1; 2; -1]
 * false
 * >>> circular_array_loop [-1; -2; -3; -4; -5; 6]
 * false
*)
let circular_array_loop (nums : int list) : bool =","  false","let () =
  assert (circular_array_loop [-5; 1; 1; 4; 2] = true);
  assert (circular_array_loop [-1; 2; -1; 2; -1] = false);
  assert (circular_array_loop [-1; -2; -3; -4; -5; 6] = false);
  assert (circular_array_loop [-2; -3; -4; -5; -6] = false);
  assert (circular_array_loop [1; 2; -1; -2; 3] = false);
  assert (circular_array_loop [5; 1; 1; 2; 2] = false);
  assert (circular_array_loop [1] = false);
;;","medium","medium_167","medium"
"(**You are given a 0-indexed string s consisting of only lowercase English letters, and an integer c...
 * >>> equal_count_substrings ""a"" 5
 * 0
 * >>> equal_count_substrings ""abcdefg"" 3
 * 0
 * >>> equal_count_substrings ""abcabcabc"" 3
 * 1
*)
let equal_count_substrings (s : string) (count : int) : int =","  0","let () =
  assert (equal_count_substrings ""a"" 5 = 0);
  assert (equal_count_substrings ""abcdefg"" 3 = 0);
  assert (equal_count_substrings ""abcabcabc"" 3 = 1);
  assert (equal_count_substrings ""abccbaabc"" 3 = 1);
  assert (equal_count_substrings ""aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz"" 2 = 351);
  assert (equal_count_substrings ""abcabcabc"" 1 = 24);
  assert (equal_count_substrings """" 1 = 0);
;;","medium","medium_192","medium"
"(**Given a non-empty array of integers nums, every element appears twice except for one. Find that s...
 * >>> single_number [-1; 2; -1; -2; 2]
 * -2
 * >>> single_number [1]
 * 1
 * >>> single_number [10; 1; 10; 2; 2]
 * 1
*)
let single_number (nums : int list) : int =","  0","let () =
  assert (single_number [-1; 2; -1; -2; 2] = -2);
  assert (single_number [1] = 1);
  assert (single_number [10; 1; 10; 2; 2] = 1);
  assert (single_number [3; 3; 7; 7; 10] = 10);
  assert (single_number [10; 10; 20; 20; 30] = 30);
  assert (single_number [3; 3; 5; 7; 5; 7; 9] = 9);
  assert (single_number [-1; -1; -2] = -2);
;;","easy","easy_162","easy"
"(**You are given two strings s1 and s2, both of length 4, consisting of lowercase English letters.
 * >>> can_be_equal ""abcd"" ""cdab""
 * true
 * >>> can_be_equal ""acbd"" ""bdac""
 * true
 * >>> can_be_equal ""abab"" ""abcd""
 * false
*)
let can_be_equal (s1 : string) (s2 : string) : bool =","  false","let () =
  assert (can_be_equal ""abcd"" ""cdab"" = true);
  assert (can_be_equal ""acbd"" ""bdac"" = true);
  assert (can_be_equal ""abab"" ""abcd"" = false);
  assert (can_be_equal ""abdc"" ""cdab"" = false);
  assert (can_be_equal ""abcd"" ""dacb"" = false);
  assert (can_be_equal ""abab"" ""baba"" = false);
  assert (can_be_equal ""abcd"" ""abcd"" = true);
;;","easy","easy_154","easy"
"(**A k x k magic square is a k x k grid filled with integers such that every row sum, every column s...
 * >>> largest_magic_square [[10; 20]; [15; 25]]
 * 1
 * >>> largest_magic_square [[7; 1; 4; 5; 6]; [2; 5; 1; 6; 4]; [1; 5; 4; 3; 2]; [1; 2; 7; 3; 4]]
 * 3
 * >>> largest_magic_square [[6; 3; 2; 8; 1; 9; 3; 2]; [4; 7; 5; 4; 5; 3; 4; 7]; [8; 4; 6; 8; 7; 2; 8; 1]; [2; 9; 1; 5; 8; 7; 7; 3]; [5; 4; 3; 1; 9; 4; 6; 3]; [2; 8; 4; 9; 7; 8; 4; 1]; [7; 8; 4; 5; 3; 9; 6; 4]; [6; 3; 5; 9; 8; 7; 1; 9]]
 * 1
*)
let largest_magic_square (grid : int list list) : int =","  0","let () =
  assert (largest_magic_square [[10; 20]; [15; 25]] = 1);
  assert (largest_magic_square [[7; 1; 4; 5; 6]; [2; 5; 1; 6; 4]; [1; 5; 4; 3; 2]; [1; 2; 7; 3; 4]] = 3);
  assert (largest_magic_square [[6; 3; 2; 8; 1; 9; 3; 2]; [4; 7; 5; 4; 5; 3; 4; 7]; [8; 4; 6; 8; 7; 2; 8; 1]; [2; 9; 1; 5; 8; 7; 7; 3]; [5; 4; 3; 1; 9; 4; 6; 3]; [2; 8; 4; 9; 7; 8; 4; 1]; [7; 8; 4; 5; 3; 9; 6; 4]; [6; 3; 5; 9; 8; 7; 1; 9]] = 1);
  assert (largest_magic_square [[8]] = 1);
  assert (largest_magic_square [[16; 23; 17]; [78; 32; 21]; [17; 26; 79]] = 1);
  assert (largest_magic_square [[5; 1; 3; 1]; [9; 3; 3; 1]; [1; 3; 3; 8]] = 2);
  assert (largest_magic_square [[4; 3; 8; 4]; [9; 5; 1; 9]; [2; 7; 6; 2]] = 3);
;;","medium","medium_110","medium"
"(**A series of highways connect n cities numbered from 0 to n - 1. You are given a 2D integer array ...
 * >>> maximum_cost 6 [[0; 1; 10]; [1; 2; 20]; [2; 3; 30]; [3; 4; 40]; [4; 5; 50]; [5; 0; 60]] 5
 * 200
 * >>> maximum_cost 3 [[0; 1; 2]; [1; 2; 3]] 2
 * 5
 * >>> maximum_cost 4 [[0; 1; 3]; [2; 3; 2]] 2
 * -1
*)
let maximum_cost (n : int) (highways : int list list) (k : int) : int =","  0","let () =
  assert (maximum_cost 6 [[0; 1; 10]; [1; 2; 20]; [2; 3; 30]; [3; 4; 40]; [4; 5; 50]; [5; 0; 60]] 5 = 200);
  assert (maximum_cost 3 [[0; 1; 2]; [1; 2; 3]] 2 = 5);
  assert (maximum_cost 4 [[0; 1; 3]; [2; 3; 2]] 2 = -1);
  assert (maximum_cost 4 [[0; 1; 1]; [1; 2; 1]; [2; 3; 1]; [3; 0; 1]] 3 = 3);
  assert (maximum_cost 6 [[0; 1; 10]; [1; 2; 5]; [2; 3; 8]; [3; 4; 6]; [4; 5; 7]; [5; 0; 9]] 4 = 32);
  assert (maximum_cost 3 [[0; 1; 5]; [1; 2; 4]; [0; 2; 3]] 2 = 9);
  assert (maximum_cost 5 [[0; 1; 4]; [2; 1; 3]; [1; 4; 11]; [3; 2; 3]; [3; 4; 2]] 3 = 17);
;;","hard","hard_048","hard"
"(**There are n cars at given miles away from the starting mile 0, traveling to reach the mile target.
 * >>> car_fleet 1000 [100; 200; 300] [100; 50; 25]
 * 1
 * >>> car_fleet 100 [0; 1; 2; 3; 4] [100; 100; 100; 100; 100]
 * 5
 * >>> car_fleet 300 [0; 50; 100; 150; 200; 250] [50; 40; 30; 20; 10; 5]
 * 1
*)
let car_fleet (target : int) (position : int list) (speed : int list) : int =","  0","let () =
  assert (car_fleet 1000 [100; 200; 300] [100; 50; 25] = 1);
  assert (car_fleet 100 [0; 1; 2; 3; 4] [100; 100; 100; 100; 100] = 5);
  assert (car_fleet 300 [0; 50; 100; 150; 200; 250] [50; 40; 30; 20; 10; 5] = 1);
  assert (car_fleet 100 [90; 80; 70; 60; 50] [10; 20; 30; 40; 50] = 1);
  assert (car_fleet 50 [0; 10; 20; 30; 40] [10; 9; 8; 7; 6] = 5);
  assert (car_fleet 50 [10; 20; 30] [1; 2; 3] = 3);
  assert (car_fleet 12 [10; 8; 0; 5; 3] [2; 4; 1; 1; 3] = 3);
;;","medium","medium_052","medium"
"(**Given an integer n, return true if n has exactly three positive divisors. Otherwise, return false.
 * >>> is_three 625
 * false
 * >>> is_three 3
 * false
 * >>> is_three 576
 * false
*)
let is_three (n : int) : bool =","  false","let () =
  assert (is_three 625 = false);
  assert (is_three 3 = false);
  assert (is_three 576 = false);
  assert (is_three 729 = false);
  assert (is_three 144 = false);
  assert (is_three 49 = true);
  assert (is_three 900 = false);
;;","easy","easy_075","easy"
"(**You are given a positive integer n representing n cities numbered from 1 to n. You are also given...
 * >>> min_score 5 [[1; 2; 10]; [2; 3; 15]; [3; 4; 20]; [4; 5; 25]; [1; 5; 30]]
 * 10
 * >>> min_score 6 [[1; 2; 1]; [2; 3; 2]; [3; 4; 3]; [4; 5; 4]; [5; 6; 5]]
 * 1
 * >>> min_score 4 [[1; 2; 2]; [1; 3; 4]; [3; 4; 7]]
 * 2
*)
let min_score (n : int) (roads : int list list) : int =","  0","let () =
  assert (min_score 5 [[1; 2; 10]; [2; 3; 15]; [3; 4; 20]; [4; 5; 25]; [1; 5; 30]] = 10);
  assert (min_score 6 [[1; 2; 1]; [2; 3; 2]; [3; 4; 3]; [4; 5; 4]; [5; 6; 5]] = 1);
  assert (min_score 4 [[1; 2; 2]; [1; 3; 4]; [3; 4; 7]] = 2);
  assert (min_score 5 [[1; 2; 10]; [2; 3; 5]; [3; 4; 2]; [4; 5; 1]] = 1);
  assert (min_score 3 [[1; 2; 5]; [2; 3; 10]; [1; 3; 7]] = 5);
  assert (min_score 6 [[1; 2; 3]; [2; 3; 4]; [3; 4; 5]; [4; 5; 6]; [5; 6; 7]; [1; 6; 1]] = 1);
  assert (min_score 3 [[1; 2; 1]; [2; 3; 2]; [1; 3; 3]] = 1);
;;","medium","medium_053","medium"
"(**You are given an integer array nums. The value of this array is defined as the sum of |nums[i] - ...
 * >>> max_value_after_reverse [1; 3; 2; 4; 5]
 * 9
 * >>> max_value_after_reverse [100; 90; 80; 70; 60; 50; 40; 30; 20; 10]
 * 230
 * >>> max_value_after_reverse [1; -1; 2; -2; 3; -3]
 * 22
*)
let max_value_after_reverse (nums : int list) : int =","  0","let () =
  assert (max_value_after_reverse [1; 3; 2; 4; 5] = 9);
  assert (max_value_after_reverse [100; 90; 80; 70; 60; 50; 40; 30; 20; 10] = 230);
  assert (max_value_after_reverse [1; -1; 2; -2; 3; -3] = 22);
  assert (max_value_after_reverse [1; -1; 1; -1; 1] = 8);
  assert (max_value_after_reverse [1; -1; 1; -1; 1; -1] = 10);
  assert (max_value_after_reverse [100000; -100000; 100000; -100000; 100000] = 800000);
  assert (max_value_after_reverse [-10; -5; 0; 5; 10] = 40);
;;","hard","hard_032","hard"
"(**Given the root of a binary tree, return the postorder traversal of its nodes' values.
 * >>> postorder_traversal [2; null; 1]
 * [1; 2]
 * >>> postorder_traversal [1; 2; 3; 4; 5; null; 8; null; null; 6; 7; 9]
 * [4; 6; 7; 5; 2; 9; 8; 3; 1]
 * >>> postorder_traversal [1; 2]
 * [2; 1]
*)
let postorder_traversal (root : 'a option) : int list =","  []","let () =
  assert (postorder_traversal [2; null; 1] = [1; 2]);
  assert (postorder_traversal [1; 2; 3; 4; 5; null; 8; null; null; 6; 7; 9] = [4; 6; 7; 5; 2; 9; 8; 3; 1]);
  assert (postorder_traversal [1; 2] = [2; 1]);
  assert (postorder_traversal [1; null; 2; 3] = [3; 2; 1]);
  assert (postorder_traversal [3; 1; 2] = [1; 2; 3]);
  assert (postorder_traversal [1] = [1]);
  assert (postorder_traversal [] = []);
;;","easy","easy_012","easy"
"(**There exists an infinitely large two-dimensional grid of uncolored unit cells. You are given a po...
 * >>> colored_cells 3
 * 13
 * >>> colored_cells 100000
 * 19999800001
 * >>> colored_cells 100
 * 19801
*)
let colored_cells (n : int) : int =","  0","let () =
  assert (colored_cells 3 = 13);
  assert (colored_cells 100000 = 19999800001);
  assert (colored_cells 100 = 19801);
  assert (colored_cells 10000 = 199980001);
  assert (colored_cells 2 = 5);
  assert (colored_cells 1 = 1);
  assert (colored_cells 1000 = 1998001);
;;","medium","medium_083","medium"
"(**You are given a 0-indexed array of positive integers tasks, representing tasks that need to be co...
 * >>> task_scheduler_ii [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 10
 * 10
 * >>> task_scheduler_ii [10; 9; 8; 7; 6; 5; 4; 3; 2; 1] 1
 * 10
 * >>> task_scheduler_ii [1; 2; 3; 4; 5] 5
 * 5
*)
let task_scheduler_ii (tasks : int list) (space : int) : int =","  0","let () =
  assert (task_scheduler_ii [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 10 = 10);
  assert (task_scheduler_ii [10; 9; 8; 7; 6; 5; 4; 3; 2; 1] 1 = 10);
  assert (task_scheduler_ii [1; 2; 3; 4; 5] 5 = 5);
  assert (task_scheduler_ii [1; 1; 1; 1; 1] 1 = 9);
  assert (task_scheduler_ii [1; 1; 1; 1] 2 = 10);
  assert (task_scheduler_ii [1; 1; 1; 1; 1] 5 = 25);
  assert (task_scheduler_ii [10; 9; 8; 7; 6; 5; 4; 3; 2; 1] 5 = 10);
;;","medium","medium_178","medium"
"(**Given an integer n, add a dot (""."") as the thousands separator and return it in string format.
 * >>> thousand_separator 0
 * 0
 * >>> thousand_separator 1234
 * 1.234
 * >>> thousand_separator 1000000
 * 1.000.000
*)
let thousand_separator (n : int) : string =","  """"","let () =
  assert (thousand_separator 0 = 0);
  assert (thousand_separator 1234 = 1.234);
  assert (thousand_separator 1000000 = 1.000.000);
  assert (thousand_separator 2147483647 = 2.147.483.647);
  assert (thousand_separator 123456789 = 123.456.789);
  assert (thousand_separator 1234567 = 1.234.567);
  assert (thousand_separator 123456 = 123.456);
;;","easy","easy_137","easy"
"(**You are given an array of events where events[i] = [startDayi, endDayi]. Every event i starts at ...
 * >>> max_events [[1; 100]; [1; 100]; [1; 100]; [1; 100]; [1; 100]]
 * 5
 * >>> max_events [[1; 3]; [2; 4]; [3; 5]; [4; 6]]
 * 4
 * >>> max_events [[10; 15]; [20; 25]; [30; 35]; [40; 45]; [50; 55]]
 * 5
*)
let max_events (events : int list list) : int =","  0","let () =
  assert (max_events [[1; 100]; [1; 100]; [1; 100]; [1; 100]; [1; 100]] = 5);
  assert (max_events [[1; 3]; [2; 4]; [3; 5]; [4; 6]] = 4);
  assert (max_events [[10; 15]; [20; 25]; [30; 35]; [40; 45]; [50; 55]] = 5);
  assert (max_events [[5; 5]; [1; 5]; [1; 5]; [1; 5]] = 4);
  assert (max_events [[1; 3]; [3; 5]; [5; 7]; [7; 9]; [9; 11]; [11; 13]; [13; 15]] = 7);
  assert (max_events [[1; 10]; [2; 9]; [3; 8]; [4; 7]; [5; 6]] = 5);
  assert (max_events [[1; 2]; [2; 2]; [3; 3]; [4; 4]; [5; 5]] = 5);
;;","medium","medium_161","medium"
"(**Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the tw...
 * >>> find_median_sorted_arrays [100; 200; 300] [150; 250; 350]
 * 225.0
 * >>> find_median_sorted_arrays [2] []
 * 2.0
 * >>> find_median_sorted_arrays [1; 3] [2]
 * 2.0
*)
let find_median_sorted_arrays (nums1 : int list) (nums2 : int list) : float =","  0.0","let () =
  assert (find_median_sorted_arrays [100; 200; 300] [150; 250; 350] = 225.0);
  assert (find_median_sorted_arrays [2] [] = 2.0);
  assert (find_median_sorted_arrays [1; 3] [2] = 2.0);
  assert (find_median_sorted_arrays [1] [2; 3; 4; 5; 6; 7; 8; 9; 10] = 5.5);
  assert (find_median_sorted_arrays [1000000] [-1000000] = 0.0);
  assert (find_median_sorted_arrays [1; 2; 3; 4; 5; 6; 7; 8; 9] [10; 11; 12; 13; 14; 15; 16; 17; 18; 19] = 10.0);
  assert (find_median_sorted_arrays [1; 3; 5; 7] [2; 4; 6; 8] = 4.5);
;;","hard","hard_092","hard"
"(**Given the root of a binary search tree and an integer k, return true if there exist two elements ...
 * >>> find_target [5; 3; 6; 2; 4; null; 7] 28
 * false
 * >>> find_target [5; 3; 6; 2; 4; null; 7] 9
 * true
 * >>> find_target [100; 50; 150; 25; 75; 125; 175; 10; 30; 60; 90; 110; 140; 160; 180] 150
 * true
*)
let find_target (root : 'a option) (k : int) : bool =","  false","let () =
  assert (find_target [5; 3; 6; 2; 4; null; 7] 28 = false);
  assert (find_target [5; 3; 6; 2; 4; null; 7] 9 = true);
  assert (find_target [100; 50; 150; 25; 75; 125; 175; 10; 30; 60; 90; 110; 140; 160; 180] 150 = true);
  assert (find_target [2; 0; 3; -4; 1] 5 = true);
  assert (find_target [100; 50; 150; 25; 75; 125; 175; 10; 30; 60; 90; 110; 140; 160; 190] 500 = false);
  assert (find_target [2; 1; 3] 4 = true);
  assert (find_target [8; 5; 10; 3; 7; 9; 12] 14 = true);
;;","easy","easy_046","easy"
"(**Given an integer n, return a string with n characters such that each character in such string occ...
 * >>> generate_the_string 250
 * aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab
 * >>> generate_the_string 3
 * aaa
 * >>> generate_the_string 100
 * aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab
*)
let generate_the_string (n : int) : string =","  """"","let () =
  assert (generate_the_string 250 = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab);
  assert (generate_the_string 3 = aaa);
  assert (generate_the_string 100 = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab);
  assert (generate_the_string 4 = aaab);
  assert (generate_the_string 2 = ab);
  assert (generate_the_string 1 = a);
  assert (generate_the_string 500 = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab);
;;","easy","easy_093","easy"
"(**Given an integer n, return all the strobogrammatic numbers that are of length n. You may return t...
 * >>> find_strobogrammatic 3
 * ['101'; '808'; '609'; '906'; '111'; '818'; '619'; '916'; '181'; '888'; '689'; '986']
 * >>> find_strobogrammatic 4
 * ['1111'; '8118'; '6119'; '9116'; '1881'; '8888'; '6889'; '9886'; '1691'; '8698'; '6699'; '9696'; '1961'; '8968'; '6969'; '9966'; '1001'; '8008'; '6009'; '9006']
 * >>> find_strobogrammatic 6
 * ['111111'; '811118'; '611119'; '911116'; '181181'; '881188'; '681189'; '981186'; '161191'; '861198'; '661199'; '961196'; '191161'; '891168'; '691169'; '991166'; '101101'; '801108'; '601109'; '901106'; '118811'; '818818'; '618819'; '918816'; '188881'; '888888'; '688889'; '988886'; '168891'; '868898'; '668899'; '968896'; '198861'; '898868'; '698869'; '998866'; '108801'; '808808'; '608809'; '908806'; '116911'; '816918'; '616919'; '916916'; '186981'; '886988'; '686989'; '986986'; '166991'; '866998'; '666999'; '966996'; '196961'; '896968'; '696969'; '996966'; '106901'; '806908'; '606909'; '906906'; '119611'; '819618'; '619619'; '919616'; '189681'; '889688'; '689689'; '989686'; '169691'; '869698'; '669699'; '969696'; '199661'; '899668'; '699669'; '999666'; '109601'; '809608'; '609609'; '909606'; '110011'; '810018'; '610019'; '910016'; '180081'; '880088'; '680089'; '980086'; '160091'; '860098'; '660099'; '960096'; '190061'; '890068'; '690069'; '990066'; '100001'; '800008'; '600009'; '900006']
*)
let find_strobogrammatic (n : int) : string list =","  []","let () =
  assert (find_strobogrammatic 3 = ['101'; '808'; '609'; '906'; '111'; '818'; '619'; '916'; '181'; '888'; '689'; '986']);
  assert (find_strobogrammatic 4 = ['1111'; '8118'; '6119'; '9116'; '1881'; '8888'; '6889'; '9886'; '1691'; '8698'; '6699'; '9696'; '1961'; '8968'; '6969'; '9966'; '1001'; '8008'; '6009'; '9006']);
  assert (find_strobogrammatic 6 = ['111111'; '811118'; '611119'; '911116'; '181181'; '881188'; '681189'; '981186'; '161191'; '861198'; '661199'; '961196'; '191161'; '891168'; '691169'; '991166'; '101101'; '801108'; '601109'; '901106'; '118811'; '818818'; '618819'; '918816'; '188881'; '888888'; '688889'; '988886'; '168891'; '868898'; '668899'; '968896'; '198861'; '898868'; '698869'; '998866'; '108801'; '808808'; '608809'; '908806'; '116911'; '816918'; '616919'; '916916'; '186981'; '886988'; '686989'; '986986'; '166991'; '866998'; '666999'; '966996'; '196961'; '896968'; '696969'; '996966'; '106901'; '806908'; '606909'; '906906'; '119611'; '819618'; '619619'; '919616'; '189681'; '889688'; '689689'; '989686'; '169691'; '869698'; '669699'; '969696'; '199661'; '899668'; '699669'; '999666'; '109601'; '809608'; '609609'; '909606'; '110011'; '810018'; '610019'; '910016'; '180081'; '880088'; '680089'; '980086'; '160091'; '860098'; '660099'; '960096'; '190061'; '890068'; '690069'; '990066'; '100001'; '800008'; '600009'; '900006']);
  assert (find_strobogrammatic 2 = ['11'; '88'; '69'; '96']);
  assert (find_strobogrammatic 1 = ['0'; '1'; '8']);
  assert (find_strobogrammatic 5 = ['11011'; '81018'; '61019'; '91016'; '18081'; '88088'; '68089'; '98086'; '16091'; '86098'; '66099'; '96096'; '19061'; '89068'; '69069'; '99066'; '10001'; '80008'; '60009'; '90006'; '11111'; '81118'; '61119'; '91116'; '18181'; '88188'; '68189'; '98186'; '16191'; '86198'; '66199'; '96196'; '19161'; '89168'; '69169'; '99166'; '10101'; '80108'; '60109'; '90106'; '11811'; '81818'; '61819'; '91816'; '18881'; '88888'; '68889'; '98886'; '16891'; '86898'; '66899'; '96896'; '19861'; '89868'; '69869'; '99866'; '10801'; '80808'; '60809'; '90806']);
  assert (find_strobogrammatic 8 = ['11111111'; '81111118'; '61111119'; '91111116'; '18111181'; '88111188'; '68111189'; '98111186'; '16111191'; '86111198'; '66111199'; '96111196'; '19111161'; '89111168'; '69111169'; '99111166'; '10111101'; '80111108'; '60111109'; '90111106'; '11811811'; '81811818'; '61811819'; '91811816'; '18811881'; '88811888'; '68811889'; '98811886'; '16811891'; '86811898'; '66811899'; '96811896'; '19811861'; '89811868'; '69811869'; '99811866'; '10811801'; '80811808'; '60811809'; '90811806'; '11611911'; '81611918'; '61611919'; '91611916'; '18611981'; '88611988'; '68611989'; '98611986'; '16611991'; '86611998'; '66611999'; '96611996'; '19611961'; '89611968'; '69611969'; '99611966'; '10611901'; '80611908'; '60611909'; '90611906'; '11911611'; '81911618'; '61911619'; '91911616'; '18911681'; '88911688'; '68911689'; '98911686'; '16911691'; '86911698'; '66911699'; '96911696'; '19911661'; '89911668'; '69911669'; '99911666'; '10911601'; '80911608'; '60911609'; '90911606'; '11011011'; '81011018'; '61011019'; '91011016'; '18011081'; '88011088'; '68011089'; '98011086'; '16011091'; '86011098'; '66011099'; '96011096'; '19011061'; '89011068'; '69011069'; '99011066'; '10011001'; '80011008'; '60011009'; '90011006'; '11188111'; '81188118'; '61188119'; '91188116'; '18188181'; '88188188'; '68188189'; '98188186'; '16188191'; '86188198'; '66188199'; '96188196'; '19188161'; '89188168'; '69188169'; '99188166'; '10188101'; '80188108'; '60188109'; '90188106'; '11888811'; '81888818'; '61888819'; '91888816'; '18888881'; '88888888'; '68888889'; '98888886'; '16888891'; '86888898'; '66888899'; '96888896'; '19888861'; '89888868'; '69888869'; '99888866'; '10888801'; '80888808'; '60888809'; '90888806'; '11688911'; '81688918'; '61688919'; '91688916'; '18688981'; '88688988'; '68688989'; '98688986'; '16688991'; '86688998'; '66688999'; '96688996'; '19688961'; '89688968'; '69688969'; '99688966'; '10688901'; '80688908'; '60688909'; '90688906'; '11988611'; '81988618'; '61988619'; '91988616'; '18988681'; '88988688'; '68988689'; '98988686'; '16988691'; '86988698'; '66988699'; '96988696'; '19988661'; '89988668'; '69988669'; '99988666'; '10988601'; '80988608'; '60988609'; '90988606'; '11088011'; '81088018'; '61088019'; '91088016'; '18088081'; '88088088'; '68088089'; '98088086'; '16088091'; '86088098'; '66088099'; '96088096'; '19088061'; '89088068'; '69088069'; '99088066'; '10088001'; '80088008'; '60088009'; '90088006'; '11169111'; '81169118'; '61169119'; '91169116'; '18169181'; '88169188'; '68169189'; '98169186'; '16169191'; '86169198'; '66169199'; '96169196'; '19169161'; '89169168'; '69169169'; '99169166'; '10169101'; '80169108'; '60169109'; '90169106'; '11869811'; '81869818'; '61869819'; '91869816'; '18869881'; '88869888'; '68869889'; '98869886'; '16869891'; '86869898'; '66869899'; '96869896'; '19869861'; '89869868'; '69869869'; '99869866'; '10869801'; '80869808'; '60869809'; '90869806'; '11669911'; '81669918'; '61669919'; '91669916'; '18669981'; '88669988'; '68669989'; '98669986'; '16669991'; '86669998'; '66669999'; '96669996'; '19669961'; '89669968'; '69669969'; '99669966'; '10669901'; '80669908'; '60669909'; '90669906'; '11969611'; '81969618'; '61969619'; '91969616'; '18969681'; '88969688'; '68969689'; '98969686'; '16969691'; '86969698'; '66969699'; '96969696'; '19969661'; '89969668'; '69969669'; '99969666'; '10969601'; '80969608'; '60969609'; '90969606'; '11069011'; '81069018'; '61069019'; '91069016'; '18069081'; '88069088'; '68069089'; '98069086'; '16069091'; '86069098'; '66069099'; '96069096'; '19069061'; '89069068'; '69069069'; '99069066'; '10069001'; '80069008'; '60069009'; '90069006'; '11196111'; '81196118'; '61196119'; '91196116'; '18196181'; '88196188'; '68196189'; '98196186'; '16196191'; '86196198'; '66196199'; '96196196'; '19196161'; '89196168'; '69196169'; '99196166'; '10196101'; '80196108'; '60196109'; '90196106'; '11896811'; '81896818'; '61896819'; '91896816'; '18896881'; '88896888'; '68896889'; '98896886'; '16896891'; '86896898'; '66896899'; '96896896'; '19896861'; '89896868'; '69896869'; '99896866'; '10896801'; '80896808'; '60896809'; '90896806'; '11696911'; '81696918'; '61696919'; '91696916'; '18696981'; '88696988'; '68696989'; '98696986'; '16696991'; '86696998'; '66696999'; '96696996'; '19696961'; '89696968'; '69696969'; '99696966'; '10696901'; '80696908'; '60696909'; '90696906'; '11996611'; '81996618'; '61996619'; '91996616'; '18996681'; '88996688'; '68996689'; '98996686'; '16996691'; '86996698'; '66996699'; '96996696'; '19996661'; '89996668'; '69996669'; '99996666'; '10996601'; '80996608'; '60996609'; '90996606'; '11096011'; '81096018'; '61096019'; '91096016'; '18096081'; '88096088'; '68096089'; '98096086'; '16096091'; '86096098'; '66096099'; '96096096'; '19096061'; '89096068'; '69096069'; '99096066'; '10096001'; '80096008'; '60096009'; '90096006'; '11100111'; '81100118'; '61100119'; '91100116'; '18100181'; '88100188'; '68100189'; '98100186'; '16100191'; '86100198'; '66100199'; '96100196'; '19100161'; '89100168'; '69100169'; '99100166'; '10100101'; '80100108'; '60100109'; '90100106'; '11800811'; '81800818'; '61800819'; '91800816'; '18800881'; '88800888'; '68800889'; '98800886'; '16800891'; '86800898'; '66800899'; '96800896'; '19800861'; '89800868'; '69800869'; '99800866'; '10800801'; '80800808'; '60800809'; '90800806'; '11600911'; '81600918'; '61600919'; '91600916'; '18600981'; '88600988'; '68600989'; '98600986'; '16600991'; '86600998'; '66600999'; '96600996'; '19600961'; '89600968'; '69600969'; '99600966'; '10600901'; '80600908'; '60600909'; '90600906'; '11900611'; '81900618'; '61900619'; '91900616'; '18900681'; '88900688'; '68900689'; '98900686'; '16900691'; '86900698'; '66900699'; '96900696'; '19900661'; '89900668'; '69900669'; '99900666'; '10900601'; '80900608'; '60900609'; '90900606'; '11000011'; '81000018'; '61000019'; '91000016'; '18000081'; '88000088'; '68000089'; '98000086'; '16000091'; '86000098'; '66000099'; '96000096'; '19000061'; '89000068'; '69000069'; '99000066'; '10000001'; '80000008'; '60000009'; '90000006']);
;;","medium","medium_090","medium"
"(**Given a positive integer num represented as a string, return the integer num without trailing zer...
 * >>> remove_trailing_zeros ""10""
 * 1
 * >>> remove_trailing_zeros ""100100""
 * 1001
 * >>> remove_trailing_zeros ""1111111111""
 * 1111111111
*)
let remove_trailing_zeros (num : string) : string =","  """"","let () =
  assert (remove_trailing_zeros ""10"" = 1);
  assert (remove_trailing_zeros ""100100"" = 1001);
  assert (remove_trailing_zeros ""1111111111"" = 1111111111);
  assert (remove_trailing_zeros ""1000"" = 1);
  assert (remove_trailing_zeros ""1"" = 1);
  assert (remove_trailing_zeros ""9876543210"" = 987654321);
  assert (remove_trailing_zeros ""10500"" = 105);
;;","easy","easy_198","easy"
"(**Given a 2D grid of size m x n and an integer k. You need to shift the grid k times.
 * >>> shift_grid [[3; 8; 1; 9]; [19; 7; 2; 5]; [4; 6; 11; 10]; [12; 0; 21; 13]] 4
 * [[12; 0; 21; 13]; [3; 8; 1; 9]; [19; 7; 2; 5]; [4; 6; 11; 10]]
 * >>> shift_grid [[-1; -2; -3]; [-4; -5; -6]; [-7; -8; -9]] 2
 * [[-8; -9; -1]; [-2; -3; -4]; [-5; -6; -7]]
 * >>> shift_grid [[1000; -1000]; [1000; -1000]] 1
 * [[-1000; 1000]; [-1000; 1000]]
*)
let shift_grid (grid : int list list) (k : int) : int list list =","  [[]]","let () =
  assert (shift_grid [[3; 8; 1; 9]; [19; 7; 2; 5]; [4; 6; 11; 10]; [12; 0; 21; 13]] 4 = [[12; 0; 21; 13]; [3; 8; 1; 9]; [19; 7; 2; 5]; [4; 6; 11; 10]]);
  assert (shift_grid [[-1; -2; -3]; [-4; -5; -6]; [-7; -8; -9]] 2 = [[-8; -9; -1]; [-2; -3; -4]; [-5; -6; -7]]);
  assert (shift_grid [[1000; -1000]; [1000; -1000]] 1 = [[-1000; 1000]; [-1000; 1000]]);
  assert (shift_grid [[1]] 0 = [[1]]);
  assert (shift_grid [[1]] 100 = [[1]]);
  assert (shift_grid [[1; 2; 3]; [4; 5; 6]; [7; 8; 9]] 9 = [[1; 2; 3]; [4; 5; 6]; [7; 8; 9]]);
  assert (shift_grid [[1; 2]; [3; 4]] 50 = [[3; 4]; [1; 2]]);
;;","easy","easy_169","easy"
"(**You are given two string arrays words1 and words2.
 * >>> word_subsets [""acaac""; ""cccbb""; ""aacbb""; ""caacc""; ""bcbbb""] [""c""; ""cc""; ""b""]
 * ['cccbb']
 * >>> word_subsets [""amazon""; ""apple""; ""facebook""; ""google""; ""leetcode""] [""e""; ""o""]
 * ['facebook'; 'google'; 'leetcode']
 * >>> word_subsets [""amazon""; ""apple""; ""facebook""; ""google""; ""leetcode""] [""lc""; ""eo""]
 * ['leetcode']
*)
let word_subsets (words1 : string list) (words2 : string list) : string list =","  []","let () =
  assert (word_subsets [""acaac""; ""cccbb""; ""aacbb""; ""caacc""; ""bcbbb""] [""c""; ""cc""; ""b""] = ['cccbb']);
  assert (word_subsets [""amazon""; ""apple""; ""facebook""; ""google""; ""leetcode""] [""e""; ""o""] = ['facebook'; 'google'; 'leetcode']);
  assert (word_subsets [""amazon""; ""apple""; ""facebook""; ""google""; ""leetcode""] [""lc""; ""eo""] = ['leetcode']);
  assert (word_subsets [""abcdefg""; ""bcdefga""; ""cdefgab""; ""defgabc""; ""efgabcd""; ""fgabcde""; ""gabcdef""] [""def""; ""efg""; ""fgh""; ""ghi""; ""hij""; ""ijk""; ""jkl""] = []);
  assert (word_subsets [""abcd""; ""abcde""; ""abcdef""; ""abcdefg""; ""abcdefgh""; ""abcdefghi""; ""abcdefghij""] [""a""; ""aa""; ""aaa""; ""aaaa""; ""aaaaa""; ""aaaaaa""; ""aaaaaaa""; ""aaaaaaaa""; ""aaaaaaaaa""] = []);
  assert (word_subsets [""hello""; ""world""; ""python""; ""programming""] [""hello""; ""world""; ""helo""; ""rowdl""] = []);
  assert (word_subsets [""aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz""; ""zzzyyxxwwvvuuttssrrqqppoonnmmllkkjjiihhggffeeddccbbaa""] [""abc""; ""def""; ""ghi""; ""jkl""; ""mno""; ""pqr""; ""stu""; ""vwx""; ""yz""; ""zyx""; ""wvu""; ""tsr""; ""qpo""; ""nml""; ""kji""; ""hgf""; ""edc""; ""baa""; ""ccc""; ""bb""; ""aa""] = []);
;;","medium","medium_126","medium"
"(**Given a 2D integer array matrix, return the transpose of matrix.
 * >>> transpose [[1]]
 * [(1; )]
 * >>> transpose [[1; 2]; [3; 4]; [5; 6]]
 * [(1; 3; 5); (2; 4; 6)]
 * >>> transpose [[1; 2; 3]; [4; 5; 6]; [7; 8; 9]]
 * [(1; 4; 7); (2; 5; 8); (3; 6; 9)]
*)
let transpose (matrix : int list list) : int list list =","  [[]]","let () =
  assert (transpose [[1]] = [(1; )]);
  assert (transpose [[1; 2]; [3; 4]; [5; 6]] = [(1; 3; 5); (2; 4; 6)]);
  assert (transpose [[1; 2; 3]; [4; 5; 6]; [7; 8; 9]] = [(1; 4; 7); (2; 5; 8); (3; 6; 9)]);
  assert (transpose [[1; 2; 3]; [4; 5; 6]] = [(1; 4); (2; 5); (3; 6)]);
  assert (transpose [[-1000; 1000]; [2000; -2000]] = [(-1000; 2000); (1000; -2000)]);
  assert (transpose [[1]; [2]; [3]; [4]; [5]; [6]; [7]; [8]; [9]; [10]] = [(1; 2; 3; 4; 5; 6; 7; 8; 9; 10)]);
  assert (transpose [[1; 2; 3; 4; 5]; [6; 7; 8; 9; 10]; [11; 12; 13; 14; 15]; [16; 17; 18; 19; 20]; [21; 22; 23; 24; 25]] = [(1; 6; 11; 16; 21); (2; 7; 12; 17; 22); (3; 8; 13; 18; 23); (4; 9; 14; 19; 24); (5; 10; 15; 20; 25)]);
;;","easy","easy_073","easy"
"(**On an infinite plane, a robot initially stands at (0, 0) and faces north. Note that:
 * >>> is_robot_bounded ""GGLGRGLL""
 * true
 * >>> is_robot_bounded ""LLLL""
 * true
 * >>> is_robot_bounded ""GLLRLLRL""
 * true
*)
let is_robot_bounded (instructions : string) : bool =","  false","let () =
  assert (is_robot_bounded ""GGLGRGLL"" = true);
  assert (is_robot_bounded ""LLLL"" = true);
  assert (is_robot_bounded ""GLLRLLRL"" = true);
  assert (is_robot_bounded ""GRGL"" = false);
  assert (is_robot_bounded ""LLGRL"" = true);
  assert (is_robot_bounded ""LRRL"" = true);
  assert (is_robot_bounded ""LLGRR"" = false);
;;","medium","medium_021","medium"
"(**You are given an array of distinct integers arr and an array of integer arrays pieces, where the ...
 * >>> can_form_array [10; 20; 30; 40; 50] [[10; 20]; [30; 40; 50]]
 * true
 * >>> can_form_array [1; 2; 3; 4; 5] [[2; 3]; [1; 4]; [5]]
 * false
 * >>> can_form_array [91; 4; 64; 78] [[78]; [4; 64]; [91]]
 * true
*)
let can_form_array (arr : int list) (pieces : int list list) : bool =","  false","let () =
  assert (can_form_array [10; 20; 30; 40; 50] [[10; 20]; [30; 40; 50]] = true);
  assert (can_form_array [1; 2; 3; 4; 5] [[2; 3]; [1; 4]; [5]] = false);
  assert (can_form_array [91; 4; 64; 78] [[78]; [4; 64]; [91]] = true);
  assert (can_form_array [49; 18; 16] [[16; 18; 49]] = false);
  assert (can_form_array [15; 88] [[88]; [15]] = true);
  assert (can_form_array [1; 2; 3; 4; 5] [[2]; [4; 5]; [3]; [1]] = true);
  assert (can_form_array [5; 9; 13; 17; 21; 25] [[5; 9; 13]; [17; 21; 25]] = true);
;;","easy","easy_135","easy"
"(**Given two strings s and goal, return true if you can swap two letters in s so the result is equal...
 * >>> buddy_strings ""abcd"" ""dcba""
 * false
 * >>> buddy_strings ""xyy"" ""xyx""
 * false
 * >>> buddy_strings ""abac"" ""abad""
 * false
*)
let buddy_strings (s : string) (goal : string) : bool =","  false","let () =
  assert (buddy_strings ""abcd"" ""dcba"" = false);
  assert (buddy_strings ""xyy"" ""xyx"" = false);
  assert (buddy_strings ""abac"" ""abad"" = false);
  assert (buddy_strings ""aa"" ""aa"" = true);
  assert (buddy_strings ""abcde"" ""edcba"" = false);
  assert (buddy_strings ""aaaa"" ""aaaa"" = true);
  assert (buddy_strings ""abab"" ""abab"" = true);
;;","easy","easy_151","easy"
"(**You are given two strings of the same length s1 and s2 and a string baseStr.
 * >>> smallest_equivalent_string ""abc"" ""bcd"" ""xyz""
 * xyz
 * >>> smallest_equivalent_string ""leetcode"" ""programs"" ""sourcecode""
 * aauaaaaada
 * >>> smallest_equivalent_string ""parker"" ""morris"" ""parser""
 * makkek
*)
let smallest_equivalent_string (s1 : string) (s2 : string) (baseStr : string) : string =","  """"","let () =
  assert (smallest_equivalent_string ""abc"" ""bcd"" ""xyz"" = xyz);
  assert (smallest_equivalent_string ""leetcode"" ""programs"" ""sourcecode"" = aauaaaaada);
  assert (smallest_equivalent_string ""parker"" ""morris"" ""parser"" = makkek);
  assert (smallest_equivalent_string ""abc"" ""bcd"" ""zab"" = zaa);
  assert (smallest_equivalent_string ""abc"" ""bcd"" ""ace"" = aae);
  assert (smallest_equivalent_string ""a"" ""b"" ""z"" = z);
  assert (smallest_equivalent_string ""aaa"" ""bbb"" ""ccc"" = ccc);
;;","medium","medium_148","medium"
"(**Write a function to find the longest common prefix string amongst an array of strings.
 * >>> longest_common_prefix [""hello""; ""helium""; ""helper""]
 * hel
 * >>> longest_common_prefix [""a""]
 * a
 * >>> longest_common_prefix [""""; """"; """"; """"]
 * 
*)
let longest_common_prefix (strs : string list) : string =","  """"","let () =
  assert (longest_common_prefix [""hello""; ""helium""; ""helper""] = hel);
  assert (longest_common_prefix [""a""] = a);
  assert (longest_common_prefix [""apple""; ""app""; ""apricot""] = ap);
  assert (longest_common_prefix [""abcd""; ""abce""; ""abcf""] = abc);
  assert (longest_common_prefix [""apple""; ""app""; ""application""] = app);
  assert (longest_common_prefix [""interview""; ""interrupt""; ""inter""] = inter);
;;","easy","easy_124","easy"
"(**There is a country of n cities numbered from 0 to n - 1. In this country, there is a road connect...
 * >>> longest_common_subpath 1 [[0]; [0]; [0]]
 * 1
 * >>> longest_common_subpath 5 [[0; 1; 2; 3; 4]; [4; 3; 2; 1; 0]]
 * 1
 * >>> longest_common_subpath 3 [[0]; [1]; [2]]
 * 0
*)
let longest_common_subpath (n : int) (paths : int list list) : int =","  0","let () =
  assert (longest_common_subpath 1 [[0]; [0]; [0]] = 1);
  assert (longest_common_subpath 5 [[0; 1; 2; 3; 4]; [4; 3; 2; 1; 0]] = 1);
  assert (longest_common_subpath 3 [[0]; [1]; [2]] = 0);
  assert (longest_common_subpath 10 [[0; 1; 2]; [1; 2; 3]; [2; 3; 4]] = 1);
  assert (longest_common_subpath 10 [[0; 1; 2; 3; 4; 5; 6; 7; 8; 9]; [5; 6; 7; 8; 9; 0; 1; 2; 3; 4]; [3; 4; 5; 6; 7; 8; 9; 0; 1; 2]] = 5);
  assert (longest_common_subpath 7 [[0; 1; 2]; [1; 2; 3]; [2; 3; 4]; [3; 4; 5]; [4; 5; 6]] = 0);
  assert (longest_common_subpath 6 [[0; 1; 2; 3; 4; 5]; [1; 2; 3; 4; 5; 0]; [2; 3; 4; 5; 0; 1]] = 4);
;;","hard","hard_023","hard"
"(**There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1 (in...
*)
let valid_path (n : int) (edges : int list list) (source : int) (destination : int) : bool =","  false","let () =
  assert (valid_path 1 [] 0 0 = true);
  assert (valid_path 100 [] 0 99 = false);
  assert (valid_path 25 [[0; 1]; [1; 2]; [2; 3]; [3; 4]; [4; 5]; [5; 6]; [6; 7]; [7; 8]; [8; 9]; [9; 10]; [10; 11]; [11; 12]; [12; 13]; [13; 14]; [14; 15]; [15; 16]; [16; 17]; [17; 18]; [18; 19]; [19; 20]; [20; 21]; [21; 22]; [22; 23]; [23; 24]; [24; 0]] 15 10 = true);
  assert (valid_path 15 [[0; 1]; [1; 2]; [2; 3]; [3; 4]; [4; 5]; [5; 6]; [6; 7]; [7; 8]; [8; 9]; [9; 10]; [10; 11]; [11; 12]; [12; 13]; [13; 14]] 14 0 = true);
;;","easy","easy_174","easy"
"(**You are given an integer array prices, which shows the chocolate prices and a 2D integer array qu...
 * >>> minimum_relative_losses [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] [[5; 5]; [10; 10]; [3; 3]; [7; 7]]
 * [6; 55; -9; 24]
 * >>> minimum_relative_losses [10; 20; 30; 40; 50] [[15; 2]; [25; 3]; [35; 4]; [45; 5]]
 * [-30; 20; 80; 140]
 * >>> minimum_relative_losses [100; 200; 300; 400; 500] [[150; 2]; [450; 4]; [500; 5]; [200; 3]]
 * [-300; 1000; 1500; 0]
*)
let minimum_relative_losses (prices : int list) (queries : int list list) : int list =","  []","let () =
  assert (minimum_relative_losses [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] [[5; 5]; [10; 10]; [3; 3]; [7; 7]] = [6; 55; -9; 24]);
  assert (minimum_relative_losses [10; 20; 30; 40; 50] [[15; 2]; [25; 3]; [35; 4]; [45; 5]] = [-30; 20; 80; 140]);
  assert (minimum_relative_losses [100; 200; 300; 400; 500] [[150; 2]; [450; 4]; [500; 5]; [200; 3]] = [-300; 1000; 1500; 0]);
  assert (minimum_relative_losses [1; 9; 22; 10; 19] [[18; 4]; [5; 2]] = [34; -21]);
  assert (minimum_relative_losses [10; 20; 30; 40; 50] [[15; 3]; [25; 2]; [35; 1]] = [-30; 10; 10]);
  assert (minimum_relative_losses [5; 6; 7] [[10; 1]; [5; 3]; [3; 3]] = [5; 12; 0]);
  assert (minimum_relative_losses [10; 20; 30; 40; 50] [[25; 3]; [35; 2]; [15; 4]] = [20; 30; -20]);
;;","hard","hard_079","hard"
"(**Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the m...
 * >>> find_mode [5; 3; 7; 2; 4; 6; 8; 1; null; null; null; null; null; null; 9]
 * [1; 2; 3; 4; 5; 6; 7; 8; 9]
 * >>> find_mode [5; 2; 5; null; null; 5; 5; 5]
 * [5]
 * >>> find_mode [1; null; 2; null; 3; null; 4; null; 5]
 * [1; 2; 3; 4; 5]
*)
let find_mode (root : 'a option) : int list =","  []","let () =
  assert (find_mode [5; 3; 7; 2; 4; 6; 8; 1; null; null; null; null; null; null; 9] = [1; 2; 3; 4; 5; 6; 7; 8; 9]);
  assert (find_mode [5; 2; 5; null; null; 5; 5; 5] = [5]);
  assert (find_mode [1; null; 2; null; 3; null; 4; null; 5] = [1; 2; 3; 4; 5]);
  assert (find_mode [3; 1; 4; 1; 3; null; 5] = [1; 3]);
  assert (find_mode [2; 1; 2] = [2]);
  assert (find_mode [1; null; 2; null; 3; null; 4] = [1; 2; 3; 4]);
  assert (find_mode [2; 2; 2] = [2]);
;;","easy","easy_138","easy"
"(**Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of...
 * >>> bst_to_gst [1; null; 2; null; 3; null; 4; null; 5]
 * [15; None; 14; None; 12; None; 9; None; 5]
 * >>> bst_to_gst [5; 2; 13]
 * [18; 20; 13]
 * >>> bst_to_gst [10; 5; 15; 3; 7; null; 18]
 * [43; 55; 33; 58; 50; None; 18]
*)
let bst_to_gst (root : 'a option) : 'a option =","  None","let () =
  assert (bst_to_gst [1; null; 2; null; 3; null; 4; null; 5] = [15; None; 14; None; 12; None; 9; None; 5]);
  assert (bst_to_gst [5; 2; 13] = [18; 20; 13]);
  assert (bst_to_gst [10; 5; 15; 3; 7; null; 18] = [43; 55; 33; 58; 50; None; 18]);
  assert (bst_to_gst [3; 2; 4; 1] = [7; 9; 4; 10]);
  assert (bst_to_gst [4; 1; 6; 0; 2; 5; 7; null; null; null; 3; null; null; null; 8] = [30; 36; 21; 36; 35; 26; 15; None; None; None; 33; None; None; None; 8]);
  assert (bst_to_gst [1; 0; 2] = [3; 3; 2]);
  assert (bst_to_gst [0; null; 1] = [1; None; 1]);
;;","medium","medium_069","medium"
"(**Given an integer array hours representing times in hours, return an integer denoting the number o...
 * >>> count_complete_day_pairs [23; 22; 21; 20; 19; 18; 17; 16; 15; 14; 13; 12; 11; 10; 9; 8; 7; 6; 5; 4; 3; 2; 1]
 * 11
 * >>> count_complete_day_pairs [24; 48; 72; 96; 120]
 * 10
 * >>> count_complete_day_pairs [1000000000; 1000000000; 1000000000; 1000000000]
 * 0
*)
let count_complete_day_pairs (hours : int list) : int =","  0","let () =
  assert (count_complete_day_pairs [23; 22; 21; 20; 19; 18; 17; 16; 15; 14; 13; 12; 11; 10; 9; 8; 7; 6; 5; 4; 3; 2; 1] = 11);
  assert (count_complete_day_pairs [24; 48; 72; 96; 120] = 10);
  assert (count_complete_day_pairs [1000000000; 1000000000; 1000000000; 1000000000] = 0);
  assert (count_complete_day_pairs [10; 14; 10; 14; 48] = 4);
  assert (count_complete_day_pairs [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23] = 11);
  assert (count_complete_day_pairs [24; 48; 72; 96] = 6);
  assert (count_complete_day_pairs [1; 2; 3; 4; 5] = 0);
;;","easy","easy_081","easy"
"(**Given a string path, where path[i] = 'N', 'S', 'E' or 'W', each representing moving one unit nort...
 * >>> is_path_crossing ""NEESWNWWSNNWNSSSWEWEWEWE""
 * true
 * >>> is_path_crossing ""NNNSSSSSSEEEEEEEWWWWWWWWW""
 * true
 * >>> is_path_crossing ""NEWSNEWS""
 * true
*)
let is_path_crossing (path : string) : bool =","  false","let () =
  assert (is_path_crossing ""NEESWNWWSNNWNSSSWEWEWEWE"" = true);
  assert (is_path_crossing ""NNNSSSSSSEEEEEEEWWWWWWWWW"" = true);
  assert (is_path_crossing ""NEWSNEWS"" = true);
  assert (is_path_crossing ""EWEWEWEW"" = true);
  assert (is_path_crossing ""NESWW"" = true);
  assert (is_path_crossing ""NSSS"" = true);
  assert (is_path_crossing ""N"" = false);
;;","easy","easy_050","easy"
"(**Given an array nums, return true if the array was originally sorted in non-decreasing order, then...
 * >>> check [4; 5; 6; 7; 0; 1; 2]
 * true
 * >>> check [2; 1; 3; 4]
 * false
 * >>> check [1; 3; 2]
 * false
*)
let check (nums : int list) : bool =","  false","let () =
  assert (check [4; 5; 6; 7; 0; 1; 2] = true);
  assert (check [2; 1; 3; 4] = false);
  assert (check [1; 3; 2] = false);
  assert (check [4; 5; 6; 1; 2; 3] = true);
  assert (check [1; 3; 5; 7; 2; 4; 6; 8] = false);
  assert (check [2; 2; 1; 1; 1] = true);
  assert (check [10; 1; 2; 3; 4; 5; 6; 7; 8; 9] = true);
;;","easy","easy_031","easy"
"(**You are given the head of a linked list of even length containing integers.
 * >>> game_result [4; 5; 2; 1]
 * Tie
 * >>> game_result [2; 5; 4; 7; 20; 5]
 * Odd
 * >>> game_result [12; 11; 14; 13; 16; 15]
 * Even
*)
let game_result (head : 'a option) : string =","  """"","let () =
  assert (game_result [4; 5; 2; 1] = Tie);
  assert (game_result [2; 5; 4; 7; 20; 5] = Odd);
  assert (game_result [12; 11; 14; 13; 16; 15] = Even);
  assert (game_result [100; 99; 98; 97; 96; 95] = Even);
  assert (game_result [2; 3; 4; 5; 6; 7; 8; 9] = Odd);
  assert (game_result [2; 1] = Even);
  assert (game_result [6; 1; 6; 1; 6; 1] = Even);
;;","easy","easy_060","easy"
"(**Given an integer array nums and an integer k, return the number of subarrays of nums where the le...
 * >>> subarray_lcm [7; 7; 7; 7; 7] 7
 * 15
 * >>> subarray_lcm [5; 5; 5; 5; 5] 5
 * 15
 * >>> subarray_lcm [7; 3; 9; 12; 15] 60
 * 1
*)
let subarray_lcm (nums : int list) (k : int) : int =","  0","let () =
  assert (subarray_lcm [7; 7; 7; 7; 7] 7 = 15);
  assert (subarray_lcm [5; 5; 5; 5; 5] 5 = 15);
  assert (subarray_lcm [7; 3; 9; 12; 15] 60 = 1);
  assert (subarray_lcm [3; 6; 2; 7; 1] 6 = 4);
  assert (subarray_lcm [100; 100; 100] 100 = 6);
  assert (subarray_lcm [7; 7; 7; 7] 7 = 10);
  assert (subarray_lcm [10; 5; 6; 20; 12] 60 = 7);
;;","medium","medium_099","medium"
"(**You are given a string s and an integer k. You can choose any character of the string and change ...
 * >>> character_replacement ""ABABABAB"" 3
 * 7
 * >>> character_replacement ""AAAAAAAAAAAAABBBAABBCCDDEE"" 5
 * 20
 * >>> character_replacement ""AABBCCDD"" 2
 * 4
*)
let character_replacement (s : string) (k : int) : int =","  0","let () =
  assert (character_replacement ""ABABABAB"" 3 = 7);
  assert (character_replacement ""AAAAAAAAAAAAABBBAABBCCDDEE"" 5 = 20);
  assert (character_replacement ""AABBCCDD"" 2 = 4);
  assert (character_replacement """" 0 = 0);
  assert (character_replacement ""A"" 1 = 1);
  assert (character_replacement ""AABAABBBCCCC"" 3 = 7);
  assert (character_replacement ""ABBBB"" 0 = 4);
;;","medium","medium_046","medium"
"(**You have n gardens, labeled from 1 to n, and an array paths where paths[i] = [xi, yi] describes a...
 * >>> garden_no_adj 3 [[1; 2]; [2; 3]; [3; 1]]
 * [1; 2; 3]
 * >>> garden_no_adj 6 [[1; 2]; [1; 3]; [1; 4]; [2; 5]; [2; 6]; [3; 5]; [3; 6]; [4; 5]; [4; 6]]
 * [1; 2; 2; 2; 1; 1]
 * >>> garden_no_adj 6 [[1; 2]; [2; 3]; [3; 4]; [4; 5]; [5; 6]; [6; 1]]
 * [1; 2; 1; 2; 1; 2]
*)
let garden_no_adj (n : int) (paths : int list list) : int list =","  []","let () =
  assert (garden_no_adj 3 [[1; 2]; [2; 3]; [3; 1]] = [1; 2; 3]);
  assert (garden_no_adj 6 [[1; 2]; [1; 3]; [1; 4]; [2; 5]; [2; 6]; [3; 5]; [3; 6]; [4; 5]; [4; 6]] = [1; 2; 2; 2; 1; 1]);
  assert (garden_no_adj 6 [[1; 2]; [2; 3]; [3; 4]; [4; 5]; [5; 6]; [6; 1]] = [1; 2; 1; 2; 1; 2]);
  assert (garden_no_adj 5 [[1; 2]; [2; 3]; [3; 4]; [4; 5]; [5; 1]] = [1; 2; 1; 2; 3]);
  assert (garden_no_adj 7 [[1; 2]; [2; 3]; [3; 4]; [4; 5]; [5; 6]; [6; 7]; [7; 1]] = [1; 2; 1; 2; 1; 2; 3]);
  assert (garden_no_adj 4 [[1; 2]; [3; 4]] = [1; 2; 1; 2]);
  assert (garden_no_adj 8 [[1; 2]; [1; 3]; [1; 4]; [2; 5]; [2; 6]; [3; 7]; [3; 8]; [4; 7]; [4; 8]] = [1; 2; 2; 2; 1; 1; 1; 1]);
;;","medium","medium_129","medium"
"(**You are given a 0-indexed integer array nums having length n, an integer indexDifference, and an ...
 * >>> find_indices [1; 3; 5; 7; 9] 2 6
 * [0; 3]
 * >>> find_indices [0; 0; 0; 0; 0] 0 0
 * [0; 0]
 * >>> find_indices [10; 20; 30; 40; 50] 1 25
 * [0; 3]
*)
let find_indices (nums : int list) (indexDifference : int) (valueDifference : int) : int list =","  []","let () =
  assert (find_indices [1; 3; 5; 7; 9] 2 6 = [0; 3]);
  assert (find_indices [0; 0; 0; 0; 0] 0 0 = [0; 0]);
  assert (find_indices [10; 20; 30; 40; 50] 1 25 = [0; 3]);
  assert (find_indices [0; 0; 0; 0] 3 1 = [-1; -1]);
  assert (find_indices [0; 0; 0; 0] 1 1 = [-1; -1]);
  assert (find_indices [10; 5; 15; 20; 25] 2 10 = [1; 3]);
  assert (find_indices [4; 2; 3; 1; 5] 1 2 = [0; 1]);
;;","easy","easy_117","easy"
"(**You are given two positive integer arrays nums and numsDivide. You can delete any number of eleme...
 * >>> min_operations [1; 2; 3; 4; 5] [10; 20; 30; 40; 50]
 * 0
 * >>> min_operations [5; 10; 15; 20] [5; 15; 25; 35]
 * 0
 * >>> min_operations [1; 3; 5; 7] [2; 4; 6; 8]
 * 0
*)
let min_operations (nums : int list) (numsDivide : int list) : int =","  0","let () =
  assert (min_operations [1; 2; 3; 4; 5] [10; 20; 30; 40; 50] = 0);
  assert (min_operations [5; 10; 15; 20] [5; 15; 25; 35] = 0);
  assert (min_operations [1; 3; 5; 7] [2; 4; 6; 8] = 0);
  assert (min_operations [10; 20; 30] [5; 10; 15] = -1);
  assert (min_operations [5; 5; 5; 5] [5; 5; 5; 5] = 0);
  assert (min_operations [3; 5; 7; 9] [15; 30; 45; 60] = 0);
  assert (min_operations [2; 4; 6; 8] [2; 4; 6; 8] = 0);
;;","hard","hard_087","hard"
"(**You are given a 0-indexed 2D integer array peaks where peaks[i] = [xi, yi] states that mountain i...
 * >>> visible_mountains [[5; 5]; [5; 5]; [5; 5]]
 * 0
 * >>> visible_mountains [[100; 100]; [200; 50]; [300; 100]]
 * 3
 * >>> visible_mountains [[1; 2]; [2; 3]; [3; 4]; [4; 5]]
 * 1
*)
let visible_mountains (peaks : int list list) : int =","  0","let () =
  assert (visible_mountains [[5; 5]; [5; 5]; [5; 5]] = 0);
  assert (visible_mountains [[100; 100]; [200; 50]; [300; 100]] = 3);
  assert (visible_mountains [[1; 2]; [2; 3]; [3; 4]; [4; 5]] = 1);
  assert (visible_mountains [[10; 10]; [15; 5]; [20; 15]] = 2);
  assert (visible_mountains [[10; 10]; [15; 5]; [20; 10]] = 2);
  assert (visible_mountains [[5; 5]; [5; 6]; [5; 7]] = 1);
  assert (visible_mountains [[2; 2]; [6; 3]; [5; 4]] = 2);
;;","medium","medium_098","medium"
"(**You are given a rows x cols matrix grid representing a field of cherries where grid[i][j] represe...
 * >>> cherry_pickup [[1; 2; 3]; [0; 1; 0]; [3; 0; 1]; [1; 2; 3]]
 * 14
 * >>> cherry_pickup [[5; 0; 0; 5]; [0; 4; 4; 0]; [0; 4; 4; 0]; [5; 0; 0; 5]]
 * 36
 * >>> cherry_pickup [[1; 1; 1; 1; 1]; [1; 0; 0; 0; 1]; [1; 0; 1; 0; 1]; [1; 0; 0; 0; 1]; [1; 1; 1; 1; 1]]
 * 10
*)
let cherry_pickup (grid : int list list) : int =","  0","let () =
  assert (cherry_pickup [[1; 2; 3]; [0; 1; 0]; [3; 0; 1]; [1; 2; 3]] = 14);
  assert (cherry_pickup [[5; 0; 0; 5]; [0; 4; 4; 0]; [0; 4; 4; 0]; [5; 0; 0; 5]] = 36);
  assert (cherry_pickup [[1; 1; 1; 1; 1]; [1; 0; 0; 0; 1]; [1; 0; 1; 0; 1]; [1; 0; 0; 0; 1]; [1; 1; 1; 1; 1]] = 10);
  assert (cherry_pickup [[1; 1; 1; 1; 1]; [1; 0; 1; 0; 1]; [1; 1; 1; 1; 1]] = 6);
  assert (cherry_pickup [[1; 2; 3; 4; 5]; [5; 4; 3; 2; 1]; [1; 3; 5; 3; 1]; [2; 1; 4; 3; 2]; [3; 2; 1; 4; 3]] = 35);
  assert (cherry_pickup [[0; 1; 0; 0; 0; 0; 0; 1]; [0; 1; 0; 0; 0; 0; 1; 0]; [0; 0; 0; 0; 0; 1; 0; 0]; [0; 1; 0; 0; 1; 0; 0; 0]; [0; 0; 0; 1; 0; 0; 0; 0]] = 7);
  assert (cherry_pickup [[2; 2; 2; 2; 2]; [2; 2; 2; 2; 2]; [2; 2; 2; 2; 2]; [2; 2; 2; 2; 2]] = 16);
;;","hard","hard_025","hard"
"(**Given two integers n and k, construct a list answer that contains n different positive integers r...
 * >>> construct_array 3 1
 * [1; 2; 3]
 * >>> construct_array 7 4
 * [1; 7; 2; 6; 5; 4; 3]
 * >>> construct_array 10 5
 * [1; 10; 2; 9; 3; 4; 5; 6; 7; 8]
*)
let construct_array (n : int) (k : int) : int list =","  []","let () =
  assert (construct_array 3 1 = [1; 2; 3]);
  assert (construct_array 7 4 = [1; 7; 2; 6; 5; 4; 3]);
  assert (construct_array 10 5 = [1; 10; 2; 9; 3; 4; 5; 6; 7; 8]);
  assert (construct_array 5 2 = [1; 5; 4; 3; 2]);
  assert (construct_array 3 2 = [1; 3; 2]);
  assert (construct_array 100 50 = [1; 100; 2; 99; 3; 98; 4; 97; 5; 96; 6; 95; 7; 94; 8; 93; 9; 92; 10; 91; 11; 90; 12; 89; 13; 88; 14; 87; 15; 86; 16; 85; 17; 84; 18; 83; 19; 82; 20; 81; 21; 80; 22; 79; 23; 78; 24; 77; 25; 76; 75; 74; 73; 72; 71; 70; 69; 68; 67; 66; 65; 64; 63; 62; 61; 60; 59; 58; 57; 56; 55; 54; 53; 52; 51; 50; 49; 48; 47; 46; 45; 44; 43; 42; 41; 40; 39; 38; 37; 36; 35; 34; 33; 32; 31; 30; 29; 28; 27; 26]);
  assert (construct_array 100 99 = [1; 100; 2; 99; 3; 98; 4; 97; 5; 96; 6; 95; 7; 94; 8; 93; 9; 92; 10; 91; 11; 90; 12; 89; 13; 88; 14; 87; 15; 86; 16; 85; 17; 84; 18; 83; 19; 82; 20; 81; 21; 80; 22; 79; 23; 78; 24; 77; 25; 76; 26; 75; 27; 74; 28; 73; 29; 72; 30; 71; 31; 70; 32; 69; 33; 68; 34; 67; 35; 66; 36; 65; 37; 64; 38; 63; 39; 62; 40; 61; 41; 60; 42; 59; 43; 58; 44; 57; 45; 56; 46; 55; 47; 54; 48; 53; 49; 52; 50; 51]);
;;","medium","medium_197","medium"
"(**You are given an integer array nums, which contains distinct elements and an integer k.
 * >>> count_the_num_of_kfree_subsets [2; 3; 5; 8] 5
 * 12
 * >>> count_the_num_of_kfree_subsets [100; 200; 300] 50
 * 8
 * >>> count_the_num_of_kfree_subsets [5; 4; 6] 1
 * 5
*)
let count_the_num_of_kfree_subsets (nums : int list) (k : int) : int =","  0","let () =
  assert (count_the_num_of_kfree_subsets [2; 3; 5; 8] 5 = 12);
  assert (count_the_num_of_kfree_subsets [100; 200; 300] 50 = 8);
  assert (count_the_num_of_kfree_subsets [5; 4; 6] 1 = 5);
  assert (count_the_num_of_kfree_subsets [7; 14; 21; 28] 7 = 8);
  assert (count_the_num_of_kfree_subsets [3; 7; 11; 15] 4 = 8);
  assert (count_the_num_of_kfree_subsets [20; 40; 60; 80; 100] 20 = 13);
  assert (count_the_num_of_kfree_subsets [50; 100; 150; 200; 250; 300] 50 = 21);
;;","medium","medium_122","medium"
"(**You are given an integer array gifts denoting the number of gifts in various piles. Every second,...
 * >>> pick_gifts [25; 64; 9; 4; 100] 4
 * 29
 * >>> pick_gifts [16; 81; 49] 3
 * 20
 * >>> pick_gifts [1; 1; 1; 1] 4
 * 4
*)
let pick_gifts (gifts : int list) (k : int) : int =","  0","let () =
  assert (pick_gifts [25; 64; 9; 4; 100] 4 = 29);
  assert (pick_gifts [16; 81; 49] 3 = 20);
  assert (pick_gifts [1; 1; 1; 1] 4 = 4);
  assert (pick_gifts [49; 36; 25; 16; 9] 5 = 25);
  assert (pick_gifts [1000000000] 1000 = 1);
  assert (pick_gifts [16; 81; 4; 25; 9] 3 = 31);
  assert (pick_gifts [36; 27; 18; 12; 9] 5 = 21);
;;","easy","easy_089","easy"
"(**Given an array of positive integers nums, return an array answer that consists of the digits of e...
 * >>> separate_digits [10921; 456; 78]
 * [1; 0; 9; 2; 1; 4; 5; 6; 7; 8]
 * >>> separate_digits [98765; 43210; 11111; 22222]
 * [9; 8; 7; 6; 5; 4; 3; 2; 1; 0; 1; 1; 1; 1; 1; 2; 2; 2; 2; 2]
 * >>> separate_digits [98765; 43210]
 * [9; 8; 7; 6; 5; 4; 3; 2; 1; 0]
*)
let separate_digits (nums : int list) : int list =","  []","let () =
  assert (separate_digits [10921; 456; 78] = [1; 0; 9; 2; 1; 4; 5; 6; 7; 8]);
  assert (separate_digits [98765; 43210; 11111; 22222] = [9; 8; 7; 6; 5; 4; 3; 2; 1; 0; 1; 1; 1; 1; 1; 2; 2; 2; 2; 2]);
  assert (separate_digits [98765; 43210] = [9; 8; 7; 6; 5; 4; 3; 2; 1; 0]);
  assert (separate_digits [7; 1; 3; 9] = [7; 1; 3; 9]);
  assert (separate_digits [999; 888; 777; 666; 555] = [9; 9; 9; 8; 8; 8; 7; 7; 7; 6; 6; 6; 5; 5; 5]);
  assert (separate_digits [10921; 123; 456; 789] = [1; 0; 9; 2; 1; 1; 2; 3; 4; 5; 6; 7; 8; 9]);
  assert (separate_digits [10921; 2024; 55] = [1; 0; 9; 2; 1; 2; 0; 2; 4; 5; 5]);
;;","easy","easy_136","easy"
"(**You are given an m x n binary grid, where each 1 represents a brick and 0 represents an empty spa...
 * >>> hit_bricks [[1; 1; 1; 0]; [1; 0; 0; 0]; [1; 1; 1; 0]] [[0; 0]; [1; 1]; [2; 2]]
 * [4; 0; 0]
 * >>> hit_bricks [[1; 1; 1; 1]; [0; 1; 0; 1]; [1; 1; 1; 1]] [[1; 0]; [1; 2]]
 * [0; 0]
 * >>> hit_bricks [[1; 0; 1]; [1; 1; 1]] [[0; 0]; [0; 2]]
 * [0; 3]
*)
let hit_bricks (grid : int list list) (hits : int list list) : int list =","  []","let () =
  assert (hit_bricks [[1; 1; 1; 0]; [1; 0; 0; 0]; [1; 1; 1; 0]] [[0; 0]; [1; 1]; [2; 2]] = [4; 0; 0]);
  assert (hit_bricks [[1; 1; 1; 1]; [0; 1; 0; 1]; [1; 1; 1; 1]] [[1; 0]; [1; 2]] = [0; 0]);
  assert (hit_bricks [[1; 0; 1]; [1; 1; 1]] [[0; 0]; [0; 2]] = [0; 3]);
  assert (hit_bricks [[1; 0; 0; 0]; [1; 1; 1; 0]] [[1; 0]] = [2]);
  assert (hit_bricks [[0; 0; 0]; [0; 0; 0]; [0; 0; 0]] [[0; 0]; [0; 1]; [0; 2]] = [0; 0; 0]);
  assert (hit_bricks [[1; 1; 1; 1]; [1; 1; 1; 1]; [1; 1; 1; 1]] [[1; 1]] = [0]);
  assert (hit_bricks [[1; 0; 0; 0]; [1; 1; 0; 0]] [[1; 1]; [1; 0]] = [0; 0]);
;;","hard","hard_004","hard"
"(**You are given an array of n strings strs, all of the same length.
 * >>> min_deletion_size [""ppp""; ""qqq""; ""rrr""]
 * 0
 * >>> min_deletion_size [""az""; ""za""]
 * 0
 * >>> min_deletion_size [""xc""; ""yb""; ""za""]
 * 0
*)
let min_deletion_size (strs : string list) : int =","  0","let () =
  assert (min_deletion_size [""ppp""; ""qqq""; ""rrr""] = 0);
  assert (min_deletion_size [""az""; ""za""] = 0);
  assert (min_deletion_size [""xc""; ""yb""; ""za""] = 0);
  assert (min_deletion_size [""dog""; ""cat""; ""bat""] = 2);
  assert (min_deletion_size [""abcdef""; ""uvwxyz""] = 0);
  assert (min_deletion_size [""abcd""; ""abce""; ""abcf""] = 0);
  assert (min_deletion_size [""aaa""; ""aaa""; ""aaa""] = 0);
;;","medium","medium_025","medium"
"(**Given an integer number n, return the difference between the product of its digits and the sum of...
 * >>> subtract_product_and_sum 99999
 * 59004
 * >>> subtract_product_and_sum 11111
 * -4
 * >>> subtract_product_and_sum 789
 * 480
*)
let subtract_product_and_sum (n : int) : int =","  0","let () =
  assert (subtract_product_and_sum 99999 = 59004);
  assert (subtract_product_and_sum 11111 = -4);
  assert (subtract_product_and_sum 789 = 480);
  assert (subtract_product_and_sum 1111 = -3);
  assert (subtract_product_and_sum 234 = 15);
  assert (subtract_product_and_sum 12345 = 105);
  assert (subtract_product_and_sum 456 = 105);
;;","easy","easy_095","easy"
"(**Given an array of integers nums and an integer target, return indices of the two numbers such tha...
 * >>> two_sum [3; 3] 6
 * [0; 1]
 * >>> two_sum [-1; -2; -3; -4] -8
 * None
 * >>> two_sum [1000000000; 1000000000] 2000000000
 * [0; 1]
*)
let two_sum (nums : int list) (target : int) : int list =","  []","let () =
  assert (two_sum [3; 3] 6 = [0; 1]);
  assert (two_sum [-1; -2; -3; -4] -8 = None);
  assert (two_sum [1000000000; 1000000000] 2000000000 = [0; 1]);
  assert (two_sum [1; 5; 7; 9] 10 = [0; 3]);
  assert (two_sum [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 3 = [0; 1]);
  assert (two_sum [0; 4; 3; 0] 0 = [0; 3]);
  assert (two_sum [1000000000; -1000000000; 500000000; -500000000] 0 = [0; 1]);
;;","easy","easy_149","easy"
"(**Given an array of integers nums, sort the array in ascending order and return it.
*)
let sort_array (nums : int list) : int list =","  []","let () =
  assert (sort_array [0] = [0]);
  assert (sort_array [-1] = [-1]);
  assert (sort_array [50000] = [50000]);
  assert (sort_array [-50000] = [-50000]);
  assert (sort_array [1] = [1]);
;;","medium","medium_175","medium"
"(**A string originalText is encoded using a slanted transposition cipher to a string encodedText wit...
 * >>> decode_ciphertext ""a"" 1
 * a
 * >>> decode_ciphertext ""abcd efg hijk"" 3
 * aeibfjcgd
 * >>> decode_ciphertext ""a   b   c   d"" 2
 * a  c    b
*)
let decode_ciphertext (encodedText : string) (rows : int) : string =","  """"","let () =
  assert (decode_ciphertext ""a"" 1 = a);
  assert (decode_ciphertext ""abcd efg hijk"" 3 = aeibfjcgd);
  assert (decode_ciphertext ""a   b   c   d"" 2 = a  c    b);
  assert (decode_ciphertext ""coding"" 1 = coding);
  assert (decode_ciphertext ""abc def ghi jkl mno"" 5 = adgbec);
  assert (decode_ciphertext ""ab c  de"" 2 = a bd ec);
  assert (decode_ciphertext ""ch   ie   pr"" 3 = cipher);
;;","medium","medium_061","medium"
"(**Given a string s, return the last substring of s in lexicographical order.
 * >>> last_substring ""abab""
 * bab
 * >>> last_substring ""mississippi""
 * ssissippi
 * >>> last_substring ""abcdabcdabcd""
 * dabcdabcd
*)
let last_substring (s : string) : string =","  """"","let () =
  assert (last_substring ""abab"" = bab);
  assert (last_substring ""mississippi"" = ssissippi);
  assert (last_substring ""abcdabcdabcd"" = dabcdabcd);
  assert (last_substring ""banana"" = nana);
  assert (last_substring ""zyxzy"" = zyxzy);
  assert (last_substring ""zyxzyxzyx"" = zyxzyxzyx);
  assert (last_substring ""a"" = a);
;;","hard","hard_065","hard"
"(**An IP address is a formatted 32-bit unsigned integer where each group of 8 bits is printed as a d...
 * >>> ip_to_cidr ""1.2.3.4"" 4
 * ['1.2.3.4/30']
 * >>> ip_to_cidr ""255.255.255.252"" 4
 * ['255.255.255.252/30']
 * >>> ip_to_cidr ""192.168.1.0"" 16
 * ['192.168.1.0/28']
*)
let ip_to_cidr (ip : string) (n : int) : string list =","  []","let () =
  assert (ip_to_cidr ""1.2.3.4"" 4 = ['1.2.3.4/30']);
  assert (ip_to_cidr ""255.255.255.252"" 4 = ['255.255.255.252/30']);
  assert (ip_to_cidr ""192.168.1.0"" 16 = ['192.168.1.0/28']);
  assert (ip_to_cidr ""192.168.1.100"" 1000 = ['192.168.1.100/30'; '192.168.1.104/29'; '192.168.1.112/28'; '192.168.1.128/25'; '192.168.2.0/23'; '192.168.4.0/24'; '192.168.5.0/26'; '192.168.5.64/29'; '192.168.5.72/30']);
  assert (ip_to_cidr ""172.16.0.0"" 2048 = ['172.16.0.0/21']);
  assert (ip_to_cidr ""192.168.1.1"" 1 = ['192.168.1.1/32']);
  assert (ip_to_cidr ""192.168.1.1"" 256 = ['192.168.1.1/32'; '192.168.1.2/31'; '192.168.1.4/30'; '192.168.1.8/29'; '192.168.1.16/28'; '192.168.1.32/27'; '192.168.1.64/26'; '192.168.1.128/25'; '192.168.2.0/32']);
;;","medium","medium_075","medium"
"(**You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][...
 * >>> island_perimeter [[0; 1; 0; 0; 0]; [0; 1; 0; 0; 0]; [0; 1; 1; 1; 0]; [0; 0; 0; 0; 0]]
 * 12
 * >>> island_perimeter [[1]]
 * 4
 * >>> island_perimeter [[1; 1; 1]; [1; 0; 1]; [1; 1; 1]]
 * 16
*)
let island_perimeter (grid : int list list) : int =","  0","let () =
  assert (island_perimeter [[0; 1; 0; 0; 0]; [0; 1; 0; 0; 0]; [0; 1; 1; 1; 0]; [0; 0; 0; 0; 0]] = 12);
  assert (island_perimeter [[1]] = 4);
  assert (island_perimeter [[1; 1; 1]; [1; 0; 1]; [1; 1; 1]] = 16);
  assert (island_perimeter [[0; 1; 0; 1; 0]; [1; 1; 1; 1; 1]; [0; 1; 0; 1; 0]] = 20);
  assert (island_perimeter [[1; 0]] = 4);
  assert (island_perimeter [[0; 1; 1; 0]; [1; 1; 1; 1]; [0; 1; 1; 0]] = 14);
  assert (island_perimeter [[0; 1; 0; 0]; [1; 1; 1; 0]; [0; 1; 0; 0]; [1; 1; 0; 0]] = 16);
;;","easy","easy_104","easy"
"(**A string can be abbreviated by replacing any number of non-adjacent, non-empty substrings with th...
 * >>> valid_word_abbreviation ""internationalization"" ""i12iz4n""
 * true
 * >>> valid_word_abbreviation ""substitution"" ""substitution""
 * true
 * >>> valid_word_abbreviation ""hi"" ""2""
 * true
*)
let valid_word_abbreviation (word : string) (abbr : string) : bool =","  false","let () =
  assert (valid_word_abbreviation ""internationalization"" ""i12iz4n"" = true);
  assert (valid_word_abbreviation ""substitution"" ""substitution"" = true);
  assert (valid_word_abbreviation ""hi"" ""2"" = true);
  assert (valid_word_abbreviation ""substitution"" ""su3i1u2on"" = true);
  assert (valid_word_abbreviation ""hi"" ""h1"" = true);
  assert (valid_word_abbreviation ""hello"" ""he3"" = true);
  assert (valid_word_abbreviation ""hello"" ""h4"" = true);
;;","easy","easy_057","easy"
"(**You are given a 0-indexed integer array nums and an integer k.
 * >>> max_frequency_score [1000000000] 1000000000000
 * 1
 * >>> max_frequency_score [1; 3; 3; 3; 7; 8; 9] 4
 * 4
 * >>> max_frequency_score [1; 3; 5; 7; 9] 10
 * 4
*)
let max_frequency_score (nums : int list) (k : int) : int =","  0","let () =
  assert (max_frequency_score [1000000000] 1000000000000 = 1);
  assert (max_frequency_score [1; 3; 3; 3; 7; 8; 9] 4 = 4);
  assert (max_frequency_score [1; 3; 5; 7; 9] 10 = 4);
  assert (max_frequency_score [1; 4; 4; 2; 4] 0 = 3);
  assert (max_frequency_score [5; 5; 5; 5; 5] 10 = 5);
  assert (max_frequency_score [1; 1000000000] 1000000000 = 2);
  assert (max_frequency_score [1000000000; 1000000000; 1000000000] 1000000000 = 3);
;;","hard","hard_049","hard"
"(**You are given a 0-indexed integer array nums.
 * >>> find_maximum_length [1; 2; 2; 3; 4; 5; 5; 6; 7; 8]
 * 10
 * >>> find_maximum_length [1; 100; 1000]
 * 3
 * >>> find_maximum_length [10; 9; 2; 5; 3; 7; 101; 18]
 * 4
*)
let find_maximum_length (nums : int list) : int =","  0","let () =
  assert (find_maximum_length [1; 2; 2; 3; 4; 5; 5; 6; 7; 8] = 10);
  assert (find_maximum_length [1; 100; 1000] = 3);
  assert (find_maximum_length [10; 9; 2; 5; 3; 7; 101; 18] = 4);
  assert (find_maximum_length [10; 9; 8; 7; 6; 5; 4; 3; 2; 1] = 3);
  assert (find_maximum_length [3; 3; 3; 3] = 4);
  assert (find_maximum_length [5; 4; 3; 2; 1; 6; 7; 8] = 4);
  assert (find_maximum_length [1] = 1);
;;","hard","hard_068","hard"
"(**Given an integer array nums sorted in non-decreasing order and an integer target, return true if ...
 * >>> is_majority_element [1; 1; 2; 2; 2; 2; 2; 3; 3; 3] 2
 * false
 * >>> is_majority_element [1; 1; 1; 1; 2; 2; 2; 2; 2] 1
 * false
 * >>> is_majority_element [10; 100; 101; 101] 101
 * false
*)
let is_majority_element (nums : int list) (target : int) : bool =","  false","let () =
  assert (is_majority_element [1; 1; 2; 2; 2; 2; 2; 3; 3; 3] 2 = false);
  assert (is_majority_element [1; 1; 1; 1; 2; 2; 2; 2; 2] 1 = false);
  assert (is_majority_element [10; 100; 101; 101] 101 = false);
  assert (is_majority_element [2; 4; 5; 5; 5; 5; 5; 6; 6] 5 = true);
  assert (is_majority_element [3; 3; 3; 3; 3; 3; 3; 3; 3; 3] 3 = true);
  assert (is_majority_element [1; 2; 2; 2; 2; 3; 3] 2 = true);
  assert (is_majority_element [5; 5; 5; 5; 5; 5; 6; 6; 6; 6] 5 = true);
;;","easy","easy_005","easy"
"(**You are given a positive integer n.
 * >>> valid_strings 3
 * ['010'; '011'; '101'; '110'; '111']
 * >>> valid_strings 15
 * ['010101010101010'; '010101010101011'; '010101010101101'; '010101010101110'; '010101010101111'; '010101010110101'; '010101010110110'; '010101010110111'; '010101010111010'; '010101010111011'; '010101010111101'; '010101010111110'; '010101010111111'; '010101011010101'; '010101011010110'; '010101011010111'; '010101011011010'; '010101011011011'; '010101011011101'; '010101011011110'; '010101011011111'; '010101011101010'; '010101011101011'; '010101011101101'; '010101011101110'; '010101011101111'; '010101011110101'; '010101011110110'; '010101011110111'; '010101011111010'; '010101011111011'; '010101011111101'; '010101011111110'; '010101011111111'; '010101101010101'; '010101101010110'; '010101101010111'; '010101101011010'; '010101101011011'; '010101101011101'; '010101101011110'; '010101101011111'; '010101101101010'; '010101101101011'; '010101101101101'; '010101101101110'; '010101101101111'; '010101101110101'; '010101101110110'; '010101101110111'; '010101101111010'; '010101101111011'; '010101101111101'; '010101101111110'; '010101101111111'; '010101110101010'; '010101110101011'; '010101110101101'; '010101110101110'; '010101110101111'; '010101110110101'; '010101110110110'; '010101110110111'; '010101110111010'; '010101110111011'; '010101110111101'; '010101110111110'; '010101110111111'; '010101111010101'; '010101111010110'; '010101111010111'; '010101111011010'; '010101111011011'; '010101111011101'; '010101111011110'; '010101111011111'; '010101111101010'; '010101111101011'; '010101111101101'; '010101111101110'; '010101111101111'; '010101111110101'; '010101111110110'; '010101111110111'; '010101111111010'; '010101111111011'; '010101111111101'; '010101111111110'; '010101111111111'; '010110101010101'; '010110101010110'; '010110101010111'; '010110101011010'; '010110101011011'; '010110101011101'; '010110101011110'; '010110101011111'; '010110101101010'; '010110101101011'; '010110101101101'; '010110101101110'; '010110101101111'; '010110101110101'; '010110101110110'; '010110101110111'; '010110101111010'; '010110101111011'; '010110101111101'; '010110101111110'; '010110101111111'; '010110110101010'; '010110110101011'; '010110110101101'; '010110110101110'; '010110110101111'; '010110110110101'; '010110110110110'; '010110110110111'; '010110110111010'; '010110110111011'; '010110110111101'; '010110110111110'; '010110110111111'; '010110111010101'; '010110111010110'; '010110111010111'; '010110111011010'; '010110111011011'; '010110111011101'; '010110111011110'; '010110111011111'; '010110111101010'; '010110111101011'; '010110111101101'; '010110111101110'; '010110111101111'; '010110111110101'; '010110111110110'; '010110111110111'; '010110111111010'; '010110111111011'; '010110111111101'; '010110111111110'; '010110111111111'; '010111010101010'; '010111010101011'; '010111010101101'; '010111010101110'; '010111010101111'; '010111010110101'; '010111010110110'; '010111010110111'; '010111010111010'; '010111010111011'; '010111010111101'; '010111010111110'; '010111010111111'; '010111011010101'; '010111011010110'; '010111011010111'; '010111011011010'; '010111011011011'; '010111011011101'; '010111011011110'; '010111011011111'; '010111011101010'; '010111011101011'; '010111011101101'; '010111011101110'; '010111011101111'; '010111011110101'; '010111011110110'; '010111011110111'; '010111011111010'; '010111011111011'; '010111011111101'; '010111011111110'; '010111011111111'; '010111101010101'; '010111101010110'; '010111101010111'; '010111101011010'; '010111101011011'; '010111101011101'; '010111101011110'; '010111101011111'; '010111101101010'; '010111101101011'; '010111101101101'; '010111101101110'; '010111101101111'; '010111101110101'; '010111101110110'; '010111101110111'; '010111101111010'; '010111101111011'; '010111101111101'; '010111101111110'; '010111101111111'; '010111110101010'; '010111110101011'; '010111110101101'; '010111110101110'; '010111110101111'; '010111110110101'; '010111110110110'; '010111110110111'; '010111110111010'; '010111110111011'; '010111110111101'; '010111110111110'; '010111110111111'; '010111111010101'; '010111111010110'; '010111111010111'; '010111111011010'; '010111111011011'; '010111111011101'; '010111111011110'; '010111111011111'; '010111111101010'; '010111111101011'; '010111111101101'; '010111111101110'; '010111111101111'; '010111111110101'; '010111111110110'; '010111111110111'; '010111111111010'; '010111111111011'; '010111111111101'; '010111111111110'; '010111111111111'; '011010101010101'; '011010101010110'; '011010101010111'; '011010101011010'; '011010101011011'; '011010101011101'; '011010101011110'; '011010101011111'; '011010101101010'; '011010101101011'; '011010101101101'; '011010101101110'; '011010101101111'; '011010101110101'; '011010101110110'; '011010101110111'; '011010101111010'; '011010101111011'; '011010101111101'; '011010101111110'; '011010101111111'; '011010110101010'; '011010110101011'; '011010110101101'; '011010110101110'; '011010110101111'; '011010110110101'; '011010110110110'; '011010110110111'; '011010110111010'; '011010110111011'; '011010110111101'; '011010110111110'; '011010110111111'; '011010111010101'; '011010111010110'; '011010111010111'; '011010111011010'; '011010111011011'; '011010111011101'; '011010111011110'; '011010111011111'; '011010111101010'; '011010111101011'; '011010111101101'; '011010111101110'; '011010111101111'; '011010111110101'; '011010111110110'; '011010111110111'; '011010111111010'; '011010111111011'; '011010111111101'; '011010111111110'; '011010111111111'; '011011010101010'; '011011010101011'; '011011010101101'; '011011010101110'; '011011010101111'; '011011010110101'; '011011010110110'; '011011010110111'; '011011010111010'; '011011010111011'; '011011010111101'; '011011010111110'; '011011010111111'; '011011011010101'; '011011011010110'; '011011011010111'; '011011011011010'; '011011011011011'; '011011011011101'; '011011011011110'; '011011011011111'; '011011011101010'; '011011011101011'; '011011011101101'; '011011011101110'; '011011011101111'; '011011011110101'; '011011011110110'; '011011011110111'; '011011011111010'; '011011011111011'; '011011011111101'; '011011011111110'; '011011011111111'; '011011101010101'; '011011101010110'; '011011101010111'; '011011101011010'; '011011101011011'; '011011101011101'; '011011101011110'; '011011101011111'; '011011101101010'; '011011101101011'; '011011101101101'; '011011101101110'; '011011101101111'; '011011101110101'; '011011101110110'; '011011101110111'; '011011101111010'; '011011101111011'; '011011101111101'; '011011101111110'; '011011101111111'; '011011110101010'; '011011110101011'; '011011110101101'; '011011110101110'; '011011110101111'; '011011110110101'; '011011110110110'; '011011110110111'; '011011110111010'; '011011110111011'; '011011110111101'; '011011110111110'; '011011110111111'; '011011111010101'; '011011111010110'; '011011111010111'; '011011111011010'; '011011111011011'; '011011111011101'; '011011111011110'; '011011111011111'; '011011111101010'; '011011111101011'; '011011111101101'; '011011111101110'; '011011111101111'; '011011111110101'; '011011111110110'; '011011111110111'; '011011111111010'; '011011111111011'; '011011111111101'; '011011111111110'; '011011111111111'; '011101010101010'; '011101010101011'; '011101010101101'; '011101010101110'; '011101010101111'; '011101010110101'; '011101010110110'; '011101010110111'; '011101010111010'; '011101010111011'; '011101010111101'; '011101010111110'; '011101010111111'; '011101011010101'; '011101011010110'; '011101011010111'; '011101011011010'; '011101011011011'; '011101011011101'; '011101011011110'; '011101011011111'; '011101011101010'; '011101011101011'; '011101011101101'; '011101011101110'; '011101011101111'; '011101011110101'; '011101011110110'; '011101011110111'; '011101011111010'; '011101011111011'; '011101011111101'; '011101011111110'; '011101011111111'; '011101101010101'; '011101101010110'; '011101101010111'; '011101101011010'; '011101101011011'; '011101101011101'; '011101101011110'; '011101101011111'; '011101101101010'; '011101101101011'; '011101101101101'; '011101101101110'; '011101101101111'; '011101101110101'; '011101101110110'; '011101101110111'; '011101101111010'; '011101101111011'; '011101101111101'; '011101101111110'; '011101101111111'; '011101110101010'; '011101110101011'; '011101110101101'; '011101110101110'; '011101110101111'; '011101110110101'; '011101110110110'; '011101110110111'; '011101110111010'; '011101110111011'; '011101110111101'; '011101110111110'; '011101110111111'; '011101111010101'; '011101111010110'; '011101111010111'; '011101111011010'; '011101111011011'; '011101111011101'; '011101111011110'; '011101111011111'; '011101111101010'; '011101111101011'; '011101111101101'; '011101111101110'; '011101111101111'; '011101111110101'; '011101111110110'; '011101111110111'; '011101111111010'; '011101111111011'; '011101111111101'; '011101111111110'; '011101111111111'; '011110101010101'; '011110101010110'; '011110101010111'; '011110101011010'; '011110101011011'; '011110101011101'; '011110101011110'; '011110101011111'; '011110101101010'; '011110101101011'; '011110101101101'; '011110101101110'; '011110101101111'; '011110101110101'; '011110101110110'; '011110101110111'; '011110101111010'; '011110101111011'; '011110101111101'; '011110101111110'; '011110101111111'; '011110110101010'; '011110110101011'; '011110110101101'; '011110110101110'; '011110110101111'; '011110110110101'; '011110110110110'; '011110110110111'; '011110110111010'; '011110110111011'; '011110110111101'; '011110110111110'; '011110110111111'; '011110111010101'; '011110111010110'; '011110111010111'; '011110111011010'; '011110111011011'; '011110111011101'; '011110111011110'; '011110111011111'; '011110111101010'; '011110111101011'; '011110111101101'; '011110111101110'; '011110111101111'; '011110111110101'; '011110111110110'; '011110111110111'; '011110111111010'; '011110111111011'; '011110111111101'; '011110111111110'; '011110111111111'; '011111010101010'; '011111010101011'; '011111010101101'; '011111010101110'; '011111010101111'; '011111010110101'; '011111010110110'; '011111010110111'; '011111010111010'; '011111010111011'; '011111010111101'; '011111010111110'; '011111010111111'; '011111011010101'; '011111011010110'; '011111011010111'; '011111011011010'; '011111011011011'; '011111011011101'; '011111011011110'; '011111011011111'; '011111011101010'; '011111011101011'; '011111011101101'; '011111011101110'; '011111011101111'; '011111011110101'; '011111011110110'; '011111011110111'; '011111011111010'; '011111011111011'; '011111011111101'; '011111011111110'; '011111011111111'; '011111101010101'; '011111101010110'; '011111101010111'; '011111101011010'; '011111101011011'; '011111101011101'; '011111101011110'; '011111101011111'; '011111101101010'; '011111101101011'; '011111101101101'; '011111101101110'; '011111101101111'; '011111101110101'; '011111101110110'; '011111101110111'; '011111101111010'; '011111101111011'; '011111101111101'; '011111101111110'; '011111101111111'; '011111110101010'; '011111110101011'; '011111110101101'; '011111110101110'; '011111110101111'; '011111110110101'; '011111110110110'; '011111110110111'; '011111110111010'; '011111110111011'; '011111110111101'; '011111110111110'; '011111110111111'; '011111111010101'; '011111111010110'; '011111111010111'; '011111111011010'; '011111111011011'; '011111111011101'; '011111111011110'; '011111111011111'; '011111111101010'; '011111111101011'; '011111111101101'; '011111111101110'; '011111111101111'; '011111111110101'; '011111111110110'; '011111111110111'; '011111111111010'; '011111111111011'; '011111111111101'; '011111111111110'; '011111111111111'; '101010101010101'; '101010101010110'; '101010101010111'; '101010101011010'; '101010101011011'; '101010101011101'; '101010101011110'; '101010101011111'; '101010101101010'; '101010101101011'; '101010101101101'; '101010101101110'; '101010101101111'; '101010101110101'; '101010101110110'; '101010101110111'; '101010101111010'; '101010101111011'; '101010101111101'; '101010101111110'; '101010101111111'; '101010110101010'; '101010110101011'; '101010110101101'; '101010110101110'; '101010110101111'; '101010110110101'; '101010110110110'; '101010110110111'; '101010110111010'; '101010110111011'; '101010110111101'; '101010110111110'; '101010110111111'; '101010111010101'; '101010111010110'; '101010111010111'; '101010111011010'; '101010111011011'; '101010111011101'; '101010111011110'; '101010111011111'; '101010111101010'; '101010111101011'; '101010111101101'; '101010111101110'; '101010111101111'; '101010111110101'; '101010111110110'; '101010111110111'; '101010111111010'; '101010111111011'; '101010111111101'; '101010111111110'; '101010111111111'; '101011010101010'; '101011010101011'; '101011010101101'; '101011010101110'; '101011010101111'; '101011010110101'; '101011010110110'; '101011010110111'; '101011010111010'; '101011010111011'; '101011010111101'; '101011010111110'; '101011010111111'; '101011011010101'; '101011011010110'; '101011011010111'; '101011011011010'; '101011011011011'; '101011011011101'; '101011011011110'; '101011011011111'; '101011011101010'; '101011011101011'; '101011011101101'; '101011011101110'; '101011011101111'; '101011011110101'; '101011011110110'; '101011011110111'; '101011011111010'; '101011011111011'; '101011011111101'; '101011011111110'; '101011011111111'; '101011101010101'; '101011101010110'; '101011101010111'; '101011101011010'; '101011101011011'; '101011101011101'; '101011101011110'; '101011101011111'; '101011101101010'; '101011101101011'; '101011101101101'; '101011101101110'; '101011101101111'; '101011101110101'; '101011101110110'; '101011101110111'; '101011101111010'; '101011101111011'; '101011101111101'; '101011101111110'; '101011101111111'; '101011110101010'; '101011110101011'; '101011110101101'; '101011110101110'; '101011110101111'; '101011110110101'; '101011110110110'; '101011110110111'; '101011110111010'; '101011110111011'; '101011110111101'; '101011110111110'; '101011110111111'; '101011111010101'; '101011111010110'; '101011111010111'; '101011111011010'; '101011111011011'; '101011111011101'; '101011111011110'; '101011111011111'; '101011111101010'; '101011111101011'; '101011111101101'; '101011111101110'; '101011111101111'; '101011111110101'; '101011111110110'; '101011111110111'; '101011111111010'; '101011111111011'; '101011111111101'; '101011111111110'; '101011111111111'; '101101010101010'; '101101010101011'; '101101010101101'; '101101010101110'; '101101010101111'; '101101010110101'; '101101010110110'; '101101010110111'; '101101010111010'; '101101010111011'; '101101010111101'; '101101010111110'; '101101010111111'; '101101011010101'; '101101011010110'; '101101011010111'; '101101011011010'; '101101011011011'; '101101011011101'; '101101011011110'; '101101011011111'; '101101011101010'; '101101011101011'; '101101011101101'; '101101011101110'; '101101011101111'; '101101011110101'; '101101011110110'; '101101011110111'; '101101011111010'; '101101011111011'; '101101011111101'; '101101011111110'; '101101011111111'; '101101101010101'; '101101101010110'; '101101101010111'; '101101101011010'; '101101101011011'; '101101101011101'; '101101101011110'; '101101101011111'; '101101101101010'; '101101101101011'; '101101101101101'; '101101101101110'; '101101101101111'; '101101101110101'; '101101101110110'; '101101101110111'; '101101101111010'; '101101101111011'; '101101101111101'; '101101101111110'; '101101101111111'; '101101110101010'; '101101110101011'; '101101110101101'; '101101110101110'; '101101110101111'; '101101110110101'; '101101110110110'; '101101110110111'; '101101110111010'; '101101110111011'; '101101110111101'; '101101110111110'; '101101110111111'; '101101111010101'; '101101111010110'; '101101111010111'; '101101111011010'; '101101111011011'; '101101111011101'; '101101111011110'; '101101111011111'; '101101111101010'; '101101111101011'; '101101111101101'; '101101111101110'; '101101111101111'; '101101111110101'; '101101111110110'; '101101111110111'; '101101111111010'; '101101111111011'; '101101111111101'; '101101111111110'; '101101111111111'; '101110101010101'; '101110101010110'; '101110101010111'; '101110101011010'; '101110101011011'; '101110101011101'; '101110101011110'; '101110101011111'; '101110101101010'; '101110101101011'; '101110101101101'; '101110101101110'; '101110101101111'; '101110101110101'; '101110101110110'; '101110101110111'; '101110101111010'; '101110101111011'; '101110101111101'; '101110101111110'; '101110101111111'; '101110110101010'; '101110110101011'; '101110110101101'; '101110110101110'; '101110110101111'; '101110110110101'; '101110110110110'; '101110110110111'; '101110110111010'; '101110110111011'; '101110110111101'; '101110110111110'; '101110110111111'; '101110111010101'; '101110111010110'; '101110111010111'; '101110111011010'; '101110111011011'; '101110111011101'; '101110111011110'; '101110111011111'; '101110111101010'; '101110111101011'; '101110111101101'; '101110111101110'; '101110111101111'; '101110111110101'; '101110111110110'; '101110111110111'; '101110111111010'; '101110111111011'; '101110111111101'; '101110111111110'; '101110111111111'; '101111010101010'; '101111010101011'; '101111010101101'; '101111010101110'; '101111010101111'; '101111010110101'; '101111010110110'; '101111010110111'; '101111010111010'; '101111010111011'; '101111010111101'; '101111010111110'; '101111010111111'; '101111011010101'; '101111011010110'; '101111011010111'; '101111011011010'; '101111011011011'; '101111011011101'; '101111011011110'; '101111011011111'; '101111011101010'; '101111011101011'; '101111011101101'; '101111011101110'; '101111011101111'; '101111011110101'; '101111011110110'; '101111011110111'; '101111011111010'; '101111011111011'; '101111011111101'; '101111011111110'; '101111011111111'; '101111101010101'; '101111101010110'; '101111101010111'; '101111101011010'; '101111101011011'; '101111101011101'; '101111101011110'; '101111101011111'; '101111101101010'; '101111101101011'; '101111101101101'; '101111101101110'; '101111101101111'; '101111101110101'; '101111101110110'; '101111101110111'; '101111101111010'; '101111101111011'; '101111101111101'; '101111101111110'; '101111101111111'; '101111110101010'; '101111110101011'; '101111110101101'; '101111110101110'; '101111110101111'; '101111110110101'; '101111110110110'; '101111110110111'; '101111110111010'; '101111110111011'; '101111110111101'; '101111110111110'; '101111110111111'; '101111111010101'; '101111111010110'; '101111111010111'; '101111111011010'; '101111111011011'; '101111111011101'; '101111111011110'; '101111111011111'; '101111111101010'; '101111111101011'; '101111111101101'; '101111111101110'; '101111111101111'; '101111111110101'; '101111111110110'; '101111111110111'; '101111111111010'; '101111111111011'; '101111111111101'; '101111111111110'; '101111111111111'; '110101010101010'; '110101010101011'; '110101010101101'; '110101010101110'; '110101010101111'; '110101010110101'; '110101010110110'; '110101010110111'; '110101010111010'; '110101010111011'; '110101010111101'; '110101010111110'; '110101010111111'; '110101011010101'; '110101011010110'; '110101011010111'; '110101011011010'; '110101011011011'; '110101011011101'; '110101011011110'; '110101011011111'; '110101011101010'; '110101011101011'; '110101011101101'; '110101011101110'; '110101011101111'; '110101011110101'; '110101011110110'; '110101011110111'; '110101011111010'; '110101011111011'; '110101011111101'; '110101011111110'; '110101011111111'; '110101101010101'; '110101101010110'; '110101101010111'; '110101101011010'; '110101101011011'; '110101101011101'; '110101101011110'; '110101101011111'; '110101101101010'; '110101101101011'; '110101101101101'; '110101101101110'; '110101101101111'; '110101101110101'; '110101101110110'; '110101101110111'; '110101101111010'; '110101101111011'; '110101101111101'; '110101101111110'; '110101101111111'; '110101110101010'; '110101110101011'; '110101110101101'; '110101110101110'; '110101110101111'; '110101110110101'; '110101110110110'; '110101110110111'; '110101110111010'; '110101110111011'; '110101110111101'; '110101110111110'; '110101110111111'; '110101111010101'; '110101111010110'; '110101111010111'; '110101111011010'; '110101111011011'; '110101111011101'; '110101111011110'; '110101111011111'; '110101111101010'; '110101111101011'; '110101111101101'; '110101111101110'; '110101111101111'; '110101111110101'; '110101111110110'; '110101111110111'; '110101111111010'; '110101111111011'; '110101111111101'; '110101111111110'; '110101111111111'; '110110101010101'; '110110101010110'; '110110101010111'; '110110101011010'; '110110101011011'; '110110101011101'; '110110101011110'; '110110101011111'; '110110101101010'; '110110101101011'; '110110101101101'; '110110101101110'; '110110101101111'; '110110101110101'; '110110101110110'; '110110101110111'; '110110101111010'; '110110101111011'; '110110101111101'; '110110101111110'; '110110101111111'; '110110110101010'; '110110110101011'; '110110110101101'; '110110110101110'; '110110110101111'; '110110110110101'; '110110110110110'; '110110110110111'; '110110110111010'; '110110110111011'; '110110110111101'; '110110110111110'; '110110110111111'; '110110111010101'; '110110111010110'; '110110111010111'; '110110111011010'; '110110111011011'; '110110111011101'; '110110111011110'; '110110111011111'; '110110111101010'; '110110111101011'; '110110111101101'; '110110111101110'; '110110111101111'; '110110111110101'; '110110111110110'; '110110111110111'; '110110111111010'; '110110111111011'; '110110111111101'; '110110111111110'; '110110111111111'; '110111010101010'; '110111010101011'; '110111010101101'; '110111010101110'; '110111010101111'; '110111010110101'; '110111010110110'; '110111010110111'; '110111010111010'; '110111010111011'; '110111010111101'; '110111010111110'; '110111010111111'; '110111011010101'; '110111011010110'; '110111011010111'; '110111011011010'; '110111011011011'; '110111011011101'; '110111011011110'; '110111011011111'; '110111011101010'; '110111011101011'; '110111011101101'; '110111011101110'; '110111011101111'; '110111011110101'; '110111011110110'; '110111011110111'; '110111011111010'; '110111011111011'; '110111011111101'; '110111011111110'; '110111011111111'; '110111101010101'; '110111101010110'; '110111101010111'; '110111101011010'; '110111101011011'; '110111101011101'; '110111101011110'; '110111101011111'; '110111101101010'; '110111101101011'; '110111101101101'; '110111101101110'; '110111101101111'; '110111101110101'; '110111101110110'; '110111101110111'; '110111101111010'; '110111101111011'; '110111101111101'; '110111101111110'; '110111101111111'; '110111110101010'; '110111110101011'; '110111110101101'; '110111110101110'; '110111110101111'; '110111110110101'; '110111110110110'; '110111110110111'; '110111110111010'; '110111110111011'; '110111110111101'; '110111110111110'; '110111110111111'; '110111111010101'; '110111111010110'; '110111111010111'; '110111111011010'; '110111111011011'; '110111111011101'; '110111111011110'; '110111111011111'; '110111111101010'; '110111111101011'; '110111111101101'; '110111111101110'; '110111111101111'; '110111111110101'; '110111111110110'; '110111111110111'; '110111111111010'; '110111111111011'; '110111111111101'; '110111111111110'; '110111111111111'; '111010101010101'; '111010101010110'; '111010101010111'; '111010101011010'; '111010101011011'; '111010101011101'; '111010101011110'; '111010101011111'; '111010101101010'; '111010101101011'; '111010101101101'; '111010101101110'; '111010101101111'; '111010101110101'; '111010101110110'; '111010101110111'; '111010101111010'; '111010101111011'; '111010101111101'; '111010101111110'; '111010101111111'; '111010110101010'; '111010110101011'; '111010110101101'; '111010110101110'; '111010110101111'; '111010110110101'; '111010110110110'; '111010110110111'; '111010110111010'; '111010110111011'; '111010110111101'; '111010110111110'; '111010110111111'; '111010111010101'; '111010111010110'; '111010111010111'; '111010111011010'; '111010111011011'; '111010111011101'; '111010111011110'; '111010111011111'; '111010111101010'; '111010111101011'; '111010111101101'; '111010111101110'; '111010111101111'; '111010111110101'; '111010111110110'; '111010111110111'; '111010111111010'; '111010111111011'; '111010111111101'; '111010111111110'; '111010111111111'; '111011010101010'; '111011010101011'; '111011010101101'; '111011010101110'; '111011010101111'; '111011010110101'; '111011010110110'; '111011010110111'; '111011010111010'; '111011010111011'; '111011010111101'; '111011010111110'; '111011010111111'; '111011011010101'; '111011011010110'; '111011011010111'; '111011011011010'; '111011011011011'; '111011011011101'; '111011011011110'; '111011011011111'; '111011011101010'; '111011011101011'; '111011011101101'; '111011011101110'; '111011011101111'; '111011011110101'; '111011011110110'; '111011011110111'; '111011011111010'; '111011011111011'; '111011011111101'; '111011011111110'; '111011011111111'; '111011101010101'; '111011101010110'; '111011101010111'; '111011101011010'; '111011101011011'; '111011101011101'; '111011101011110'; '111011101011111'; '111011101101010'; '111011101101011'; '111011101101101'; '111011101101110'; '111011101101111'; '111011101110101'; '111011101110110'; '111011101110111'; '111011101111010'; '111011101111011'; '111011101111101'; '111011101111110'; '111011101111111'; '111011110101010'; '111011110101011'; '111011110101101'; '111011110101110'; '111011110101111'; '111011110110101'; '111011110110110'; '111011110110111'; '111011110111010'; '111011110111011'; '111011110111101'; '111011110111110'; '111011110111111'; '111011111010101'; '111011111010110'; '111011111010111'; '111011111011010'; '111011111011011'; '111011111011101'; '111011111011110'; '111011111011111'; '111011111101010'; '111011111101011'; '111011111101101'; '111011111101110'; '111011111101111'; '111011111110101'; '111011111110110'; '111011111110111'; '111011111111010'; '111011111111011'; '111011111111101'; '111011111111110'; '111011111111111'; '111101010101010'; '111101010101011'; '111101010101101'; '111101010101110'; '111101010101111'; '111101010110101'; '111101010110110'; '111101010110111'; '111101010111010'; '111101010111011'; '111101010111101'; '111101010111110'; '111101010111111'; '111101011010101'; '111101011010110'; '111101011010111'; '111101011011010'; '111101011011011'; '111101011011101'; '111101011011110'; '111101011011111'; '111101011101010'; '111101011101011'; '111101011101101'; '111101011101110'; '111101011101111'; '111101011110101'; '111101011110110'; '111101011110111'; '111101011111010'; '111101011111011'; '111101011111101'; '111101011111110'; '111101011111111'; '111101101010101'; '111101101010110'; '111101101010111'; '111101101011010'; '111101101011011'; '111101101011101'; '111101101011110'; '111101101011111'; '111101101101010'; '111101101101011'; '111101101101101'; '111101101101110'; '111101101101111'; '111101101110101'; '111101101110110'; '111101101110111'; '111101101111010'; '111101101111011'; '111101101111101'; '111101101111110'; '111101101111111'; '111101110101010'; '111101110101011'; '111101110101101'; '111101110101110'; '111101110101111'; '111101110110101'; '111101110110110'; '111101110110111'; '111101110111010'; '111101110111011'; '111101110111101'; '111101110111110'; '111101110111111'; '111101111010101'; '111101111010110'; '111101111010111'; '111101111011010'; '111101111011011'; '111101111011101'; '111101111011110'; '111101111011111'; '111101111101010'; '111101111101011'; '111101111101101'; '111101111101110'; '111101111101111'; '111101111110101'; '111101111110110'; '111101111110111'; '111101111111010'; '111101111111011'; '111101111111101'; '111101111111110'; '111101111111111'; '111110101010101'; '111110101010110'; '111110101010111'; '111110101011010'; '111110101011011'; '111110101011101'; '111110101011110'; '111110101011111'; '111110101101010'; '111110101101011'; '111110101101101'; '111110101101110'; '111110101101111'; '111110101110101'; '111110101110110'; '111110101110111'; '111110101111010'; '111110101111011'; '111110101111101'; '111110101111110'; '111110101111111'; '111110110101010'; '111110110101011'; '111110110101101'; '111110110101110'; '111110110101111'; '111110110110101'; '111110110110110'; '111110110110111'; '111110110111010'; '111110110111011'; '111110110111101'; '111110110111110'; '111110110111111'; '111110111010101'; '111110111010110'; '111110111010111'; '111110111011010'; '111110111011011'; '111110111011101'; '111110111011110'; '111110111011111'; '111110111101010'; '111110111101011'; '111110111101101'; '111110111101110'; '111110111101111'; '111110111110101'; '111110111110110'; '111110111110111'; '111110111111010'; '111110111111011'; '111110111111101'; '111110111111110'; '111110111111111'; '111111010101010'; '111111010101011'; '111111010101101'; '111111010101110'; '111111010101111'; '111111010110101'; '111111010110110'; '111111010110111'; '111111010111010'; '111111010111011'; '111111010111101'; '111111010111110'; '111111010111111'; '111111011010101'; '111111011010110'; '111111011010111'; '111111011011010'; '111111011011011'; '111111011011101'; '111111011011110'; '111111011011111'; '111111011101010'; '111111011101011'; '111111011101101'; '111111011101110'; '111111011101111'; '111111011110101'; '111111011110110'; '111111011110111'; '111111011111010'; '111111011111011'; '111111011111101'; '111111011111110'; '111111011111111'; '111111101010101'; '111111101010110'; '111111101010111'; '111111101011010'; '111111101011011'; '111111101011101'; '111111101011110'; '111111101011111'; '111111101101010'; '111111101101011'; '111111101101101'; '111111101101110'; '111111101101111'; '111111101110101'; '111111101110110'; '111111101110111'; '111111101111010'; '111111101111011'; '111111101111101'; '111111101111110'; '111111101111111'; '111111110101010'; '111111110101011'; '111111110101101'; '111111110101110'; '111111110101111'; '111111110110101'; '111111110110110'; '111111110110111'; '111111110111010'; '111111110111011'; '111111110111101'; '111111110111110'; '111111110111111'; '111111111010101'; '111111111010110'; '111111111010111'; '111111111011010'; '111111111011011'; '111111111011101'; '111111111011110'; '111111111011111'; '111111111101010'; '111111111101011'; '111111111101101'; '111111111101110'; '111111111101111'; '111111111110101'; '111111111110110'; '111111111110111'; '111111111111010'; '111111111111011'; '111111111111101'; '111111111111110'; '111111111111111']
 * >>> valid_strings 4
 * ['0101'; '0110'; '0111'; '1010'; '1011'; '1101'; '1110'; '1111']
*)
let valid_strings (n : int) : string list =","  []","let () =
  assert (valid_strings 3 = ['010'; '011'; '101'; '110'; '111']);
  assert (valid_strings 15 = ['010101010101010'; '010101010101011'; '010101010101101'; '010101010101110'; '010101010101111'; '010101010110101'; '010101010110110'; '010101010110111'; '010101010111010'; '010101010111011'; '010101010111101'; '010101010111110'; '010101010111111'; '010101011010101'; '010101011010110'; '010101011010111'; '010101011011010'; '010101011011011'; '010101011011101'; '010101011011110'; '010101011011111'; '010101011101010'; '010101011101011'; '010101011101101'; '010101011101110'; '010101011101111'; '010101011110101'; '010101011110110'; '010101011110111'; '010101011111010'; '010101011111011'; '010101011111101'; '010101011111110'; '010101011111111'; '010101101010101'; '010101101010110'; '010101101010111'; '010101101011010'; '010101101011011'; '010101101011101'; '010101101011110'; '010101101011111'; '010101101101010'; '010101101101011'; '010101101101101'; '010101101101110'; '010101101101111'; '010101101110101'; '010101101110110'; '010101101110111'; '010101101111010'; '010101101111011'; '010101101111101'; '010101101111110'; '010101101111111'; '010101110101010'; '010101110101011'; '010101110101101'; '010101110101110'; '010101110101111'; '010101110110101'; '010101110110110'; '010101110110111'; '010101110111010'; '010101110111011'; '010101110111101'; '010101110111110'; '010101110111111'; '010101111010101'; '010101111010110'; '010101111010111'; '010101111011010'; '010101111011011'; '010101111011101'; '010101111011110'; '010101111011111'; '010101111101010'; '010101111101011'; '010101111101101'; '010101111101110'; '010101111101111'; '010101111110101'; '010101111110110'; '010101111110111'; '010101111111010'; '010101111111011'; '010101111111101'; '010101111111110'; '010101111111111'; '010110101010101'; '010110101010110'; '010110101010111'; '010110101011010'; '010110101011011'; '010110101011101'; '010110101011110'; '010110101011111'; '010110101101010'; '010110101101011'; '010110101101101'; '010110101101110'; '010110101101111'; '010110101110101'; '010110101110110'; '010110101110111'; '010110101111010'; '010110101111011'; '010110101111101'; '010110101111110'; '010110101111111'; '010110110101010'; '010110110101011'; '010110110101101'; '010110110101110'; '010110110101111'; '010110110110101'; '010110110110110'; '010110110110111'; '010110110111010'; '010110110111011'; '010110110111101'; '010110110111110'; '010110110111111'; '010110111010101'; '010110111010110'; '010110111010111'; '010110111011010'; '010110111011011'; '010110111011101'; '010110111011110'; '010110111011111'; '010110111101010'; '010110111101011'; '010110111101101'; '010110111101110'; '010110111101111'; '010110111110101'; '010110111110110'; '010110111110111'; '010110111111010'; '010110111111011'; '010110111111101'; '010110111111110'; '010110111111111'; '010111010101010'; '010111010101011'; '010111010101101'; '010111010101110'; '010111010101111'; '010111010110101'; '010111010110110'; '010111010110111'; '010111010111010'; '010111010111011'; '010111010111101'; '010111010111110'; '010111010111111'; '010111011010101'; '010111011010110'; '010111011010111'; '010111011011010'; '010111011011011'; '010111011011101'; '010111011011110'; '010111011011111'; '010111011101010'; '010111011101011'; '010111011101101'; '010111011101110'; '010111011101111'; '010111011110101'; '010111011110110'; '010111011110111'; '010111011111010'; '010111011111011'; '010111011111101'; '010111011111110'; '010111011111111'; '010111101010101'; '010111101010110'; '010111101010111'; '010111101011010'; '010111101011011'; '010111101011101'; '010111101011110'; '010111101011111'; '010111101101010'; '010111101101011'; '010111101101101'; '010111101101110'; '010111101101111'; '010111101110101'; '010111101110110'; '010111101110111'; '010111101111010'; '010111101111011'; '010111101111101'; '010111101111110'; '010111101111111'; '010111110101010'; '010111110101011'; '010111110101101'; '010111110101110'; '010111110101111'; '010111110110101'; '010111110110110'; '010111110110111'; '010111110111010'; '010111110111011'; '010111110111101'; '010111110111110'; '010111110111111'; '010111111010101'; '010111111010110'; '010111111010111'; '010111111011010'; '010111111011011'; '010111111011101'; '010111111011110'; '010111111011111'; '010111111101010'; '010111111101011'; '010111111101101'; '010111111101110'; '010111111101111'; '010111111110101'; '010111111110110'; '010111111110111'; '010111111111010'; '010111111111011'; '010111111111101'; '010111111111110'; '010111111111111'; '011010101010101'; '011010101010110'; '011010101010111'; '011010101011010'; '011010101011011'; '011010101011101'; '011010101011110'; '011010101011111'; '011010101101010'; '011010101101011'; '011010101101101'; '011010101101110'; '011010101101111'; '011010101110101'; '011010101110110'; '011010101110111'; '011010101111010'; '011010101111011'; '011010101111101'; '011010101111110'; '011010101111111'; '011010110101010'; '011010110101011'; '011010110101101'; '011010110101110'; '011010110101111'; '011010110110101'; '011010110110110'; '011010110110111'; '011010110111010'; '011010110111011'; '011010110111101'; '011010110111110'; '011010110111111'; '011010111010101'; '011010111010110'; '011010111010111'; '011010111011010'; '011010111011011'; '011010111011101'; '011010111011110'; '011010111011111'; '011010111101010'; '011010111101011'; '011010111101101'; '011010111101110'; '011010111101111'; '011010111110101'; '011010111110110'; '011010111110111'; '011010111111010'; '011010111111011'; '011010111111101'; '011010111111110'; '011010111111111'; '011011010101010'; '011011010101011'; '011011010101101'; '011011010101110'; '011011010101111'; '011011010110101'; '011011010110110'; '011011010110111'; '011011010111010'; '011011010111011'; '011011010111101'; '011011010111110'; '011011010111111'; '011011011010101'; '011011011010110'; '011011011010111'; '011011011011010'; '011011011011011'; '011011011011101'; '011011011011110'; '011011011011111'; '011011011101010'; '011011011101011'; '011011011101101'; '011011011101110'; '011011011101111'; '011011011110101'; '011011011110110'; '011011011110111'; '011011011111010'; '011011011111011'; '011011011111101'; '011011011111110'; '011011011111111'; '011011101010101'; '011011101010110'; '011011101010111'; '011011101011010'; '011011101011011'; '011011101011101'; '011011101011110'; '011011101011111'; '011011101101010'; '011011101101011'; '011011101101101'; '011011101101110'; '011011101101111'; '011011101110101'; '011011101110110'; '011011101110111'; '011011101111010'; '011011101111011'; '011011101111101'; '011011101111110'; '011011101111111'; '011011110101010'; '011011110101011'; '011011110101101'; '011011110101110'; '011011110101111'; '011011110110101'; '011011110110110'; '011011110110111'; '011011110111010'; '011011110111011'; '011011110111101'; '011011110111110'; '011011110111111'; '011011111010101'; '011011111010110'; '011011111010111'; '011011111011010'; '011011111011011'; '011011111011101'; '011011111011110'; '011011111011111'; '011011111101010'; '011011111101011'; '011011111101101'; '011011111101110'; '011011111101111'; '011011111110101'; '011011111110110'; '011011111110111'; '011011111111010'; '011011111111011'; '011011111111101'; '011011111111110'; '011011111111111'; '011101010101010'; '011101010101011'; '011101010101101'; '011101010101110'; '011101010101111'; '011101010110101'; '011101010110110'; '011101010110111'; '011101010111010'; '011101010111011'; '011101010111101'; '011101010111110'; '011101010111111'; '011101011010101'; '011101011010110'; '011101011010111'; '011101011011010'; '011101011011011'; '011101011011101'; '011101011011110'; '011101011011111'; '011101011101010'; '011101011101011'; '011101011101101'; '011101011101110'; '011101011101111'; '011101011110101'; '011101011110110'; '011101011110111'; '011101011111010'; '011101011111011'; '011101011111101'; '011101011111110'; '011101011111111'; '011101101010101'; '011101101010110'; '011101101010111'; '011101101011010'; '011101101011011'; '011101101011101'; '011101101011110'; '011101101011111'; '011101101101010'; '011101101101011'; '011101101101101'; '011101101101110'; '011101101101111'; '011101101110101'; '011101101110110'; '011101101110111'; '011101101111010'; '011101101111011'; '011101101111101'; '011101101111110'; '011101101111111'; '011101110101010'; '011101110101011'; '011101110101101'; '011101110101110'; '011101110101111'; '011101110110101'; '011101110110110'; '011101110110111'; '011101110111010'; '011101110111011'; '011101110111101'; '011101110111110'; '011101110111111'; '011101111010101'; '011101111010110'; '011101111010111'; '011101111011010'; '011101111011011'; '011101111011101'; '011101111011110'; '011101111011111'; '011101111101010'; '011101111101011'; '011101111101101'; '011101111101110'; '011101111101111'; '011101111110101'; '011101111110110'; '011101111110111'; '011101111111010'; '011101111111011'; '011101111111101'; '011101111111110'; '011101111111111'; '011110101010101'; '011110101010110'; '011110101010111'; '011110101011010'; '011110101011011'; '011110101011101'; '011110101011110'; '011110101011111'; '011110101101010'; '011110101101011'; '011110101101101'; '011110101101110'; '011110101101111'; '011110101110101'; '011110101110110'; '011110101110111'; '011110101111010'; '011110101111011'; '011110101111101'; '011110101111110'; '011110101111111'; '011110110101010'; '011110110101011'; '011110110101101'; '011110110101110'; '011110110101111'; '011110110110101'; '011110110110110'; '011110110110111'; '011110110111010'; '011110110111011'; '011110110111101'; '011110110111110'; '011110110111111'; '011110111010101'; '011110111010110'; '011110111010111'; '011110111011010'; '011110111011011'; '011110111011101'; '011110111011110'; '011110111011111'; '011110111101010'; '011110111101011'; '011110111101101'; '011110111101110'; '011110111101111'; '011110111110101'; '011110111110110'; '011110111110111'; '011110111111010'; '011110111111011'; '011110111111101'; '011110111111110'; '011110111111111'; '011111010101010'; '011111010101011'; '011111010101101'; '011111010101110'; '011111010101111'; '011111010110101'; '011111010110110'; '011111010110111'; '011111010111010'; '011111010111011'; '011111010111101'; '011111010111110'; '011111010111111'; '011111011010101'; '011111011010110'; '011111011010111'; '011111011011010'; '011111011011011'; '011111011011101'; '011111011011110'; '011111011011111'; '011111011101010'; '011111011101011'; '011111011101101'; '011111011101110'; '011111011101111'; '011111011110101'; '011111011110110'; '011111011110111'; '011111011111010'; '011111011111011'; '011111011111101'; '011111011111110'; '011111011111111'; '011111101010101'; '011111101010110'; '011111101010111'; '011111101011010'; '011111101011011'; '011111101011101'; '011111101011110'; '011111101011111'; '011111101101010'; '011111101101011'; '011111101101101'; '011111101101110'; '011111101101111'; '011111101110101'; '011111101110110'; '011111101110111'; '011111101111010'; '011111101111011'; '011111101111101'; '011111101111110'; '011111101111111'; '011111110101010'; '011111110101011'; '011111110101101'; '011111110101110'; '011111110101111'; '011111110110101'; '011111110110110'; '011111110110111'; '011111110111010'; '011111110111011'; '011111110111101'; '011111110111110'; '011111110111111'; '011111111010101'; '011111111010110'; '011111111010111'; '011111111011010'; '011111111011011'; '011111111011101'; '011111111011110'; '011111111011111'; '011111111101010'; '011111111101011'; '011111111101101'; '011111111101110'; '011111111101111'; '011111111110101'; '011111111110110'; '011111111110111'; '011111111111010'; '011111111111011'; '011111111111101'; '011111111111110'; '011111111111111'; '101010101010101'; '101010101010110'; '101010101010111'; '101010101011010'; '101010101011011'; '101010101011101'; '101010101011110'; '101010101011111'; '101010101101010'; '101010101101011'; '101010101101101'; '101010101101110'; '101010101101111'; '101010101110101'; '101010101110110'; '101010101110111'; '101010101111010'; '101010101111011'; '101010101111101'; '101010101111110'; '101010101111111'; '101010110101010'; '101010110101011'; '101010110101101'; '101010110101110'; '101010110101111'; '101010110110101'; '101010110110110'; '101010110110111'; '101010110111010'; '101010110111011'; '101010110111101'; '101010110111110'; '101010110111111'; '101010111010101'; '101010111010110'; '101010111010111'; '101010111011010'; '101010111011011'; '101010111011101'; '101010111011110'; '101010111011111'; '101010111101010'; '101010111101011'; '101010111101101'; '101010111101110'; '101010111101111'; '101010111110101'; '101010111110110'; '101010111110111'; '101010111111010'; '101010111111011'; '101010111111101'; '101010111111110'; '101010111111111'; '101011010101010'; '101011010101011'; '101011010101101'; '101011010101110'; '101011010101111'; '101011010110101'; '101011010110110'; '101011010110111'; '101011010111010'; '101011010111011'; '101011010111101'; '101011010111110'; '101011010111111'; '101011011010101'; '101011011010110'; '101011011010111'; '101011011011010'; '101011011011011'; '101011011011101'; '101011011011110'; '101011011011111'; '101011011101010'; '101011011101011'; '101011011101101'; '101011011101110'; '101011011101111'; '101011011110101'; '101011011110110'; '101011011110111'; '101011011111010'; '101011011111011'; '101011011111101'; '101011011111110'; '101011011111111'; '101011101010101'; '101011101010110'; '101011101010111'; '101011101011010'; '101011101011011'; '101011101011101'; '101011101011110'; '101011101011111'; '101011101101010'; '101011101101011'; '101011101101101'; '101011101101110'; '101011101101111'; '101011101110101'; '101011101110110'; '101011101110111'; '101011101111010'; '101011101111011'; '101011101111101'; '101011101111110'; '101011101111111'; '101011110101010'; '101011110101011'; '101011110101101'; '101011110101110'; '101011110101111'; '101011110110101'; '101011110110110'; '101011110110111'; '101011110111010'; '101011110111011'; '101011110111101'; '101011110111110'; '101011110111111'; '101011111010101'; '101011111010110'; '101011111010111'; '101011111011010'; '101011111011011'; '101011111011101'; '101011111011110'; '101011111011111'; '101011111101010'; '101011111101011'; '101011111101101'; '101011111101110'; '101011111101111'; '101011111110101'; '101011111110110'; '101011111110111'; '101011111111010'; '101011111111011'; '101011111111101'; '101011111111110'; '101011111111111'; '101101010101010'; '101101010101011'; '101101010101101'; '101101010101110'; '101101010101111'; '101101010110101'; '101101010110110'; '101101010110111'; '101101010111010'; '101101010111011'; '101101010111101'; '101101010111110'; '101101010111111'; '101101011010101'; '101101011010110'; '101101011010111'; '101101011011010'; '101101011011011'; '101101011011101'; '101101011011110'; '101101011011111'; '101101011101010'; '101101011101011'; '101101011101101'; '101101011101110'; '101101011101111'; '101101011110101'; '101101011110110'; '101101011110111'; '101101011111010'; '101101011111011'; '101101011111101'; '101101011111110'; '101101011111111'; '101101101010101'; '101101101010110'; '101101101010111'; '101101101011010'; '101101101011011'; '101101101011101'; '101101101011110'; '101101101011111'; '101101101101010'; '101101101101011'; '101101101101101'; '101101101101110'; '101101101101111'; '101101101110101'; '101101101110110'; '101101101110111'; '101101101111010'; '101101101111011'; '101101101111101'; '101101101111110'; '101101101111111'; '101101110101010'; '101101110101011'; '101101110101101'; '101101110101110'; '101101110101111'; '101101110110101'; '101101110110110'; '101101110110111'; '101101110111010'; '101101110111011'; '101101110111101'; '101101110111110'; '101101110111111'; '101101111010101'; '101101111010110'; '101101111010111'; '101101111011010'; '101101111011011'; '101101111011101'; '101101111011110'; '101101111011111'; '101101111101010'; '101101111101011'; '101101111101101'; '101101111101110'; '101101111101111'; '101101111110101'; '101101111110110'; '101101111110111'; '101101111111010'; '101101111111011'; '101101111111101'; '101101111111110'; '101101111111111'; '101110101010101'; '101110101010110'; '101110101010111'; '101110101011010'; '101110101011011'; '101110101011101'; '101110101011110'; '101110101011111'; '101110101101010'; '101110101101011'; '101110101101101'; '101110101101110'; '101110101101111'; '101110101110101'; '101110101110110'; '101110101110111'; '101110101111010'; '101110101111011'; '101110101111101'; '101110101111110'; '101110101111111'; '101110110101010'; '101110110101011'; '101110110101101'; '101110110101110'; '101110110101111'; '101110110110101'; '101110110110110'; '101110110110111'; '101110110111010'; '101110110111011'; '101110110111101'; '101110110111110'; '101110110111111'; '101110111010101'; '101110111010110'; '101110111010111'; '101110111011010'; '101110111011011'; '101110111011101'; '101110111011110'; '101110111011111'; '101110111101010'; '101110111101011'; '101110111101101'; '101110111101110'; '101110111101111'; '101110111110101'; '101110111110110'; '101110111110111'; '101110111111010'; '101110111111011'; '101110111111101'; '101110111111110'; '101110111111111'; '101111010101010'; '101111010101011'; '101111010101101'; '101111010101110'; '101111010101111'; '101111010110101'; '101111010110110'; '101111010110111'; '101111010111010'; '101111010111011'; '101111010111101'; '101111010111110'; '101111010111111'; '101111011010101'; '101111011010110'; '101111011010111'; '101111011011010'; '101111011011011'; '101111011011101'; '101111011011110'; '101111011011111'; '101111011101010'; '101111011101011'; '101111011101101'; '101111011101110'; '101111011101111'; '101111011110101'; '101111011110110'; '101111011110111'; '101111011111010'; '101111011111011'; '101111011111101'; '101111011111110'; '101111011111111'; '101111101010101'; '101111101010110'; '101111101010111'; '101111101011010'; '101111101011011'; '101111101011101'; '101111101011110'; '101111101011111'; '101111101101010'; '101111101101011'; '101111101101101'; '101111101101110'; '101111101101111'; '101111101110101'; '101111101110110'; '101111101110111'; '101111101111010'; '101111101111011'; '101111101111101'; '101111101111110'; '101111101111111'; '101111110101010'; '101111110101011'; '101111110101101'; '101111110101110'; '101111110101111'; '101111110110101'; '101111110110110'; '101111110110111'; '101111110111010'; '101111110111011'; '101111110111101'; '101111110111110'; '101111110111111'; '101111111010101'; '101111111010110'; '101111111010111'; '101111111011010'; '101111111011011'; '101111111011101'; '101111111011110'; '101111111011111'; '101111111101010'; '101111111101011'; '101111111101101'; '101111111101110'; '101111111101111'; '101111111110101'; '101111111110110'; '101111111110111'; '101111111111010'; '101111111111011'; '101111111111101'; '101111111111110'; '101111111111111'; '110101010101010'; '110101010101011'; '110101010101101'; '110101010101110'; '110101010101111'; '110101010110101'; '110101010110110'; '110101010110111'; '110101010111010'; '110101010111011'; '110101010111101'; '110101010111110'; '110101010111111'; '110101011010101'; '110101011010110'; '110101011010111'; '110101011011010'; '110101011011011'; '110101011011101'; '110101011011110'; '110101011011111'; '110101011101010'; '110101011101011'; '110101011101101'; '110101011101110'; '110101011101111'; '110101011110101'; '110101011110110'; '110101011110111'; '110101011111010'; '110101011111011'; '110101011111101'; '110101011111110'; '110101011111111'; '110101101010101'; '110101101010110'; '110101101010111'; '110101101011010'; '110101101011011'; '110101101011101'; '110101101011110'; '110101101011111'; '110101101101010'; '110101101101011'; '110101101101101'; '110101101101110'; '110101101101111'; '110101101110101'; '110101101110110'; '110101101110111'; '110101101111010'; '110101101111011'; '110101101111101'; '110101101111110'; '110101101111111'; '110101110101010'; '110101110101011'; '110101110101101'; '110101110101110'; '110101110101111'; '110101110110101'; '110101110110110'; '110101110110111'; '110101110111010'; '110101110111011'; '110101110111101'; '110101110111110'; '110101110111111'; '110101111010101'; '110101111010110'; '110101111010111'; '110101111011010'; '110101111011011'; '110101111011101'; '110101111011110'; '110101111011111'; '110101111101010'; '110101111101011'; '110101111101101'; '110101111101110'; '110101111101111'; '110101111110101'; '110101111110110'; '110101111110111'; '110101111111010'; '110101111111011'; '110101111111101'; '110101111111110'; '110101111111111'; '110110101010101'; '110110101010110'; '110110101010111'; '110110101011010'; '110110101011011'; '110110101011101'; '110110101011110'; '110110101011111'; '110110101101010'; '110110101101011'; '110110101101101'; '110110101101110'; '110110101101111'; '110110101110101'; '110110101110110'; '110110101110111'; '110110101111010'; '110110101111011'; '110110101111101'; '110110101111110'; '110110101111111'; '110110110101010'; '110110110101011'; '110110110101101'; '110110110101110'; '110110110101111'; '110110110110101'; '110110110110110'; '110110110110111'; '110110110111010'; '110110110111011'; '110110110111101'; '110110110111110'; '110110110111111'; '110110111010101'; '110110111010110'; '110110111010111'; '110110111011010'; '110110111011011'; '110110111011101'; '110110111011110'; '110110111011111'; '110110111101010'; '110110111101011'; '110110111101101'; '110110111101110'; '110110111101111'; '110110111110101'; '110110111110110'; '110110111110111'; '110110111111010'; '110110111111011'; '110110111111101'; '110110111111110'; '110110111111111'; '110111010101010'; '110111010101011'; '110111010101101'; '110111010101110'; '110111010101111'; '110111010110101'; '110111010110110'; '110111010110111'; '110111010111010'; '110111010111011'; '110111010111101'; '110111010111110'; '110111010111111'; '110111011010101'; '110111011010110'; '110111011010111'; '110111011011010'; '110111011011011'; '110111011011101'; '110111011011110'; '110111011011111'; '110111011101010'; '110111011101011'; '110111011101101'; '110111011101110'; '110111011101111'; '110111011110101'; '110111011110110'; '110111011110111'; '110111011111010'; '110111011111011'; '110111011111101'; '110111011111110'; '110111011111111'; '110111101010101'; '110111101010110'; '110111101010111'; '110111101011010'; '110111101011011'; '110111101011101'; '110111101011110'; '110111101011111'; '110111101101010'; '110111101101011'; '110111101101101'; '110111101101110'; '110111101101111'; '110111101110101'; '110111101110110'; '110111101110111'; '110111101111010'; '110111101111011'; '110111101111101'; '110111101111110'; '110111101111111'; '110111110101010'; '110111110101011'; '110111110101101'; '110111110101110'; '110111110101111'; '110111110110101'; '110111110110110'; '110111110110111'; '110111110111010'; '110111110111011'; '110111110111101'; '110111110111110'; '110111110111111'; '110111111010101'; '110111111010110'; '110111111010111'; '110111111011010'; '110111111011011'; '110111111011101'; '110111111011110'; '110111111011111'; '110111111101010'; '110111111101011'; '110111111101101'; '110111111101110'; '110111111101111'; '110111111110101'; '110111111110110'; '110111111110111'; '110111111111010'; '110111111111011'; '110111111111101'; '110111111111110'; '110111111111111'; '111010101010101'; '111010101010110'; '111010101010111'; '111010101011010'; '111010101011011'; '111010101011101'; '111010101011110'; '111010101011111'; '111010101101010'; '111010101101011'; '111010101101101'; '111010101101110'; '111010101101111'; '111010101110101'; '111010101110110'; '111010101110111'; '111010101111010'; '111010101111011'; '111010101111101'; '111010101111110'; '111010101111111'; '111010110101010'; '111010110101011'; '111010110101101'; '111010110101110'; '111010110101111'; '111010110110101'; '111010110110110'; '111010110110111'; '111010110111010'; '111010110111011'; '111010110111101'; '111010110111110'; '111010110111111'; '111010111010101'; '111010111010110'; '111010111010111'; '111010111011010'; '111010111011011'; '111010111011101'; '111010111011110'; '111010111011111'; '111010111101010'; '111010111101011'; '111010111101101'; '111010111101110'; '111010111101111'; '111010111110101'; '111010111110110'; '111010111110111'; '111010111111010'; '111010111111011'; '111010111111101'; '111010111111110'; '111010111111111'; '111011010101010'; '111011010101011'; '111011010101101'; '111011010101110'; '111011010101111'; '111011010110101'; '111011010110110'; '111011010110111'; '111011010111010'; '111011010111011'; '111011010111101'; '111011010111110'; '111011010111111'; '111011011010101'; '111011011010110'; '111011011010111'; '111011011011010'; '111011011011011'; '111011011011101'; '111011011011110'; '111011011011111'; '111011011101010'; '111011011101011'; '111011011101101'; '111011011101110'; '111011011101111'; '111011011110101'; '111011011110110'; '111011011110111'; '111011011111010'; '111011011111011'; '111011011111101'; '111011011111110'; '111011011111111'; '111011101010101'; '111011101010110'; '111011101010111'; '111011101011010'; '111011101011011'; '111011101011101'; '111011101011110'; '111011101011111'; '111011101101010'; '111011101101011'; '111011101101101'; '111011101101110'; '111011101101111'; '111011101110101'; '111011101110110'; '111011101110111'; '111011101111010'; '111011101111011'; '111011101111101'; '111011101111110'; '111011101111111'; '111011110101010'; '111011110101011'; '111011110101101'; '111011110101110'; '111011110101111'; '111011110110101'; '111011110110110'; '111011110110111'; '111011110111010'; '111011110111011'; '111011110111101'; '111011110111110'; '111011110111111'; '111011111010101'; '111011111010110'; '111011111010111'; '111011111011010'; '111011111011011'; '111011111011101'; '111011111011110'; '111011111011111'; '111011111101010'; '111011111101011'; '111011111101101'; '111011111101110'; '111011111101111'; '111011111110101'; '111011111110110'; '111011111110111'; '111011111111010'; '111011111111011'; '111011111111101'; '111011111111110'; '111011111111111'; '111101010101010'; '111101010101011'; '111101010101101'; '111101010101110'; '111101010101111'; '111101010110101'; '111101010110110'; '111101010110111'; '111101010111010'; '111101010111011'; '111101010111101'; '111101010111110'; '111101010111111'; '111101011010101'; '111101011010110'; '111101011010111'; '111101011011010'; '111101011011011'; '111101011011101'; '111101011011110'; '111101011011111'; '111101011101010'; '111101011101011'; '111101011101101'; '111101011101110'; '111101011101111'; '111101011110101'; '111101011110110'; '111101011110111'; '111101011111010'; '111101011111011'; '111101011111101'; '111101011111110'; '111101011111111'; '111101101010101'; '111101101010110'; '111101101010111'; '111101101011010'; '111101101011011'; '111101101011101'; '111101101011110'; '111101101011111'; '111101101101010'; '111101101101011'; '111101101101101'; '111101101101110'; '111101101101111'; '111101101110101'; '111101101110110'; '111101101110111'; '111101101111010'; '111101101111011'; '111101101111101'; '111101101111110'; '111101101111111'; '111101110101010'; '111101110101011'; '111101110101101'; '111101110101110'; '111101110101111'; '111101110110101'; '111101110110110'; '111101110110111'; '111101110111010'; '111101110111011'; '111101110111101'; '111101110111110'; '111101110111111'; '111101111010101'; '111101111010110'; '111101111010111'; '111101111011010'; '111101111011011'; '111101111011101'; '111101111011110'; '111101111011111'; '111101111101010'; '111101111101011'; '111101111101101'; '111101111101110'; '111101111101111'; '111101111110101'; '111101111110110'; '111101111110111'; '111101111111010'; '111101111111011'; '111101111111101'; '111101111111110'; '111101111111111'; '111110101010101'; '111110101010110'; '111110101010111'; '111110101011010'; '111110101011011'; '111110101011101'; '111110101011110'; '111110101011111'; '111110101101010'; '111110101101011'; '111110101101101'; '111110101101110'; '111110101101111'; '111110101110101'; '111110101110110'; '111110101110111'; '111110101111010'; '111110101111011'; '111110101111101'; '111110101111110'; '111110101111111'; '111110110101010'; '111110110101011'; '111110110101101'; '111110110101110'; '111110110101111'; '111110110110101'; '111110110110110'; '111110110110111'; '111110110111010'; '111110110111011'; '111110110111101'; '111110110111110'; '111110110111111'; '111110111010101'; '111110111010110'; '111110111010111'; '111110111011010'; '111110111011011'; '111110111011101'; '111110111011110'; '111110111011111'; '111110111101010'; '111110111101011'; '111110111101101'; '111110111101110'; '111110111101111'; '111110111110101'; '111110111110110'; '111110111110111'; '111110111111010'; '111110111111011'; '111110111111101'; '111110111111110'; '111110111111111'; '111111010101010'; '111111010101011'; '111111010101101'; '111111010101110'; '111111010101111'; '111111010110101'; '111111010110110'; '111111010110111'; '111111010111010'; '111111010111011'; '111111010111101'; '111111010111110'; '111111010111111'; '111111011010101'; '111111011010110'; '111111011010111'; '111111011011010'; '111111011011011'; '111111011011101'; '111111011011110'; '111111011011111'; '111111011101010'; '111111011101011'; '111111011101101'; '111111011101110'; '111111011101111'; '111111011110101'; '111111011110110'; '111111011110111'; '111111011111010'; '111111011111011'; '111111011111101'; '111111011111110'; '111111011111111'; '111111101010101'; '111111101010110'; '111111101010111'; '111111101011010'; '111111101011011'; '111111101011101'; '111111101011110'; '111111101011111'; '111111101101010'; '111111101101011'; '111111101101101'; '111111101101110'; '111111101101111'; '111111101110101'; '111111101110110'; '111111101110111'; '111111101111010'; '111111101111011'; '111111101111101'; '111111101111110'; '111111101111111'; '111111110101010'; '111111110101011'; '111111110101101'; '111111110101110'; '111111110101111'; '111111110110101'; '111111110110110'; '111111110110111'; '111111110111010'; '111111110111011'; '111111110111101'; '111111110111110'; '111111110111111'; '111111111010101'; '111111111010110'; '111111111010111'; '111111111011010'; '111111111011011'; '111111111011101'; '111111111011110'; '111111111011111'; '111111111101010'; '111111111101011'; '111111111101101'; '111111111101110'; '111111111101111'; '111111111110101'; '111111111110110'; '111111111110111'; '111111111111010'; '111111111111011'; '111111111111101'; '111111111111110'; '111111111111111']);
  assert (valid_strings 4 = ['0101'; '0110'; '0111'; '1010'; '1011'; '1101'; '1110'; '1111']);
  assert (valid_strings 18 = Execution timed out);
  assert (valid_strings 2 = ['01'; '10'; '11']);
  assert (valid_strings 1 = ['0'; '1']);
  assert (valid_strings 10 = ['0101010101'; '0101010110'; '0101010111'; '0101011010'; '0101011011'; '0101011101'; '0101011110'; '0101011111'; '0101101010'; '0101101011'; '0101101101'; '0101101110'; '0101101111'; '0101110101'; '0101110110'; '0101110111'; '0101111010'; '0101111011'; '0101111101'; '0101111110'; '0101111111'; '0110101010'; '0110101011'; '0110101101'; '0110101110'; '0110101111'; '0110110101'; '0110110110'; '0110110111'; '0110111010'; '0110111011'; '0110111101'; '0110111110'; '0110111111'; '0111010101'; '0111010110'; '0111010111'; '0111011010'; '0111011011'; '0111011101'; '0111011110'; '0111011111'; '0111101010'; '0111101011'; '0111101101'; '0111101110'; '0111101111'; '0111110101'; '0111110110'; '0111110111'; '0111111010'; '0111111011'; '0111111101'; '0111111110'; '0111111111'; '1010101010'; '1010101011'; '1010101101'; '1010101110'; '1010101111'; '1010110101'; '1010110110'; '1010110111'; '1010111010'; '1010111011'; '1010111101'; '1010111110'; '1010111111'; '1011010101'; '1011010110'; '1011010111'; '1011011010'; '1011011011'; '1011011101'; '1011011110'; '1011011111'; '1011101010'; '1011101011'; '1011101101'; '1011101110'; '1011101111'; '1011110101'; '1011110110'; '1011110111'; '1011111010'; '1011111011'; '1011111101'; '1011111110'; '1011111111'; '1101010101'; '1101010110'; '1101010111'; '1101011010'; '1101011011'; '1101011101'; '1101011110'; '1101011111'; '1101101010'; '1101101011'; '1101101101'; '1101101110'; '1101101111'; '1101110101'; '1101110110'; '1101110111'; '1101111010'; '1101111011'; '1101111101'; '1101111110'; '1101111111'; '1110101010'; '1110101011'; '1110101101'; '1110101110'; '1110101111'; '1110110101'; '1110110110'; '1110110111'; '1110111010'; '1110111011'; '1110111101'; '1110111110'; '1110111111'; '1111010101'; '1111010110'; '1111010111'; '1111011010'; '1111011011'; '1111011101'; '1111011110'; '1111011111'; '1111101010'; '1111101011'; '1111101101'; '1111101110'; '1111101111'; '1111110101'; '1111110110'; '1111110111'; '1111111010'; '1111111011'; '1111111101'; '1111111110'; '1111111111']);
;;","medium","medium_108","medium"
"(**You are given a 0-indexed array nums and a non-negative integer k.
 * >>> maximum_beauty [7; 7; 7; 7; 7; 7; 7; 7; 7; 7] 3
 * 10
 * >>> maximum_beauty [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 1
 * 3
 * >>> maximum_beauty [10; 20; 30; 40; 50] 15
 * 4
*)
let maximum_beauty (nums : int list) (k : int) : int =","  0","let () =
  assert (maximum_beauty [7; 7; 7; 7; 7; 7; 7; 7; 7; 7] 3 = 10);
  assert (maximum_beauty [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 1 = 3);
  assert (maximum_beauty [10; 20; 30; 40; 50] 15 = 4);
  assert (maximum_beauty [5; 15; 25; 35] 5 = 2);
  assert (maximum_beauty [100; 100; 100] 5 = 3);
  assert (maximum_beauty [100; 200; 300; 400; 500] 0 = 1);
  assert (maximum_beauty [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 5 = 10);
;;","medium","medium_010","medium"
"(**You are given the root of a binary tree that consists of exactly 3 nodes: the root, its left chil...
 * >>> check_tree [1; -1; 2]
 * true
 * >>> check_tree [-5; -3; -2]
 * true
 * >>> check_tree [5; 3; 1]
 * false
*)
let check_tree (root : 'a option) : bool =","  false","let () =
  assert (check_tree [1; -1; 2] = true);
  assert (check_tree [-5; -3; -2] = true);
  assert (check_tree [5; 3; 1] = false);
  assert (check_tree [99; 50; 49] = true);
  assert (check_tree [-100; 50; 50] = false);
  assert (check_tree [100; -50; 150] = true);
  assert (check_tree [1; 0; 1] = true);
;;","easy","easy_183","easy"
"(**Write an algorithm to determine if a number n is happy.
 * >>> is_happy 100
 * true
 * >>> is_happy 4
 * false
 * >>> is_happy 20
 * false
*)
let is_happy (n : int) : bool =","  false","let () =
  assert (is_happy 100 = true);
  assert (is_happy 4 = false);
  assert (is_happy 20 = false);
  assert (is_happy 2 = false);
  assert (is_happy 1111111 = true);
  assert (is_happy 19 = true);
  assert (is_happy 1 = true);
;;","easy","easy_166","easy"
"(**In a string s of lowercase letters, these letters form consecutive groups of the same character.
 * >>> large_group_positions ""aabbbccccdddd""
 * [[2; 4]; [5; 8]; [9; 12]]
 * >>> large_group_positions ""aabbbccccddeee""
 * [[2; 4]; [5; 8]; [11; 13]]
 * >>> large_group_positions ""abcdefghijk""
 * []
*)
let large_group_positions (s : string) : int list list =","  [[]]","let () =
  assert (large_group_positions ""aabbbccccdddd"" = [[2; 4]; [5; 8]; [9; 12]]);
  assert (large_group_positions ""aabbbccccddeee"" = [[2; 4]; [5; 8]; [11; 13]]);
  assert (large_group_positions ""abcdefghijk"" = []);
  assert (large_group_positions ""aabbaa"" = []);
  assert (large_group_positions ""aabbccccaaaabbccccaaaabbcccc"" = [[4; 7]; [8; 11]; [14; 17]; [18; 21]; [24; 27]]);
  assert (large_group_positions ""a"" = []);
  assert (large_group_positions ""abbxxxxzzy"" = [[3; 6]]);
;;","easy","easy_122","easy"
"(**The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers...
 * >>> count_students [0; 1; 0; 1] [1; 0; 1; 0]
 * 0
 * >>> count_students [1; 1; 1; 0; 0; 1] [1; 0; 0; 0; 1; 1]
 * 3
 * >>> count_students [0; 0; 1; 1] [1; 1; 0; 0]
 * 0
*)
let count_students (students : int list) (sandwiches : int list) : int =","  0","let () =
  assert (count_students [0; 1; 0; 1] [1; 0; 1; 0] = 0);
  assert (count_students [1; 1; 1; 0; 0; 1] [1; 0; 0; 0; 1; 1] = 3);
  assert (count_students [0; 0; 1; 1] [1; 1; 0; 0] = 0);
  assert (count_students [1; 0; 1; 0] [0; 1; 0; 1] = 0);
  assert (count_students [0; 0; 0; 0] [0; 0; 0; 0] = 0);
  assert (count_students [0; 1; 0; 1] [0; 1; 0; 1] = 0);
  assert (count_students [1; 1; 0; 0] [0; 1; 0; 1] = 0);
;;","easy","easy_177","easy"
"(**Given an array of unique integers preorder, return true if it is the correct preorder traversal s...
 * >>> verify_preorder [5; 2; 6; 1; 3]
 * false
 * >>> verify_preorder [1; 3; 2]
 * true
 * >>> verify_preorder [1]
 * true
*)
let verify_preorder (preorder : int list) : bool =","  false","let () =
  assert (verify_preorder [5; 2; 6; 1; 3] = false);
  assert (verify_preorder [1; 3; 2] = true);
  assert (verify_preorder [1] = true);
  assert (verify_preorder [8; 5; 1; 7; 10; 12] = true);
  assert (verify_preorder [1; 2; 3; 4; 5] = true);
  assert (verify_preorder [5; 4; 3; 2; 1] = true);
  assert (verify_preorder [5; 2; 1; 3; 6] = true);
;;","medium","medium_047","medium"
"(**You are given a 0-indexed 2D integer array grid of size m x n. Each cell has one of two values:
 * >>> minimum_obstacles [[0; 1]; [1; 0]]
 * 1
 * >>> minimum_obstacles [[0; 0; 0]; [0; 1; 0]; [0; 0; 0]]
 * 0
 * >>> minimum_obstacles [[0; 1; 1; 1]; [1; 1; 1; 1]; [1; 1; 1; 0]]
 * 4
*)
let minimum_obstacles (grid : int list list) : int =","  0","let () =
  assert (minimum_obstacles [[0; 1]; [1; 0]] = 1);
  assert (minimum_obstacles [[0; 0; 0]; [0; 1; 0]; [0; 0; 0]] = 0);
  assert (minimum_obstacles [[0; 1; 1; 1]; [1; 1; 1; 1]; [1; 1; 1; 0]] = 4);
  assert (minimum_obstacles [[0; 1; 1; 0]; [1; 1; 1; 0]; [1; 1; 1; 0]; [0; 0; 0; 0]] = 2);
  assert (minimum_obstacles [[0; 1; 0; 0; 0]; [0; 1; 0; 1; 0]; [0; 0; 0; 1; 0]] = 0);
  assert (minimum_obstacles [[0; 1; 1]; [1; 1; 0]; [1; 1; 0]] = 2);
  assert (minimum_obstacles [[0; 0; 1; 0; 0; 0]; [0; 1; 1; 1; 1; 0]; [0; 0; 1; 0; 0; 0]; [0; 1; 1; 1; 1; 0]; [0; 0; 0; 0; 1; 0]] = 1);
;;","hard","hard_081","hard"
"(**A city is represented as a bi-directional connected graph with n vertices where each vertex is la...
 * >>> second_minimum 2 [[1; 2]] 3 2
 * 11
 * >>> second_minimum 3 [[1; 2]; [2; 3]] 2 3
 * 10
 * >>> second_minimum 3 [[1; 2]; [2; 3]] 5 5
 * 35
*)
let second_minimum (n : int) (edges : int list list) (time : int) (change : int) : int =","  0","let () =
  assert (second_minimum 2 [[1; 2]] 3 2 = 11);
  assert (second_minimum 3 [[1; 2]; [2; 3]] 2 3 = 10);
  assert (second_minimum 3 [[1; 2]; [2; 3]] 5 5 = 35);
  assert (second_minimum 6 [[1; 2]; [1; 3]; [1; 4]; [2; 5]; [3; 5]; [4; 5]; [5; 6]] 2 4 = 18);
  assert (second_minimum 4 [[1; 2]; [2; 3]; [3; 4]; [1; 4]] 2 3 = 8);
  assert (second_minimum 4 [[1; 2]; [1; 3]; [3; 4]; [2; 4]] 2 3 = 10);
  assert (second_minimum 6 [[1; 2]; [1; 3]; [2; 4]; [2; 5]; [3; 5]; [4; 6]; [5; 6]] 4 7 = 32);
;;","hard","hard_009","hard"
"(**You are given an empty 2D binary grid grid of size m x n. The grid represents a map where 0's rep...
 * >>> num_islands2 5 5 [[0; 0]; [4; 4]; [2; 2]; [3; 3]; [1; 1]]
 * [1; 2; 3; 4; 5]
 * >>> num_islands2 4 4 [[0; 0]; [0; 1]; [1; 0]; [1; 1]; [2; 2]; [2; 3]; [3; 2]; [3; 3]]
 * [1; 1; 1; 1; 2; 2; 2; 2]
 * >>> num_islands2 5 4 [[0; 0]; [4; 3]; [3; 3]; [3; 2]; [2; 1]; [1; 0]; [2; 0]; [3; 0]; [4; 0]; [0; 3]]
 * [1; 2; 2; 2; 3; 3; 2; 2; 2; 3]
*)
let num_islands2 (m : int) (n : int) (positions : int list list) : int list =","  []","let () =
  assert (num_islands2 5 5 [[0; 0]; [4; 4]; [2; 2]; [3; 3]; [1; 1]] = [1; 2; 3; 4; 5]);
  assert (num_islands2 4 4 [[0; 0]; [0; 1]; [1; 0]; [1; 1]; [2; 2]; [2; 3]; [3; 2]; [3; 3]] = [1; 1; 1; 1; 2; 2; 2; 2]);
  assert (num_islands2 5 4 [[0; 0]; [4; 3]; [3; 3]; [3; 2]; [2; 1]; [1; 0]; [2; 0]; [3; 0]; [4; 0]; [0; 3]] = [1; 2; 2; 2; 3; 3; 2; 2; 2; 3]);
  assert (num_islands2 3 3 [[0; 0]; [0; 1]; [0; 2]; [1; 0]; [1; 1]; [1; 2]; [2; 0]; [2; 1]; [2; 2]] = [1; 1; 1; 1; 1; 1; 1; 1; 1]);
  assert (num_islands2 2 2 [[0; 0]; [1; 1]; [0; 1]; [1; 0]] = [1; 2; 1; 1]);
  assert (num_islands2 4 5 [[0; 0]; [0; 1]; [1; 1]; [1; 0]; [2; 2]; [2; 1]; [2; 0]; [3; 3]] = [1; 1; 1; 1; 2; 1; 1; 2]);
  assert (num_islands2 3 3 [[0; 0]; [0; 1]; [1; 0]; [1; 1]] = [1; 1; 1; 1]);
;;","hard","hard_067","hard"
"(**You are given a sorted unique integer array nums.
 * >>> summary_ranges [0; 1; 2; 3; 4; 5]
 * ['0->5']
 * >>> summary_ranges [-1; 0; 1; 2; 3; 5; 6; 7; 8; 10]
 * ['-1->3'; '5->8'; '10']
 * >>> summary_ranges [-2147483648; -2147483647; -2147483646]
 * ['-2147483648->-2147483646']
*)
let summary_ranges (nums : int list) : string list =","  []","let () =
  assert (summary_ranges [0; 1; 2; 3; 4; 5] = ['0->5']);
  assert (summary_ranges [-1; 0; 1; 2; 3; 5; 6; 7; 8; 10] = ['-1->3'; '5->8'; '10']);
  assert (summary_ranges [-2147483648; -2147483647; -2147483646] = ['-2147483648->-2147483646']);
  assert (summary_ranges [1; 3; 5; 7; 9] = ['1'; '3'; '5'; '7'; '9']);
  assert (summary_ranges [5; 6; 7; 9; 10; 11; 13; 14; 15; 16] = ['5->7'; '9->11'; '13->16']);
  assert (summary_ranges [1] = ['1']);
  assert (summary_ranges [-2; -1; 0; 1; 3; 4; 6; 8] = ['-2->1'; '3->4'; '6'; '8']);
;;","easy","easy_105","easy"
"(**There are n employees in a company, numbered from 0 to n - 1. Each employee i has worked for hour...
 * >>> number_of_employees_who_met_target [5; 5; 5; 5; 5] 5
 * 5
 * >>> number_of_employees_who_met_target [3; 4; 5; 6; 7] 4
 * 4
 * >>> number_of_employees_who_met_target [1; 5; 7; 9] 8
 * 1
*)
let number_of_employees_who_met_target (hours : int list) (target : int) : int =","  0","let () =
  assert (number_of_employees_who_met_target [5; 5; 5; 5; 5] 5 = 5);
  assert (number_of_employees_who_met_target [3; 4; 5; 6; 7] 4 = 4);
  assert (number_of_employees_who_met_target [1; 5; 7; 9] 8 = 1);
  assert (number_of_employees_who_met_target [10; 10; 10] 10 = 3);
  assert (number_of_employees_who_met_target [0; 1; 2; 3; 4] 2 = 3);
  assert (number_of_employees_who_met_target [10; 20; 30; 40; 50] 25 = 3);
  assert (number_of_employees_who_met_target [50; 50; 50; 50; 50] 50 = 5);
;;","easy","easy_185","easy"
"(**Given an integer array nums and an integer k, return true if nums has a good subarray or false ot...
 * >>> check_subarray_sum [2; 5; 31; 4; 5; 1] 5
 * true
 * >>> check_subarray_sum [1; 2; 3; 4; 5] 9
 * true
 * >>> check_subarray_sum [23; 2; 6; 4; 7] 6
 * true
*)
let check_subarray_sum (nums : int list) (k : int) : bool =","  false","let () =
  assert (check_subarray_sum [2; 5; 31; 4; 5; 1] 5 = true);
  assert (check_subarray_sum [1; 2; 3; 4; 5] 9 = true);
  assert (check_subarray_sum [23; 2; 6; 4; 7] 6 = true);
  assert (check_subarray_sum [2; 5; 4; 5; 10] 3 = true);
  assert (check_subarray_sum [1; 0; 1; 0; 1] 2 = true);
  assert (check_subarray_sum [23; 2; 4; 6; 7] 6 = true);
  assert (check_subarray_sum [1; 2; 3; 4; 5; 6] 10 = true);
;;","medium","medium_111","medium"
"(**Given a positive integer n, you can apply one of the following operations:
 * >>> integer_replacement 8
 * 3
 * >>> integer_replacement 15
 * 5
 * >>> integer_replacement 4
 * 2
*)
let integer_replacement (n : int) : int =","  0","let () =
  assert (integer_replacement 8 = 3);
  assert (integer_replacement 15 = 5);
  assert (integer_replacement 4 = 2);
  assert (integer_replacement 2147483647 = 32);
  assert (integer_replacement 1 = 0);
  assert (integer_replacement 1000000000 = 38);
  assert (integer_replacement 7 = 4);
;;","medium","medium_182","medium"
"(**You are given an array nums of positive integers and an integer k.
 * >>> min_operations [2; 1; 2; 1; 2] 2
 * 2
 * >>> min_operations [2; 3; 1; 4; 5] 4
 * 5
 * >>> min_operations [3; 1; 5; 4; 2] 5
 * 5
*)
let min_operations (nums : int list) (k : int) : int =","  0","let () =
  assert (min_operations [2; 1; 2; 1; 2] 2 = 2);
  assert (min_operations [2; 3; 1; 4; 5] 4 = 5);
  assert (min_operations [3; 1; 5; 4; 2] 5 = 5);
  assert (min_operations [4; 3; 2; 1; 5] 5 = 5);
  assert (min_operations [2; 4; 6; 8; 10] 3 = None);
  assert (min_operations [1; 2; 2; 3; 3] 3 = 5);
  assert (min_operations [1; 2; 3; 4; 5] 3 = 5);
;;","easy","easy_049","easy"
"(**You have a cubic storeroom where the width, length, and height of the room are all equal to n uni...
 * >>> minimum_boxes 8
 * 6
 * >>> minimum_boxes 3
 * 3
 * >>> minimum_boxes 100
 * 34
*)
let minimum_boxes (n : int) : int =","  0","let () =
  assert (minimum_boxes 8 = 6);
  assert (minimum_boxes 3 = 3);
  assert (minimum_boxes 100 = 34);
  assert (minimum_boxes 15 = 9);
  assert (minimum_boxes 4 = 3);
  assert (minimum_boxes 1000000 = 16443);
  assert (minimum_boxes 20 = 10);
;;","hard","hard_090","hard"
"(**You are given an integer array nums. In one operation, you can replace any element in nums with a...
 * >>> min_operations [10; 10; 10; 10]
 * 3
 * >>> min_operations [4; 2; 5; 3]
 * 0
 * >>> min_operations [10; 9; 8; 7; 6; 5; 4; 3; 2; 1]
 * 0
*)
let min_operations (nums : int list) : int =","  0","let () =
  assert (min_operations [10; 10; 10; 10] = 3);
  assert (min_operations [4; 2; 5; 3] = 0);
  assert (min_operations [10; 9; 8; 7; 6; 5; 4; 3; 2; 1] = 0);
  assert (min_operations [9; 8; 7; 6; 5; 4; 3; 2; 1] = 0);
  assert (min_operations [1; 2; 2; 2; 3; 4; 5] = 2);
  assert (min_operations [5; 6; 7; 8; 9; 1] = 1);
  assert (min_operations [1; 3; 5; 7; 9] = 2);
;;","hard","hard_046","hard"
"(**There are n balls on a table, each ball has a color black or white.
 * >>> minimum_steps ""110100""
 * 8
 * >>> minimum_steps ""1111""
 * 0
 * >>> minimum_steps ""100100101""
 * 9
*)
let minimum_steps (s : string) : int =","  0","let () =
  assert (minimum_steps ""110100"" = 8);
  assert (minimum_steps ""1111"" = 0);
  assert (minimum_steps ""100100101"" = 9);
  assert (minimum_steps ""110011"" = 4);
  assert (minimum_steps ""00110011"" = 4);
  assert (minimum_steps ""11110000"" = 16);
  assert (minimum_steps ""0000"" = 0);
;;","medium","medium_117","medium"
"(**Seven different symbols represent Roman numerals with the following values:
 * >>> int_to_roman 44
 * XLIV
 * >>> int_to_roman 9
 * IX
 * >>> int_to_roman 4
 * IV
*)
let int_to_roman (num : int) : string =","  """"","let () =
  assert (int_to_roman 44 = XLIV);
  assert (int_to_roman 9 = IX);
  assert (int_to_roman 4 = IV);
  assert (int_to_roman 2023 = MMXXIII);
  assert (int_to_roman 589 = DLXXXIX);
  assert (int_to_roman 444 = CDXLIV);
  assert (int_to_roman 1000 = M);
;;","medium","medium_186","medium"
"(**Given the string s, return the size of the longest substring containing each vowel an even number...
 * >>> find_the_longest_substring ""bcbcbc""
 * 6
 * >>> find_the_longest_substring ""cbacdcdcdbacdbad""
 * 14
 * >>> find_the_longest_substring ""aeiouaeiouaeiouaeiou""
 * 20
*)
let find_the_longest_substring (s : string) : int =","  0","let () =
  assert (find_the_longest_substring ""bcbcbc"" = 6);
  assert (find_the_longest_substring ""cbacdcdcdbacdbad"" = 14);
  assert (find_the_longest_substring ""aeiouaeiouaeiouaeiou"" = 20);
  assert (find_the_longest_substring ""aaaaaeeeeeiioooouuuu"" = 14);
  assert (find_the_longest_substring ""abcdefghijklmnopqrstuvwxyz"" = 5);
  assert (find_the_longest_substring ""uuuuuuuuuuuuuuuuuuuuuuuuuuu"" = 26);
  assert (find_the_longest_substring ""aaeeiioouu"" = 10);
;;","medium","medium_154","medium"
"(**You are given two integers n and k.
 * >>> value_after_kseconds 7 4
 * 210
 * >>> value_after_kseconds 2 4
 * 5
 * >>> value_after_kseconds 2 5
 * 6
*)
let value_after_kseconds (n : int) (k : int) : int =","  0","let () =
  assert (value_after_kseconds 7 4 = 210);
  assert (value_after_kseconds 2 4 = 5);
  assert (value_after_kseconds 2 5 = 6);
  assert (value_after_kseconds 8 4 = 330);
  assert (value_after_kseconds 2 1 = 2);
  assert (value_after_kseconds 1 1 = 1);
  assert (value_after_kseconds 3 2 = 6);
;;","medium","medium_159","medium"
"(**You have a pointer at index 0 in an array of size arrLen. At each step, you can move 1 position t...
 * >>> num_ways 5 3
 * 21
 * >>> num_ways 10 5
 * 2187
 * >>> num_ways 5 5
 * 21
*)
let num_ways (steps : int) (arrLen : int) : int =","  0","let () =
  assert (num_ways 5 3 = 21);
  assert (num_ways 10 5 = 2187);
  assert (num_ways 5 5 = 21);
  assert (num_ways 2 4 = 2);
  assert (num_ways 3 2 = 4);
  assert (num_ways 10 1 = 1);
  assert (num_ways 10 3 = 1682);
;;","hard","hard_010","hard"
"(**Given a fixed-length integer array arr, duplicate each occurrence of zero, shifting the remaining...
 * >>> duplicate_zeros [8; 4; 5; 0; 0; 0; 0; 7]
 * None
 * >>> duplicate_zeros [0; 1; 0; 3; 0; 0; 0; 4]
 * None
 * >>> duplicate_zeros [0; 1; 2; 3; 4; 5; 6; 7]
 * None
*)
let duplicate_zeros (arr : int list) : unit =","  failwith ""Not implemented""","let () =
  assert (duplicate_zeros [8; 4; 5; 0; 0; 0; 0; 7] = None);
  assert (duplicate_zeros [0; 1; 0; 3; 0; 0; 0; 4] = None);
  assert (duplicate_zeros [0; 1; 2; 3; 4; 5; 6; 7] = None);
  assert (duplicate_zeros [9; 8; 7; 6; 5] = None);
  assert (duplicate_zeros [0; 1; 0; 2; 0; 3; 0; 4] = None);
  assert (duplicate_zeros [1; 0; 2; 3; 0; 4; 5; 0] = None);
  assert (duplicate_zeros [1; 2; 3] = None);
;;","easy","easy_088","easy"
"(**Given two strings first and second, consider occurrences in some text of the form ""first second t...
 * >>> find_ocurrences ""hello world hello hello world"" ""hello"" ""world""
 * ['hello']
 * >>> find_ocurrences ""repeat repeat repeat repeat"" ""repeat"" ""repeat""
 * ['repeat'; 'repeat']
 * >>> find_ocurrences ""look at the stars look at the moon"" ""look"" ""at""
 * ['the'; 'the']
*)
let find_ocurrences (text : string) (first : string) (second : string) : string list =","  []","let () =
  assert (find_ocurrences ""hello world hello hello world"" ""hello"" ""world"" = ['hello']);
  assert (find_ocurrences ""repeat repeat repeat repeat"" ""repeat"" ""repeat"" = ['repeat'; 'repeat']);
  assert (find_ocurrences ""look at the stars look at the moon"" ""look"" ""at"" = ['the'; 'the']);
  assert (find_ocurrences ""in the beginning there was the word"" ""the"" ""beginning"" = ['there']);
  assert (find_ocurrences ""this is a test this is only a test"" ""this"" ""is"" = ['a'; 'only']);
  assert (find_ocurrences ""one two three two three four three five"" ""two"" ""three"" = ['two'; 'four']);
  assert (find_ocurrences ""every good boy does fine every good boy does fine"" ""good"" ""boy"" = ['does'; 'does']);
;;","easy","easy_067","easy"
"(**The demons had captured the princess and imprisoned her in the bottom-right corner of a dungeon. ...
 * >>> calculate_minimum_hp [[1; -3; 3]; [0; -2; 0]; [-3; -3; -3]]
 * 3
 * >>> calculate_minimum_hp [[-5; -4; -6]; [-6; -5; -8]; [3; 3; 1]]
 * 12
 * >>> calculate_minimum_hp [[-2; -3; 3]; [-5; -10; 1]; [10; 30; -5]]
 * 7
*)
let calculate_minimum_hp (dungeon : int list list) : int =","  0","let () =
  assert (calculate_minimum_hp [[1; -3; 3]; [0; -2; 0]; [-3; -3; -3]] = 3);
  assert (calculate_minimum_hp [[-5; -4; -6]; [-6; -5; -8]; [3; 3; 1]] = 12);
  assert (calculate_minimum_hp [[-2; -3; 3]; [-5; -10; 1]; [10; 30; -5]] = 7);
  assert (calculate_minimum_hp [[0; 0; 0]; [0; 0; 0]; [0; 0; 0]] = 1);
  assert (calculate_minimum_hp [[1; 6; 7; -6; 5; 3]; [4; -8; -5; 5; -9; 3]; [-3; 1; -2; 6; -6; 2]; [-8; -6; -3; -8; -9; -5]; [-5; -8; -8; -1; 5; -9]] = 1);
  assert (calculate_minimum_hp [[-2; -1]; [-1; 10]] = 4);
  assert (calculate_minimum_hp [[0]] = 1);
;;","hard","hard_051","hard"
"(**You are given a network of n nodes represented as an n x n adjacency matrix graph, where the ith ...
 * >>> min_malware_spread [[1; 1; 1; 1]; [1; 1; 0; 0]; [1; 0; 1; 1]; [1; 0; 1; 1]] [0; 1; 2; 3]
 * 0
 * >>> min_malware_spread [[1; 1; 0; 0]; [1; 1; 1; 0]; [0; 1; 1; 1]; [0; 0; 1; 1]] [0; 1]
 * 0
 * >>> min_malware_spread [[1; 1; 0; 0]; [1; 1; 0; 0]; [0; 0; 1; 1]; [0; 0; 1; 1]] [0; 2]
 * 0
*)
let min_malware_spread (graph : int list list) (initial : int list) : int =","  0","let () =
  assert (min_malware_spread [[1; 1; 1; 1]; [1; 1; 0; 0]; [1; 0; 1; 1]; [1; 0; 1; 1]] [0; 1; 2; 3] = 0);
  assert (min_malware_spread [[1; 1; 0; 0]; [1; 1; 1; 0]; [0; 1; 1; 1]; [0; 0; 1; 1]] [0; 1] = 0);
  assert (min_malware_spread [[1; 1; 0; 0]; [1; 1; 0; 0]; [0; 0; 1; 1]; [0; 0; 1; 1]] [0; 2] = 0);
  assert (min_malware_spread [[1; 0; 0; 0]; [0; 1; 0; 0]; [0; 0; 1; 1]; [0; 0; 1; 1]] [2; 3] = 2);
  assert (min_malware_spread [[1; 1; 0]; [1; 1; 0]; [0; 0; 1]] [0; 1] = 0);
  assert (min_malware_spread [[1; 1; 1; 0]; [1; 1; 1; 0]; [1; 1; 1; 1]; [0; 0; 1; 1]] [0; 1; 3] = 0);
  assert (min_malware_spread [[1; 0; 0; 0]; [0; 1; 1; 1]; [0; 1; 1; 1]; [0; 1; 1; 1]] [1; 2] = 1);
;;","hard","hard_016","hard"
"(**Given an array perm of length n which is a permutation of [1, 2, ..., n], return the index of per...
 * >>> get_permutation_index [3; 1; 2]
 * 4
 * >>> get_permutation_index [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
 * 0
 * >>> get_permutation_index [4; 3; 2; 1]
 * 23
*)
let get_permutation_index (perm : int list) : int =","  0","let () =
  assert (get_permutation_index [3; 1; 2] = 4);
  assert (get_permutation_index [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = 0);
  assert (get_permutation_index [4; 3; 2; 1] = 23);
  assert (get_permutation_index [5; 3; 1; 2; 4] = 108);
  assert (get_permutation_index [4; 1; 3; 2; 5] = 74);
  assert (get_permutation_index [1; 2; 3; 4; 5] = 0);
  assert (get_permutation_index [1; 3; 2] = 1);
;;","medium","medium_065","medium"
"(**You are given a string array words, and an array groups, both arrays having length n.
 * >>> get_words_in_longest_subsequence [""abc""; ""bac""; ""bca""; ""cab""; ""cba""; ""acb""] [1; 2; 1; 2; 1; 2]
 * ['abc']
 * >>> get_words_in_longest_subsequence [""same""; ""sane""; ""same""] [1; 2; 1]
 * ['same'; 'sane'; 'same']
 * >>> get_words_in_longest_subsequence [""test""; ""tast""; ""best""; ""rest""] [1; 2; 2; 3]
 * ['test'; 'best'; 'rest']
*)
let get_words_in_longest_subsequence (words : string list) (groups : int list) : string list =","  []","let () =
  assert (get_words_in_longest_subsequence [""abc""; ""bac""; ""bca""; ""cab""; ""cba""; ""acb""] [1; 2; 1; 2; 1; 2] = ['abc']);
  assert (get_words_in_longest_subsequence [""same""; ""sane""; ""same""] [1; 2; 1] = ['same'; 'sane'; 'same']);
  assert (get_words_in_longest_subsequence [""test""; ""tast""; ""best""; ""rest""] [1; 2; 2; 3] = ['test'; 'best'; 'rest']);
  assert (get_words_in_longest_subsequence [""hello""; ""hallo""; ""hxllo""; ""hexlo""] [1; 2; 2; 3] = ['hello'; 'hallo']);
  assert (get_words_in_longest_subsequence [""abcd""; ""abcf""; ""abgf""; ""abgh""] [1; 2; 2; 3] = ['abcd'; 'abcf']);
  assert (get_words_in_longest_subsequence [""hello""; ""hallo""; ""hbllo""; ""hillo""] [1; 1; 2; 3] = ['hello'; 'hbllo'; 'hillo']);
  assert (get_words_in_longest_subsequence [""bab""; ""dab""; ""cab""] [1; 2; 2] = ['bab'; 'dab']);
;;","medium","medium_155","medium"
"(**You are given a string s consisting of lowercase English letters, and an integer k. Your task is ...
 * >>> get_lucky ""zzzz"" 1
 * 32
 * >>> get_lucky ""zzz"" 10
 * 6
 * >>> get_lucky ""programming"" 1
 * 68
*)
let get_lucky (s : string) (k : int) : int =","  0","let () =
  assert (get_lucky ""zzzz"" 1 = 32);
  assert (get_lucky ""zzz"" 10 = 6);
  assert (get_lucky ""programming"" 1 = 68);
  assert (get_lucky ""abz"" 5 = 2);
  assert (get_lucky ""a"" 1 = 1);
  assert (get_lucky ""aaa"" 3 = 3);
  assert (get_lucky ""challenge"" 2 = 4);
;;","easy","easy_047","easy"
"(**You are given a 0-indexed integer array nums. A subarray of nums is called continuous if:
 * >>> continuous_subarrays [5; 4; 2; 4]
 * 8
 * >>> continuous_subarrays [1; 2; 2; 2; 3; 3; 4]
 * 27
 * >>> continuous_subarrays [9; 7; 5; 3; 1]
 * 9
*)
let continuous_subarrays (nums : int list) : int =","  0","let () =
  assert (continuous_subarrays [5; 4; 2; 4] = 8);
  assert (continuous_subarrays [1; 2; 2; 2; 3; 3; 4] = 27);
  assert (continuous_subarrays [9; 7; 5; 3; 1] = 9);
  assert (continuous_subarrays [10; 9; 8; 7; 6; 5; 4; 3; 2; 1] = 27);
  assert (continuous_subarrays [9; 8; 7; 6; 5; 4; 3; 2; 1] = 24);
  assert (continuous_subarrays [1; 3; 5; 7; 9] = 9);
  assert (continuous_subarrays [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = 27);
;;","medium","medium_096","medium"
"(**Consider a matrix M with dimensions width * height, such that every cell has value 0 or 1, and an...
 * >>> maximum_number_of_ones 4 4 3 2
 * 6
 * >>> maximum_number_of_ones 6 6 3 3
 * 12
 * >>> maximum_number_of_ones 10 10 5 6
 * 24
*)
let maximum_number_of_ones (width : int) (height : int) (sideLength : int) (maxOnes : int) : int =","  0","let () =
  assert (maximum_number_of_ones 4 4 3 2 = 6);
  assert (maximum_number_of_ones 6 6 3 3 = 12);
  assert (maximum_number_of_ones 10 10 5 6 = 24);
  assert (maximum_number_of_ones 5 5 3 3 = 12);
  assert (maximum_number_of_ones 4 4 2 3 = 12);
  assert (maximum_number_of_ones 3 3 2 1 = 4);
  assert (maximum_number_of_ones 3 3 2 2 = 6);
;;","hard","hard_040","hard"
"(**A swap is defined as taking two distinct positions in an array and swapping the values in them.
 * >>> min_swaps [1; 0; 0; 0; 1; 1; 1; 0; 0; 1]
 * 2
 * >>> min_swaps [0; 0; 1; 0; 1; 0; 1; 0; 1; 0; 0]
 * 2
 * >>> min_swaps [1; 1; 1; 0; 0; 0; 0; 0; 0; 1; 1; 1]
 * 0
*)
let min_swaps (nums : int list) : int =","  0","let () =
  assert (min_swaps [1; 0; 0; 0; 1; 1; 1; 0; 0; 1] = 2);
  assert (min_swaps [0; 0; 1; 0; 1; 0; 1; 0; 1; 0; 0] = 2);
  assert (min_swaps [1; 1; 1; 0; 0; 0; 0; 0; 0; 1; 1; 1] = 0);
  assert (min_swaps [0; 1; 0; 1; 1; 0; 0] = 1);
  assert (min_swaps [0; 0; 0; 1; 1; 1; 0; 0; 0] = 0);
  assert (min_swaps [1; 0; 1; 0; 1; 0; 1; 0; 1; 0] = 2);
  assert (min_swaps [1; 1; 1; 1; 1; 0; 0; 0; 0; 0] = 0);
;;","medium","medium_135","medium"
"(**You are given a string moves of length n consisting only of characters 'L', 'R', and '_'. The str...
 * >>> furthest_distance_from_origin ""________R""
 * 9
 * >>> furthest_distance_from_origin ""L_RL__R""
 * 3
 * >>> furthest_distance_from_origin ""L_____R""
 * 5
*)
let furthest_distance_from_origin (moves : string) : int =","  0","let () =
  assert (furthest_distance_from_origin ""________R"" = 9);
  assert (furthest_distance_from_origin ""L_RL__R"" = 3);
  assert (furthest_distance_from_origin ""L_____R"" = 5);
  assert (furthest_distance_from_origin ""R_L_R_L"" = 3);
  assert (furthest_distance_from_origin ""L________"" = 9);
  assert (furthest_distance_from_origin ""R________"" = 9);
  assert (furthest_distance_from_origin ""LLRRLLR"" = 1);
;;","easy","easy_008","easy"
"(**There are two types of persons:
 * >>> maximum_good [[2; 1; 2]; [1; 2; 2]; [2; 0; 2]]
 * 2
 * >>> maximum_good [[2; 1; 0]; [1; 2; 1]; [0; 1; 0]]
 * 0
 * >>> maximum_good [[2; 1; 0; 2]; [1; 2; 2; 0]; [0; 2; 2; 1]; [2; 0; 1; 2]]
 * 2
*)
let maximum_good (statements : int list list) : int =","  0","let () =
  assert (maximum_good [[2; 1; 2]; [1; 2; 2]; [2; 0; 2]] = 2);
  assert (maximum_good [[2; 1; 0]; [1; 2; 1]; [0; 1; 0]] = 0);
  assert (maximum_good [[2; 1; 0; 2]; [1; 2; 2; 0]; [0; 2; 2; 1]; [2; 0; 1; 2]] = 2);
  assert (maximum_good [[2; 2]; [2; 2]] = 2);
  assert (maximum_good [[2; 1; 0; 0]; [0; 2; 1; 0]; [1; 1; 2; 0]; [0; 0; 0; 2]] = 1);
  assert (maximum_good [[1; 0; 1]; [0; 1; 0]; [1; 0; 1]] = 2);
  assert (maximum_good [[2; 1; 1]; [0; 2; 1]; [0; 0; 2]] = 1);
;;","hard","hard_088","hard"
"(**A distinct string is a string that is present only once in an array.
 * >>> kth_distinct [""a""] 1
 * a
 * >>> kth_distinct [""a""; ""a""; ""b""; ""b""; ""c""; ""c""; ""d""] 1
 * d
 * >>> kth_distinct [""apple""; ""banana""; ""apple""; ""orange""; ""banana""; ""kiwi""] 2
 * kiwi
*)
let kth_distinct (arr : string list) (k : int) : string =","  """"","let () =
  assert (kth_distinct [""a""] 1 = a);
  assert (kth_distinct [""a""; ""a""; ""b""; ""b""; ""c""; ""c""; ""d""] 1 = d);
  assert (kth_distinct [""apple""; ""banana""; ""apple""; ""orange""; ""banana""; ""kiwi""] 2 = kiwi);
  assert (kth_distinct [""apple""; ""banana""; ""apple""; ""orange""; ""banana""; ""grape""] 2 = grape);
  assert (kth_distinct [""aaa""; ""aa""; ""a""] 1 = aaa);
  assert (kth_distinct [""a""; ""b""; ""c""; ""d""; ""e""; ""f""] 6 = f);
;;","easy","easy_098","easy"
"(**You have n dice, and each dice has k faces numbered from 1 to k.
 * >>> num_rolls_to_target 15 10 100
 * 794915145
 * >>> num_rolls_to_target 4 6 12
 * 125
 * >>> num_rolls_to_target 30 30 500
 * 222616187
*)
let num_rolls_to_target (n : int) (k : int) (target : int) : int =","  0","let () =
  assert (num_rolls_to_target 15 10 100 = 794915145);
  assert (num_rolls_to_target 4 6 12 = 125);
  assert (num_rolls_to_target 30 30 500 = 222616187);
  assert (num_rolls_to_target 2 6 7 = 6);
  assert (num_rolls_to_target 10 5 30 = 856945);
  assert (num_rolls_to_target 3 4 8 = 12);
  assert (num_rolls_to_target 3 2 5 = 3);
;;","medium","medium_190","medium"
"(**Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, r...
 * >>> intersection [[1]; [1]]
 * [1]
 * >>> intersection [[10; 20; 30]; [20; 30; 40]; [30; 40; 50]; [30; 60; 70]]
 * [30]
 * >>> intersection [[3; 1; 2; 4; 5]; [1; 2; 3; 4]; [3; 4; 5; 6]]
 * [3; 4]
*)
let intersection (nums : int list list) : int list =","  []","let () =
  assert (intersection [[1]; [1]] = [1]);
  assert (intersection [[10; 20; 30]; [20; 30; 40]; [30; 40; 50]; [30; 60; 70]] = [30]);
  assert (intersection [[3; 1; 2; 4; 5]; [1; 2; 3; 4]; [3; 4; 5; 6]] = [3; 4]);
  assert (intersection [[10; 20; 30]; [20; 30; 40]; [30; 40; 50]] = [30]);
  assert (intersection [[1]; [1]; [1]; [1]] = [1]);
  assert (intersection [[1; 2; 3]; [2; 3; 4]; [3; 4; 5]; [4; 5; 6]] = []);
  assert (intersection [[1; 2; 3; 4; 5]; [2; 3; 4; 5; 6]; [3; 4; 5; 6; 7]] = [3; 4; 5]);
;;","easy","easy_157","easy"
"(**You are given two positive integer arrays nums and target, of the same length.
 * >>> minimum_operations [1; 100000000; 1] [100000000; 1; 100000000]
 * 299999997
 * >>> minimum_operations [1; 3; 2] [2; 1; 4]
 * 5
 * >>> minimum_operations [3; 5; 1; 2] [4; 6; 2; 4]
 * 2
*)
let minimum_operations (nums : int list) (target : int list) : int =","  0","let () =
  assert (minimum_operations [1; 100000000; 1] [100000000; 1; 100000000] = 299999997);
  assert (minimum_operations [1; 3; 2] [2; 1; 4] = 5);
  assert (minimum_operations [3; 5; 1; 2] [4; 6; 2; 4] = 2);
  assert (minimum_operations [100000000; 100000000; 100000000] [1; 1; 1] = 99999999);
  assert (minimum_operations [1; 1; 1; 1] [2; 2; 2; 2] = 1);
  assert (minimum_operations [10; 20; 30] [15; 25; 25] = 10);
  assert (minimum_operations [10; 20; 30] [15; 25; 35] = 5);
;;","hard","hard_085","hard"
"(**Given 2 integers n and start. Your task is return any permutation p of (0,1,2.....,2^n -1) such t...
 * >>> circular_permutation 1 0
 * [0; 1]
 * >>> circular_permutation 16 32768
 * Execution timed out
 * >>> circular_permutation 14 8190
 * Execution timed out
*)
let circular_permutation (n : int) (start : int) : int list =","  []","let () =
  assert (circular_permutation 1 0 = [0; 1]);
  assert (circular_permutation 16 32768 = Execution timed out);
  assert (circular_permutation 14 8190 = Execution timed out);
  assert (circular_permutation 12 2048 = [2048; 0; 1; 3; 2; 6; 7; 5; 4; 12; 13; 15; 14; 10; 11; 9; 8; 24; 25; 27; 26; 30; 31; 29; 28; 20; 21; 23; 22; 18; 19; 17; 16; 48; 49; 51; 50; 54; 55; 53; 52; 60; 61; 63; 62; 58; 59; 57; 56; 40; 41; 43; 42; 46; 47; 45; 44; 36; 37; 39; 38; 34; 35; 33; 32; 96; 97; 99; 98; 102; 103; 101; 100; 108; 109; 111; 110; 106; 107; 105; 104; 120; 121; 123; 122; 126; 127; 125; 124; 116; 117; 119; 118; 114; 115; 113; 112; 80; 81; 83; 82; 86; 87; 85; 84; 92; 93; 95; 94; 90; 91; 89; 88; 72; 73; 75; 74; 78; 79; 77; 76; 68; 69; 71; 70; 66; 67; 65; 64; 192; 193; 195; 194; 198; 199; 197; 196; 204; 205; 207; 206; 202; 203; 201; 200; 216; 217; 219; 218; 222; 223; 221; 220; 212; 213; 215; 214; 210; 211; 209; 208; 240; 241; 243; 242; 246; 247; 245; 244; 252; 253; 255; 254; 250; 251; 249; 248; 232; 233; 235; 234; 238; 239; 237; 236; 228; 229; 231; 230; 226; 227; 225; 224; 160; 161; 163; 162; 166; 167; 165; 164; 172; 173; 175; 174; 170; 171; 169; 168; 184; 185; 187; 186; 190; 191; 189; 188; 180; 181; 183; 182; 178; 179; 177; 176; 144; 145; 147; 146; 150; 151; 149; 148; 156; 157; 159; 158; 154; 155; 153; 152; 136; 137; 139; 138; 142; 143; 141; 140; 132; 133; 135; 134; 130; 131; 129; 128; 384; 385; 387; 386; 390; 391; 389; 388; 396; 397; 399; 398; 394; 395; 393; 392; 408; 409; 411; 410; 414; 415; 413; 412; 404; 405; 407; 406; 402; 403; 401; 400; 432; 433; 435; 434; 438; 439; 437; 436; 444; 445; 447; 446; 442; 443; 441; 440; 424; 425; 427; 426; 430; 431; 429; 428; 420; 421; 423; 422; 418; 419; 417; 416; 480; 481; 483; 482; 486; 487; 485; 484; 492; 493; 495; 494; 490; 491; 489; 488; 504; 505; 507; 506; 510; 511; 509; 508; 500; 501; 503; 502; 498; 499; 497; 496; 464; 465; 467; 466; 470; 471; 469; 468; 476; 477; 479; 478; 474; 475; 473; 472; 456; 457; 459; 458; 462; 463; 461; 460; 452; 453; 455; 454; 450; 451; 449; 448; 320; 321; 323; 322; 326; 327; 325; 324; 332; 333; 335; 334; 330; 331; 329; 328; 344; 345; 347; 346; 350; 351; 349; 348; 340; 341; 343; 342; 338; 339; 337; 336; 368; 369; 371; 370; 374; 375; 373; 372; 380; 381; 383; 382; 378; 379; 377; 376; 360; 361; 363; 362; 366; 367; 365; 364; 356; 357; 359; 358; 354; 355; 353; 352; 288; 289; 291; 290; 294; 295; 293; 292; 300; 301; 303; 302; 298; 299; 297; 296; 312; 313; 315; 314; 318; 319; 317; 316; 308; 309; 311; 310; 306; 307; 305; 304; 272; 273; 275; 274; 278; 279; 277; 276; 284; 285; 287; 286; 282; 283; 281; 280; 264; 265; 267; 266; 270; 271; 269; 268; 260; 261; 263; 262; 258; 259; 257; 256; 768; 769; 771; 770; 774; 775; 773; 772; 780; 781; 783; 782; 778; 779; 777; 776; 792; 793; 795; 794; 798; 799; 797; 796; 788; 789; 791; 790; 786; 787; 785; 784; 816; 817; 819; 818; 822; 823; 821; 820; 828; 829; 831; 830; 826; 827; 825; 824; 808; 809; 811; 810; 814; 815; 813; 812; 804; 805; 807; 806; 802; 803; 801; 800; 864; 865; 867; 866; 870; 871; 869; 868; 876; 877; 879; 878; 874; 875; 873; 872; 888; 889; 891; 890; 894; 895; 893; 892; 884; 885; 887; 886; 882; 883; 881; 880; 848; 849; 851; 850; 854; 855; 853; 852; 860; 861; 863; 862; 858; 859; 857; 856; 840; 841; 843; 842; 846; 847; 845; 844; 836; 837; 839; 838; 834; 835; 833; 832; 960; 961; 963; 962; 966; 967; 965; 964; 972; 973; 975; 974; 970; 971; 969; 968; 984; 985; 987; 986; 990; 991; 989; 988; 980; 981; 983; 982; 978; 979; 977; 976; 1008; 1009; 1011; 1010; 1014; 1015; 1013; 1012; 1020; 1021; 1023; 1022; 1018; 1019; 1017; 1016; 1000; 1001; 1003; 1002; 1006; 1007; 1005; 1004; 996; 997; 999; 998; 994; 995; 993; 992; 928; 929; 931; 930; 934; 935; 933; 932; 940; 941; 943; 942; 938; 939; 937; 936; 952; 953; 955; 954; 958; 959; 957; 956; 948; 949; 951; 950; 946; 947; 945; 944; 912; 913; 915; 914; 918; 919; 917; 916; 924; 925; 927; 926; 922; 923; 921; 920; 904; 905; 907; 906; 910; 911; 909; 908; 900; 901; 903; 902; 898; 899; 897; 896; 640; 641; 643; 642; 646; 647; 645; 644; 652; 653; 655; 654; 650; 651; 649; 648; 664; 665; 667; 666; 670; 671; 669; 668; 660; 661; 663; 662; 658; 659; 657; 656; 688; 689; 691; 690; 694; 695; 693; 692; 700; 701; 703; 702; 698; 699; 697; 696; 680; 681; 683; 682; 686; 687; 685; 684; 676; 677; 679; 678; 674; 675; 673; 672; 736; 737; 739; 738; 742; 743; 741; 740; 748; 749; 751; 750; 746; 747; 745; 744; 760; 761; 763; 762; 766; 767; 765; 764; 756; 757; 759; 758; 754; 755; 753; 752; 720; 721; 723; 722; 726; 727; 725; 724; 732; 733; 735; 734; 730; 731; 729; 728; 712; 713; 715; 714; 718; 719; 717; 716; 708; 709; 711; 710; 706; 707; 705; 704; 576; 577; 579; 578; 582; 583; 581; 580; 588; 589; 591; 590; 586; 587; 585; 584; 600; 601; 603; 602; 606; 607; 605; 604; 596; 597; 599; 598; 594; 595; 593; 592; 624; 625; 627; 626; 630; 631; 629; 628; 636; 637; 639; 638; 634; 635; 633; 632; 616; 617; 619; 618; 622; 623; 621; 620; 612; 613; 615; 614; 610; 611; 609; 608; 544; 545; 547; 546; 550; 551; 549; 548; 556; 557; 559; 558; 554; 555; 553; 552; 568; 569; 571; 570; 574; 575; 573; 572; 564; 565; 567; 566; 562; 563; 561; 560; 528; 529; 531; 530; 534; 535; 533; 532; 540; 541; 543; 542; 538; 539; 537; 536; 520; 521; 523; 522; 526; 527; 525; 524; 516; 517; 519; 518; 514; 515; 513; 512; 1536; 1537; 1539; 1538; 1542; 1543; 1541; 1540; 1548; 1549; 1551; 1550; 1546; 1547; 1545; 1544; 1560; 1561; 1563; 1562; 1566; 1567; 1565; 1564; 1556; 1557; 1559; 1558; 1554; 1555; 1553; 1552; 1584; 1585; 1587; 1586; 1590; 1591; 1589; 1588; 1596; 1597; 1599; 1598; 1594; 1595; 1593; 1592; 1576; 1577; 1579; 1578; 1582; 1583; 1581; 1580; 1572; 1573; 1575; 1574; 1570; 1571; 1569; 1568; 1632; 1633; 1635; 1634; 1638; 1639; 1637; 1636; 1644; 1645; 1647; 1646; 1642; 1643; 1641; 1640; 1656; 1657; 1659; 1658; 1662; 1663; 1661; 1660; 1652; 1653; 1655; 1654; 1650; 1651; 1649; 1648; 1616; 1617; 1619; 1618; 1622; 1623; 1621; 1620; 1628; 1629; 1631; 1630; 1626; 1627; 1625; 1624; 1608; 1609; 1611; 1610; 1614; 1615; 1613; 1612; 1604; 1605; 1607; 1606; 1602; 1603; 1601; 1600; 1728; 1729; 1731; 1730; 1734; 1735; 1733; 1732; 1740; 1741; 1743; 1742; 1738; 1739; 1737; 1736; 1752; 1753; 1755; 1754; 1758; 1759; 1757; 1756; 1748; 1749; 1751; 1750; 1746; 1747; 1745; 1744; 1776; 1777; 1779; 1778; 1782; 1783; 1781; 1780; 1788; 1789; 1791; 1790; 1786; 1787; 1785; 1784; 1768; 1769; 1771; 1770; 1774; 1775; 1773; 1772; 1764; 1765; 1767; 1766; 1762; 1763; 1761; 1760; 1696; 1697; 1699; 1698; 1702; 1703; 1701; 1700; 1708; 1709; 1711; 1710; 1706; 1707; 1705; 1704; 1720; 1721; 1723; 1722; 1726; 1727; 1725; 1724; 1716; 1717; 1719; 1718; 1714; 1715; 1713; 1712; 1680; 1681; 1683; 1682; 1686; 1687; 1685; 1684; 1692; 1693; 1695; 1694; 1690; 1691; 1689; 1688; 1672; 1673; 1675; 1674; 1678; 1679; 1677; 1676; 1668; 1669; 1671; 1670; 1666; 1667; 1665; 1664; 1920; 1921; 1923; 1922; 1926; 1927; 1925; 1924; 1932; 1933; 1935; 1934; 1930; 1931; 1929; 1928; 1944; 1945; 1947; 1946; 1950; 1951; 1949; 1948; 1940; 1941; 1943; 1942; 1938; 1939; 1937; 1936; 1968; 1969; 1971; 1970; 1974; 1975; 1973; 1972; 1980; 1981; 1983; 1982; 1978; 1979; 1977; 1976; 1960; 1961; 1963; 1962; 1966; 1967; 1965; 1964; 1956; 1957; 1959; 1958; 1954; 1955; 1953; 1952; 2016; 2017; 2019; 2018; 2022; 2023; 2021; 2020; 2028; 2029; 2031; 2030; 2026; 2027; 2025; 2024; 2040; 2041; 2043; 2042; 2046; 2047; 2045; 2044; 2036; 2037; 2039; 2038; 2034; 2035; 2033; 2032; 2000; 2001; 2003; 2002; 2006; 2007; 2005; 2004; 2012; 2013; 2015; 2014; 2010; 2011; 2009; 2008; 1992; 1993; 1995; 1994; 1998; 1999; 1997; 1996; 1988; 1989; 1991; 1990; 1986; 1987; 1985; 1984; 1856; 1857; 1859; 1858; 1862; 1863; 1861; 1860; 1868; 1869; 1871; 1870; 1866; 1867; 1865; 1864; 1880; 1881; 1883; 1882; 1886; 1887; 1885; 1884; 1876; 1877; 1879; 1878; 1874; 1875; 1873; 1872; 1904; 1905; 1907; 1906; 1910; 1911; 1909; 1908; 1916; 1917; 1919; 1918; 1914; 1915; 1913; 1912; 1896; 1897; 1899; 1898; 1902; 1903; 1901; 1900; 1892; 1893; 1895; 1894; 1890; 1891; 1889; 1888; 1824; 1825; 1827; 1826; 1830; 1831; 1829; 1828; 1836; 1837; 1839; 1838; 1834; 1835; 1833; 1832; 1848; 1849; 1851; 1850; 1854; 1855; 1853; 1852; 1844; 1845; 1847; 1846; 1842; 1843; 1841; 1840; 1808; 1809; 1811; 1810; 1814; 1815; 1813; 1812; 1820; 1821; 1823; 1822; 1818; 1819; 1817; 1816; 1800; 1801; 1803; 1802; 1806; 1807; 1805; 1804; 1796; 1797; 1799; 1798; 1794; 1795; 1793; 1792; 1280; 1281; 1283; 1282; 1286; 1287; 1285; 1284; 1292; 1293; 1295; 1294; 1290; 1291; 1289; 1288; 1304; 1305; 1307; 1306; 1310; 1311; 1309; 1308; 1300; 1301; 1303; 1302; 1298; 1299; 1297; 1296; 1328; 1329; 1331; 1330; 1334; 1335; 1333; 1332; 1340; 1341; 1343; 1342; 1338; 1339; 1337; 1336; 1320; 1321; 1323; 1322; 1326; 1327; 1325; 1324; 1316; 1317; 1319; 1318; 1314; 1315; 1313; 1312; 1376; 1377; 1379; 1378; 1382; 1383; 1381; 1380; 1388; 1389; 1391; 1390; 1386; 1387; 1385; 1384; 1400; 1401; 1403; 1402; 1406; 1407; 1405; 1404; 1396; 1397; 1399; 1398; 1394; 1395; 1393; 1392; 1360; 1361; 1363; 1362; 1366; 1367; 1365; 1364; 1372; 1373; 1375; 1374; 1370; 1371; 1369; 1368; 1352; 1353; 1355; 1354; 1358; 1359; 1357; 1356; 1348; 1349; 1351; 1350; 1346; 1347; 1345; 1344; 1472; 1473; 1475; 1474; 1478; 1479; 1477; 1476; 1484; 1485; 1487; 1486; 1482; 1483; 1481; 1480; 1496; 1497; 1499; 1498; 1502; 1503; 1501; 1500; 1492; 1493; 1495; 1494; 1490; 1491; 1489; 1488; 1520; 1521; 1523; 1522; 1526; 1527; 1525; 1524; 1532; 1533; 1535; 1534; 1530; 1531; 1529; 1528; 1512; 1513; 1515; 1514; 1518; 1519; 1517; 1516; 1508; 1509; 1511; 1510; 1506; 1507; 1505; 1504; 1440; 1441; 1443; 1442; 1446; 1447; 1445; 1444; 1452; 1453; 1455; 1454; 1450; 1451; 1449; 1448; 1464; 1465; 1467; 1466; 1470; 1471; 1469; 1468; 1460; 1461; 1463; 1462; 1458; 1459; 1457; 1456; 1424; 1425; 1427; 1426; 1430; 1431; 1429; 1428; 1436; 1437; 1439; 1438; 1434; 1435; 1433; 1432; 1416; 1417; 1419; 1418; 1422; 1423; 1421; 1420; 1412; 1413; 1415; 1414; 1410; 1411; 1409; 1408; 1152; 1153; 1155; 1154; 1158; 1159; 1157; 1156; 1164; 1165; 1167; 1166; 1162; 1163; 1161; 1160; 1176; 1177; 1179; 1178; 1182; 1183; 1181; 1180; 1172; 1173; 1175; 1174; 1170; 1171; 1169; 1168; 1200; 1201; 1203; 1202; 1206; 1207; 1205; 1204; 1212; 1213; 1215; 1214; 1210; 1211; 1209; 1208; 1192; 1193; 1195; 1194; 1198; 1199; 1197; 1196; 1188; 1189; 1191; 1190; 1186; 1187; 1185; 1184; 1248; 1249; 1251; 1250; 1254; 1255; 1253; 1252; 1260; 1261; 1263; 1262; 1258; 1259; 1257; 1256; 1272; 1273; 1275; 1274; 1278; 1279; 1277; 1276; 1268; 1269; 1271; 1270; 1266; 1267; 1265; 1264; 1232; 1233; 1235; 1234; 1238; 1239; 1237; 1236; 1244; 1245; 1247; 1246; 1242; 1243; 1241; 1240; 1224; 1225; 1227; 1226; 1230; 1231; 1229; 1228; 1220; 1221; 1223; 1222; 1218; 1219; 1217; 1216; 1088; 1089; 1091; 1090; 1094; 1095; 1093; 1092; 1100; 1101; 1103; 1102; 1098; 1099; 1097; 1096; 1112; 1113; 1115; 1114; 1118; 1119; 1117; 1116; 1108; 1109; 1111; 1110; 1106; 1107; 1105; 1104; 1136; 1137; 1139; 1138; 1142; 1143; 1141; 1140; 1148; 1149; 1151; 1150; 1146; 1147; 1145; 1144; 1128; 1129; 1131; 1130; 1134; 1135; 1133; 1132; 1124; 1125; 1127; 1126; 1122; 1123; 1121; 1120; 1056; 1057; 1059; 1058; 1062; 1063; 1061; 1060; 1068; 1069; 1071; 1070; 1066; 1067; 1065; 1064; 1080; 1081; 1083; 1082; 1086; 1087; 1085; 1084; 1076; 1077; 1079; 1078; 1074; 1075; 1073; 1072; 1040; 1041; 1043; 1042; 1046; 1047; 1045; 1044; 1052; 1053; 1055; 1054; 1050; 1051; 1049; 1048; 1032; 1033; 1035; 1034; 1038; 1039; 1037; 1036; 1028; 1029; 1031; 1030; 1026; 1027; 1025; 1024; 3072; 3073; 3075; 3074; 3078; 3079; 3077; 3076; 3084; 3085; 3087; 3086; 3082; 3083; 3081; 3080; 3096; 3097; 3099; 3098; 3102; 3103; 3101; 3100; 3092; 3093; 3095; 3094; 3090; 3091; 3089; 3088; 3120; 3121; 3123; 3122; 3126; 3127; 3125; 3124; 3132; 3133; 3135; 3134; 3130; 3131; 3129; 3128; 3112; 3113; 3115; 3114; 3118; 3119; 3117; 3116; 3108; 3109; 3111; 3110; 3106; 3107; 3105; 3104; 3168; 3169; 3171; 3170; 3174; 3175; 3173; 3172; 3180; 3181; 3183; 3182; 3178; 3179; 3177; 3176; 3192; 3193; 3195; 3194; 3198; 3199; 3197; 3196; 3188; 3189; 3191; 3190; 3186; 3187; 3185; 3184; 3152; 3153; 3155; 3154; 3158; 3159; 3157; 3156; 3164; 3165; 3167; 3166; 3162; 3163; 3161; 3160; 3144; 3145; 3147; 3146; 3150; 3151; 3149; 3148; 3140; 3141; 3143; 3142; 3138; 3139; 3137; 3136; 3264; 3265; 3267; 3266; 3270; 3271; 3269; 3268; 3276; 3277; 3279; 3278; 3274; 3275; 3273; 3272; 3288; 3289; 3291; 3290; 3294; 3295; 3293; 3292; 3284; 3285; 3287; 3286; 3282; 3283; 3281; 3280; 3312; 3313; 3315; 3314; 3318; 3319; 3317; 3316; 3324; 3325; 3327; 3326; 3322; 3323; 3321; 3320; 3304; 3305; 3307; 3306; 3310; 3311; 3309; 3308; 3300; 3301; 3303; 3302; 3298; 3299; 3297; 3296; 3232; 3233; 3235; 3234; 3238; 3239; 3237; 3236; 3244; 3245; 3247; 3246; 3242; 3243; 3241; 3240; 3256; 3257; 3259; 3258; 3262; 3263; 3261; 3260; 3252; 3253; 3255; 3254; 3250; 3251; 3249; 3248; 3216; 3217; 3219; 3218; 3222; 3223; 3221; 3220; 3228; 3229; 3231; 3230; 3226; 3227; 3225; 3224; 3208; 3209; 3211; 3210; 3214; 3215; 3213; 3212; 3204; 3205; 3207; 3206; 3202; 3203; 3201; 3200; 3456; 3457; 3459; 3458; 3462; 3463; 3461; 3460; 3468; 3469; 3471; 3470; 3466; 3467; 3465; 3464; 3480; 3481; 3483; 3482; 3486; 3487; 3485; 3484; 3476; 3477; 3479; 3478; 3474; 3475; 3473; 3472; 3504; 3505; 3507; 3506; 3510; 3511; 3509; 3508; 3516; 3517; 3519; 3518; 3514; 3515; 3513; 3512; 3496; 3497; 3499; 3498; 3502; 3503; 3501; 3500; 3492; 3493; 3495; 3494; 3490; 3491; 3489; 3488; 3552; 3553; 3555; 3554; 3558; 3559; 3557; 3556; 3564; 3565; 3567; 3566; 3562; 3563; 3561; 3560; 3576; 3577; 3579; 3578; 3582; 3583; 3581; 3580; 3572; 3573; 3575; 3574; 3570; 3571; 3569; 3568; 3536; 3537; 3539; 3538; 3542; 3543; 3541; 3540; 3548; 3549; 3551; 3550; 3546; 3547; 3545; 3544; 3528; 3529; 3531; 3530; 3534; 3535; 3533; 3532; 3524; 3525; 3527; 3526; 3522; 3523; 3521; 3520; 3392; 3393; 3395; 3394; 3398; 3399; 3397; 3396; 3404; 3405; 3407; 3406; 3402; 3403; 3401; 3400; 3416; 3417; 3419; 3418; 3422; 3423; 3421; 3420; 3412; 3413; 3415; 3414; 3410; 3411; 3409; 3408; 3440; 3441; 3443; 3442; 3446; 3447; 3445; 3444; 3452; 3453; 3455; 3454; 3450; 3451; 3449; 3448; 3432; 3433; 3435; 3434; 3438; 3439; 3437; 3436; 3428; 3429; 3431; 3430; 3426; 3427; 3425; 3424; 3360; 3361; 3363; 3362; 3366; 3367; 3365; 3364; 3372; 3373; 3375; 3374; 3370; 3371; 3369; 3368; 3384; 3385; 3387; 3386; 3390; 3391; 3389; 3388; 3380; 3381; 3383; 3382; 3378; 3379; 3377; 3376; 3344; 3345; 3347; 3346; 3350; 3351; 3349; 3348; 3356; 3357; 3359; 3358; 3354; 3355; 3353; 3352; 3336; 3337; 3339; 3338; 3342; 3343; 3341; 3340; 3332; 3333; 3335; 3334; 3330; 3331; 3329; 3328; 3840; 3841; 3843; 3842; 3846; 3847; 3845; 3844; 3852; 3853; 3855; 3854; 3850; 3851; 3849; 3848; 3864; 3865; 3867; 3866; 3870; 3871; 3869; 3868; 3860; 3861; 3863; 3862; 3858; 3859; 3857; 3856; 3888; 3889; 3891; 3890; 3894; 3895; 3893; 3892; 3900; 3901; 3903; 3902; 3898; 3899; 3897; 3896; 3880; 3881; 3883; 3882; 3886; 3887; 3885; 3884; 3876; 3877; 3879; 3878; 3874; 3875; 3873; 3872; 3936; 3937; 3939; 3938; 3942; 3943; 3941; 3940; 3948; 3949; 3951; 3950; 3946; 3947; 3945; 3944; 3960; 3961; 3963; 3962; 3966; 3967; 3965; 3964; 3956; 3957; 3959; 3958; 3954; 3955; 3953; 3952; 3920; 3921; 3923; 3922; 3926; 3927; 3925; 3924; 3932; 3933; 3935; 3934; 3930; 3931; 3929; 3928; 3912; 3913; 3915; 3914; 3918; 3919; 3917; 3916; 3908; 3909; 3911; 3910; 3906; 3907; 3905; 3904; 4032; 4033; 4035; 4034; 4038; 4039; 4037; 4036; 4044; 4045; 4047; 4046; 4042; 4043; 4041; 4040; 4056; 4057; 4059; 4058; 4062; 4063; 4061; 4060; 4052; 4053; 4055; 4054; 4050; 4051; 4049; 4048; 4080; 4081; 4083; 4082; 4086; 4087; 4085; 4084; 4092; 4093; 4095; 4094; 4090; 4091; 4089; 4088; 4072; 4073; 4075; 4074; 4078; 4079; 4077; 4076; 4068; 4069; 4071; 4070; 4066; 4067; 4065; 4064; 4000; 4001; 4003; 4002; 4006; 4007; 4005; 4004; 4012; 4013; 4015; 4014; 4010; 4011; 4009; 4008; 4024; 4025; 4027; 4026; 4030; 4031; 4029; 4028; 4020; 4021; 4023; 4022; 4018; 4019; 4017; 4016; 3984; 3985; 3987; 3986; 3990; 3991; 3989; 3988; 3996; 3997; 3999; 3998; 3994; 3995; 3993; 3992; 3976; 3977; 3979; 3978; 3982; 3983; 3981; 3980; 3972; 3973; 3975; 3974; 3970; 3971; 3969; 3968; 3712; 3713; 3715; 3714; 3718; 3719; 3717; 3716; 3724; 3725; 3727; 3726; 3722; 3723; 3721; 3720; 3736; 3737; 3739; 3738; 3742; 3743; 3741; 3740; 3732; 3733; 3735; 3734; 3730; 3731; 3729; 3728; 3760; 3761; 3763; 3762; 3766; 3767; 3765; 3764; 3772; 3773; 3775; 3774; 3770; 3771; 3769; 3768; 3752; 3753; 3755; 3754; 3758; 3759; 3757; 3756; 3748; 3749; 3751; 3750; 3746; 3747; 3745; 3744; 3808; 3809; 3811; 3810; 3814; 3815; 3813; 3812; 3820; 3821; 3823; 3822; 3818; 3819; 3817; 3816; 3832; 3833; 3835; 3834; 3838; 3839; 3837; 3836; 3828; 3829; 3831; 3830; 3826; 3827; 3825; 3824; 3792; 3793; 3795; 3794; 3798; 3799; 3797; 3796; 3804; 3805; 3807; 3806; 3802; 3803; 3801; 3800; 3784; 3785; 3787; 3786; 3790; 3791; 3789; 3788; 3780; 3781; 3783; 3782; 3778; 3779; 3777; 3776; 3648; 3649; 3651; 3650; 3654; 3655; 3653; 3652; 3660; 3661; 3663; 3662; 3658; 3659; 3657; 3656; 3672; 3673; 3675; 3674; 3678; 3679; 3677; 3676; 3668; 3669; 3671; 3670; 3666; 3667; 3665; 3664; 3696; 3697; 3699; 3698; 3702; 3703; 3701; 3700; 3708; 3709; 3711; 3710; 3706; 3707; 3705; 3704; 3688; 3689; 3691; 3690; 3694; 3695; 3693; 3692; 3684; 3685; 3687; 3686; 3682; 3683; 3681; 3680; 3616; 3617; 3619; 3618; 3622; 3623; 3621; 3620; 3628; 3629; 3631; 3630; 3626; 3627; 3625; 3624; 3640; 3641; 3643; 3642; 3646; 3647; 3645; 3644; 3636; 3637; 3639; 3638; 3634; 3635; 3633; 3632; 3600; 3601; 3603; 3602; 3606; 3607; 3605; 3604; 3612; 3613; 3615; 3614; 3610; 3611; 3609; 3608; 3592; 3593; 3595; 3594; 3598; 3599; 3597; 3596; 3588; 3589; 3591; 3590; 3586; 3587; 3585; 3584; 2560; 2561; 2563; 2562; 2566; 2567; 2565; 2564; 2572; 2573; 2575; 2574; 2570; 2571; 2569; 2568; 2584; 2585; 2587; 2586; 2590; 2591; 2589; 2588; 2580; 2581; 2583; 2582; 2578; 2579; 2577; 2576; 2608; 2609; 2611; 2610; 2614; 2615; 2613; 2612; 2620; 2621; 2623; 2622; 2618; 2619; 2617; 2616; 2600; 2601; 2603; 2602; 2606; 2607; 2605; 2604; 2596; 2597; 2599; 2598; 2594; 2595; 2593; 2592; 2656; 2657; 2659; 2658; 2662; 2663; 2661; 2660; 2668; 2669; 2671; 2670; 2666; 2667; 2665; 2664; 2680; 2681; 2683; 2682; 2686; 2687; 2685; 2684; 2676; 2677; 2679; 2678; 2674; 2675; 2673; 2672; 2640; 2641; 2643; 2642; 2646; 2647; 2645; 2644; 2652; 2653; 2655; 2654; 2650; 2651; 2649; 2648; 2632; 2633; 2635; 2634; 2638; 2639; 2637; 2636; 2628; 2629; 2631; 2630; 2626; 2627; 2625; 2624; 2752; 2753; 2755; 2754; 2758; 2759; 2757; 2756; 2764; 2765; 2767; 2766; 2762; 2763; 2761; 2760; 2776; 2777; 2779; 2778; 2782; 2783; 2781; 2780; 2772; 2773; 2775; 2774; 2770; 2771; 2769; 2768; 2800; 2801; 2803; 2802; 2806; 2807; 2805; 2804; 2812; 2813; 2815; 2814; 2810; 2811; 2809; 2808; 2792; 2793; 2795; 2794; 2798; 2799; 2797; 2796; 2788; 2789; 2791; 2790; 2786; 2787; 2785; 2784; 2720; 2721; 2723; 2722; 2726; 2727; 2725; 2724; 2732; 2733; 2735; 2734; 2730; 2731; 2729; 2728; 2744; 2745; 2747; 2746; 2750; 2751; 2749; 2748; 2740; 2741; 2743; 2742; 2738; 2739; 2737; 2736; 2704; 2705; 2707; 2706; 2710; 2711; 2709; 2708; 2716; 2717; 2719; 2718; 2714; 2715; 2713; 2712; 2696; 2697; 2699; 2698; 2702; 2703; 2701; 2700; 2692; 2693; 2695; 2694; 2690; 2691; 2689; 2688; 2944; 2945; 2947; 2946; 2950; 2951; 2949; 2948; 2956; 2957; 2959; 2958; 2954; 2955; 2953; 2952; 2968; 2969; 2971; 2970; 2974; 2975; 2973; 2972; 2964; 2965; 2967; 2966; 2962; 2963; 2961; 2960; 2992; 2993; 2995; 2994; 2998; 2999; 2997; 2996; 3004; 3005; 3007; 3006; 3002; 3003; 3001; 3000; 2984; 2985; 2987; 2986; 2990; 2991; 2989; 2988; 2980; 2981; 2983; 2982; 2978; 2979; 2977; 2976; 3040; 3041; 3043; 3042; 3046; 3047; 3045; 3044; 3052; 3053; 3055; 3054; 3050; 3051; 3049; 3048; 3064; 3065; 3067; 3066; 3070; 3071; 3069; 3068; 3060; 3061; 3063; 3062; 3058; 3059; 3057; 3056; 3024; 3025; 3027; 3026; 3030; 3031; 3029; 3028; 3036; 3037; 3039; 3038; 3034; 3035; 3033; 3032; 3016; 3017; 3019; 3018; 3022; 3023; 3021; 3020; 3012; 3013; 3015; 3014; 3010; 3011; 3009; 3008; 2880; 2881; 2883; 2882; 2886; 2887; 2885; 2884; 2892; 2893; 2895; 2894; 2890; 2891; 2889; 2888; 2904; 2905; 2907; 2906; 2910; 2911; 2909; 2908; 2900; 2901; 2903; 2902; 2898; 2899; 2897; 2896; 2928; 2929; 2931; 2930; 2934; 2935; 2933; 2932; 2940; 2941; 2943; 2942; 2938; 2939; 2937; 2936; 2920; 2921; 2923; 2922; 2926; 2927; 2925; 2924; 2916; 2917; 2919; 2918; 2914; 2915; 2913; 2912; 2848; 2849; 2851; 2850; 2854; 2855; 2853; 2852; 2860; 2861; 2863; 2862; 2858; 2859; 2857; 2856; 2872; 2873; 2875; 2874; 2878; 2879; 2877; 2876; 2868; 2869; 2871; 2870; 2866; 2867; 2865; 2864; 2832; 2833; 2835; 2834; 2838; 2839; 2837; 2836; 2844; 2845; 2847; 2846; 2842; 2843; 2841; 2840; 2824; 2825; 2827; 2826; 2830; 2831; 2829; 2828; 2820; 2821; 2823; 2822; 2818; 2819; 2817; 2816; 2304; 2305; 2307; 2306; 2310; 2311; 2309; 2308; 2316; 2317; 2319; 2318; 2314; 2315; 2313; 2312; 2328; 2329; 2331; 2330; 2334; 2335; 2333; 2332; 2324; 2325; 2327; 2326; 2322; 2323; 2321; 2320; 2352; 2353; 2355; 2354; 2358; 2359; 2357; 2356; 2364; 2365; 2367; 2366; 2362; 2363; 2361; 2360; 2344; 2345; 2347; 2346; 2350; 2351; 2349; 2348; 2340; 2341; 2343; 2342; 2338; 2339; 2337; 2336; 2400; 2401; 2403; 2402; 2406; 2407; 2405; 2404; 2412; 2413; 2415; 2414; 2410; 2411; 2409; 2408; 2424; 2425; 2427; 2426; 2430; 2431; 2429; 2428; 2420; 2421; 2423; 2422; 2418; 2419; 2417; 2416; 2384; 2385; 2387; 2386; 2390; 2391; 2389; 2388; 2396; 2397; 2399; 2398; 2394; 2395; 2393; 2392; 2376; 2377; 2379; 2378; 2382; 2383; 2381; 2380; 2372; 2373; 2375; 2374; 2370; 2371; 2369; 2368; 2496; 2497; 2499; 2498; 2502; 2503; 2501; 2500; 2508; 2509; 2511; 2510; 2506; 2507; 2505; 2504; 2520; 2521; 2523; 2522; 2526; 2527; 2525; 2524; 2516; 2517; 2519; 2518; 2514; 2515; 2513; 2512; 2544; 2545; 2547; 2546; 2550; 2551; 2549; 2548; 2556; 2557; 2559; 2558; 2554; 2555; 2553; 2552; 2536; 2537; 2539; 2538; 2542; 2543; 2541; 2540; 2532; 2533; 2535; 2534; 2530; 2531; 2529; 2528; 2464; 2465; 2467; 2466; 2470; 2471; 2469; 2468; 2476; 2477; 2479; 2478; 2474; 2475; 2473; 2472; 2488; 2489; 2491; 2490; 2494; 2495; 2493; 2492; 2484; 2485; 2487; 2486; 2482; 2483; 2481; 2480; 2448; 2449; 2451; 2450; 2454; 2455; 2453; 2452; 2460; 2461; 2463; 2462; 2458; 2459; 2457; 2456; 2440; 2441; 2443; 2442; 2446; 2447; 2445; 2444; 2436; 2437; 2439; 2438; 2434; 2435; 2433; 2432; 2176; 2177; 2179; 2178; 2182; 2183; 2181; 2180; 2188; 2189; 2191; 2190; 2186; 2187; 2185; 2184; 2200; 2201; 2203; 2202; 2206; 2207; 2205; 2204; 2196; 2197; 2199; 2198; 2194; 2195; 2193; 2192; 2224; 2225; 2227; 2226; 2230; 2231; 2229; 2228; 2236; 2237; 2239; 2238; 2234; 2235; 2233; 2232; 2216; 2217; 2219; 2218; 2222; 2223; 2221; 2220; 2212; 2213; 2215; 2214; 2210; 2211; 2209; 2208; 2272; 2273; 2275; 2274; 2278; 2279; 2277; 2276; 2284; 2285; 2287; 2286; 2282; 2283; 2281; 2280; 2296; 2297; 2299; 2298; 2302; 2303; 2301; 2300; 2292; 2293; 2295; 2294; 2290; 2291; 2289; 2288; 2256; 2257; 2259; 2258; 2262; 2263; 2261; 2260; 2268; 2269; 2271; 2270; 2266; 2267; 2265; 2264; 2248; 2249; 2251; 2250; 2254; 2255; 2253; 2252; 2244; 2245; 2247; 2246; 2242; 2243; 2241; 2240; 2112; 2113; 2115; 2114; 2118; 2119; 2117; 2116; 2124; 2125; 2127; 2126; 2122; 2123; 2121; 2120; 2136; 2137; 2139; 2138; 2142; 2143; 2141; 2140; 2132; 2133; 2135; 2134; 2130; 2131; 2129; 2128; 2160; 2161; 2163; 2162; 2166; 2167; 2165; 2164; 2172; 2173; 2175; 2174; 2170; 2171; 2169; 2168; 2152; 2153; 2155; 2154; 2158; 2159; 2157; 2156; 2148; 2149; 2151; 2150; 2146; 2147; 2145; 2144; 2080; 2081; 2083; 2082; 2086; 2087; 2085; 2084; 2092; 2093; 2095; 2094; 2090; 2091; 2089; 2088; 2104; 2105; 2107; 2106; 2110; 2111; 2109; 2108; 2100; 2101; 2103; 2102; 2098; 2099; 2097; 2096; 2064; 2065; 2067; 2066; 2070; 2071; 2069; 2068; 2076; 2077; 2079; 2078; 2074; 2075; 2073; 2072; 2056; 2057; 2059; 2058; 2062; 2063; 2061; 2060; 2052; 2053; 2055; 2054; 2050; 2051; 2049]);
  assert (circular_permutation 8 128 = [128; 0; 1; 3; 2; 6; 7; 5; 4; 12; 13; 15; 14; 10; 11; 9; 8; 24; 25; 27; 26; 30; 31; 29; 28; 20; 21; 23; 22; 18; 19; 17; 16; 48; 49; 51; 50; 54; 55; 53; 52; 60; 61; 63; 62; 58; 59; 57; 56; 40; 41; 43; 42; 46; 47; 45; 44; 36; 37; 39; 38; 34; 35; 33; 32; 96; 97; 99; 98; 102; 103; 101; 100; 108; 109; 111; 110; 106; 107; 105; 104; 120; 121; 123; 122; 126; 127; 125; 124; 116; 117; 119; 118; 114; 115; 113; 112; 80; 81; 83; 82; 86; 87; 85; 84; 92; 93; 95; 94; 90; 91; 89; 88; 72; 73; 75; 74; 78; 79; 77; 76; 68; 69; 71; 70; 66; 67; 65; 64; 192; 193; 195; 194; 198; 199; 197; 196; 204; 205; 207; 206; 202; 203; 201; 200; 216; 217; 219; 218; 222; 223; 221; 220; 212; 213; 215; 214; 210; 211; 209; 208; 240; 241; 243; 242; 246; 247; 245; 244; 252; 253; 255; 254; 250; 251; 249; 248; 232; 233; 235; 234; 238; 239; 237; 236; 228; 229; 231; 230; 226; 227; 225; 224; 160; 161; 163; 162; 166; 167; 165; 164; 172; 173; 175; 174; 170; 171; 169; 168; 184; 185; 187; 186; 190; 191; 189; 188; 180; 181; 183; 182; 178; 179; 177; 176; 144; 145; 147; 146; 150; 151; 149; 148; 156; 157; 159; 158; 154; 155; 153; 152; 136; 137; 139; 138; 142; 143; 141; 140; 132; 133; 135; 134; 130; 131; 129]);
  assert (circular_permutation 13 4095 = Execution timed out);
  assert (circular_permutation 5 15 = [15; 14; 10; 11; 9; 8; 24; 25; 27; 26; 30; 31; 29; 28; 20; 21; 23; 22; 18; 19; 17; 16; 0; 1; 3; 2; 6; 7; 5; 4; 12; 13]);
;;","medium","medium_184","medium"
"(**You are given an array nums consisting of positive integers where all integers have the same numb...
 * >>> sum_digit_differences [12345; 54321; 13245]
 * 11
 * >>> sum_digit_differences [10; 10; 10; 10]
 * 0
 * >>> sum_digit_differences [123; 234; 345]
 * 9
*)
let sum_digit_differences (nums : int list) : int =","  0","let () =
  assert (sum_digit_differences [12345; 54321; 13245] = 11);
  assert (sum_digit_differences [10; 10; 10; 10] = 0);
  assert (sum_digit_differences [123; 234; 345] = 9);
  assert (sum_digit_differences [123; 456; 789] = 9);
  assert (sum_digit_differences [987; 876; 765; 654] = 18);
  assert (sum_digit_differences [99999; 99999; 99999] = 0);
  assert (sum_digit_differences [13; 23; 12] = 4);
;;","medium","medium_084","medium"
"(**Given an array of unique integers, arr, where each integer arr[i] is strictly greater than 1.
 * >>> num_factored_binary_trees [10; 20; 40; 80]
 * 4
 * >>> num_factored_binary_trees [2; 4; 5; 10]
 * 7
 * >>> num_factored_binary_trees [2; 3; 6; 18]
 * 12
*)
let num_factored_binary_trees (arr : int list) : int =","  0","let () =
  assert (num_factored_binary_trees [10; 20; 40; 80] = 4);
  assert (num_factored_binary_trees [2; 4; 5; 10] = 7);
  assert (num_factored_binary_trees [2; 3; 6; 18] = 12);
  assert (num_factored_binary_trees [5; 10; 20; 40; 80] = 5);
  assert (num_factored_binary_trees [18; 3; 6; 2] = 12);
  assert (num_factored_binary_trees [3; 6; 9] = 4);
  assert (num_factored_binary_trees [2; 3; 4; 6; 8; 12; 16; 24; 48] = 278);
;;","medium","medium_057","medium"
"(**You are given a positive integer k. You are also given:
 * >>> build_matrix 5 [[1; 5]; [2; 5]; [3; 5]; [4; 5]] [[1; 2]; [2; 3]; [3; 4]; [4; 5]]
 * [[1; 0; 0; 0; 0]; [0; 2; 0; 0; 0]; [0; 0; 3; 0; 0]; [0; 0; 0; 4; 0]; [0; 0; 0; 0; 5]]
 * >>> build_matrix 3 [[1; 2]; [3; 2]] [[2; 1]; [3; 2]]
 * [[0; 0; 1]; [3; 0; 0]; [0; 2; 0]]
 * >>> build_matrix 4 [[4; 3]; [3; 2]; [2; 1]] [[4; 3]; [3; 2]; [2; 1]]
 * [[4; 0; 0; 0]; [0; 3; 0; 0]; [0; 0; 2; 0]; [0; 0; 0; 1]]
*)
let build_matrix (k : int) (rowConditions : int list list) (colConditions : int list list) : int list list =","  [[]]","let () =
  assert (build_matrix 5 [[1; 5]; [2; 5]; [3; 5]; [4; 5]] [[1; 2]; [2; 3]; [3; 4]; [4; 5]] = [[1; 0; 0; 0; 0]; [0; 2; 0; 0; 0]; [0; 0; 3; 0; 0]; [0; 0; 0; 4; 0]; [0; 0; 0; 0; 5]]);
  assert (build_matrix 3 [[1; 2]; [3; 2]] [[2; 1]; [3; 2]] = [[0; 0; 1]; [3; 0; 0]; [0; 2; 0]]);
  assert (build_matrix 4 [[4; 3]; [3; 2]; [2; 1]] [[4; 3]; [3; 2]; [2; 1]] = [[4; 0; 0; 0]; [0; 3; 0; 0]; [0; 0; 2; 0]; [0; 0; 0; 1]]);
  assert (build_matrix 4 [[1; 2]; [2; 3]; [3; 4]] [[1; 2]; [2; 3]; [3; 4]] = [[1; 0; 0; 0]; [0; 2; 0; 0]; [0; 0; 3; 0]; [0; 0; 0; 4]]);
  assert (build_matrix 6 [[1; 2]; [1; 3]; [2; 4]; [3; 4]; [4; 5]; [4; 6]] [[1; 2]; [1; 3]; [2; 4]; [3; 4]; [4; 5]; [4; 6]] = [[1; 0; 0; 0; 0; 0]; [0; 2; 0; 0; 0; 0]; [0; 0; 3; 0; 0; 0]; [0; 0; 0; 4; 0; 0]; [0; 0; 0; 0; 5; 0]; [0; 0; 0; 0; 0; 6]]);
  assert (build_matrix 4 [[1; 2]; [3; 4]] [[1; 3]; [2; 4]] = [[1; 0; 0; 0]; [0; 0; 3; 0]; [0; 2; 0; 0]; [0; 0; 0; 4]]);
  assert (build_matrix 3 [[1; 2]; [2; 3]; [3; 1]; [2; 3]] [[2; 1]] = []);
;;","hard","hard_073","hard"
"(**A magical string s consists of only '1' and '2' and obeys the following rules:
 * >>> magical_string 100000
 * 49972
 * >>> magical_string 100
 * 49
 * >>> magical_string 15
 * 7
*)
let magical_string (n : int) : int =","  0","let () =
  assert (magical_string 100000 = 49972);
  assert (magical_string 100 = 49);
  assert (magical_string 15 = 7);
  assert (magical_string 10000 = 4996);
  assert (magical_string 6 = 3);
  assert (magical_string 20 = 10);
  assert (magical_string 1 = 1);
;;","medium","medium_196","medium"
"(**You are given two positive integers x and y, denoting the number of coins with values 75 and 10 r...
 * >>> winning_player 100 1
 * Bob
 * >>> winning_player 1 100
 * Alice
 * >>> winning_player 1 10
 * Alice
*)
let winning_player (x : int) (y : int) : string =","  """"","let () =
  assert (winning_player 100 1 = Bob);
  assert (winning_player 1 100 = Alice);
  assert (winning_player 1 10 = Alice);
  assert (winning_player 4 11 = Bob);
  assert (winning_player 2 7 = Alice);
  assert (winning_player 5 5 = Alice);
  assert (winning_player 10 1 = Bob);
;;","easy","easy_072","easy"
"(**You are given a positive integer num consisting of exactly four digits. Split num into two new in...
 * >>> minimum_sum 8765
 * 125
 * >>> minimum_sum 2309
 * 32
 * >>> minimum_sum 5678
 * 125
*)
let minimum_sum (num : int) : int =","  0","let () =
  assert (minimum_sum 8765 = 125);
  assert (minimum_sum 2309 = 32);
  assert (minimum_sum 5678 = 125);
  assert (minimum_sum 1098 = 27);
  assert (minimum_sum 1111 = 22);
  assert (minimum_sum 3333 = 66);
  assert (minimum_sum 4009 = 13);
;;","easy","easy_023","easy"
"(**You are given an array of intervals, where intervals[i] = [starti, endi] and each starti is unique.
 * >>> find_right_interval [[-1; 1]; [0; 2]; [1; 3]; [2; 4]; [3; 5]]
 * [2; 3; 4; -1; -1]
 * >>> find_right_interval [[5; 10]; [2; 3]; [1; 5]; [8; 12]]
 * [-1; 0; 0; -1]
 * >>> find_right_interval [[10; 20]; [20; 30]; [5; 15]; [30; 40]]
 * [1; 3; 1; -1]
*)
let find_right_interval (intervals : int list list) : int list =","  []","let () =
  assert (find_right_interval [[-1; 1]; [0; 2]; [1; 3]; [2; 4]; [3; 5]] = [2; 3; 4; -1; -1]);
  assert (find_right_interval [[5; 10]; [2; 3]; [1; 5]; [8; 12]] = [-1; 0; 0; -1]);
  assert (find_right_interval [[10; 20]; [20; 30]; [5; 15]; [30; 40]] = [1; 3; 1; -1]);
  assert (find_right_interval [[1; 3]; [4; 7]; [8; 10]; [9; 12]] = [1; 2; -1; -1]);
  assert (find_right_interval [[-10; -5]; [-5; 0]; [0; 5]; [5; 10]] = [1; 2; 3; -1]);
  assert (find_right_interval [[5; 5]; [6; 6]; [7; 7]; [8; 8]] = [0; 1; 2; 3]);
  assert (find_right_interval [[3; 4]; [2; 3]; [1; 2]] = [-1; 0; 1]);
;;","medium","medium_141","medium"
"(**You are given a 2D integer array coordinates and an integer k, where coordinates[i] = [xi, yi] ar...
 * >>> count_pairs [[0; 0]; [1; 1]; [2; 2]; [3; 3]] 2
 * 2
 * >>> count_pairs [[1; 3]; [1; 3]; [1; 3]; [1; 3]; [1; 3]] 0
 * 10
 * >>> count_pairs [[1; 2]; [4; 2]; [1; 3]; [5; 2]] 5
 * 2
*)
let count_pairs (coordinates : int list list) (k : int) : int =","  0","let () =
  assert (count_pairs [[0; 0]; [1; 1]; [2; 2]; [3; 3]] 2 = 2);
  assert (count_pairs [[1; 3]; [1; 3]; [1; 3]; [1; 3]; [1; 3]] 0 = 10);
  assert (count_pairs [[1; 2]; [4; 2]; [1; 3]; [5; 2]] 5 = 2);
  assert (count_pairs [[0; 0]; [0; 1]; [1; 0]; [1; 1]] 1 = 4);
  assert (count_pairs [[1000000; 1000000]; [0; 0]; [500000; 500000]] 1000000 = 1);
  assert (count_pairs [[10; 10]; [20; 20]; [30; 30]; [40; 40]; [50; 50]; [60; 60]; [70; 70]; [80; 80]; [90; 90]; [100; 100]; [110; 110]] 20 = 3);
  assert (count_pairs [[0; 0]; [1; 1]; [2; 2]; [3; 3]; [4; 4]; [5; 5]; [6; 6]; [7; 7]; [8; 8]; [9; 9]; [10; 10]; [11; 11]; [12; 12]; [13; 13]; [14; 14]; [15; 15]] 15 = 0);
;;","medium","medium_172","medium"
"(**There is a new alien language that uses the English alphabet. However, the order of the letters i...
 * >>> alien_order [""wrt""; ""wrf""; ""er""; ""ett""; ""rftt""]
 * wertf
 * >>> alien_order [""abc""; ""ab""]
 * 
 * >>> alien_order [""a""; ""b""; ""ca""; ""cc""]
 * abc
*)
let alien_order (words : string list) : string =","  """"","let () =
  assert (alien_order [""wrt""; ""wrf""; ""er""; ""ett""; ""rftt""] = wertf);
  assert (alien_order [""a""; ""b""; ""ca""; ""cc""] = abc);
  assert (alien_order [""a""; ""b""; ""ca""] = abc);
  assert (alien_order [""z""; ""x""] = zx);
  assert (alien_order [""ab""; ""abc""; ""abcd""; ""abcde""; ""abcdef""] = abcdef);
;;","hard","hard_030","hard"
"(**You are given a positive integer n representing the number of nodes in a tree, numbered from 0 to...
 * >>> closest_node 5 [[0; 1]; [1; 2]; [2; 3]; [3; 4]] [[4; 0; 2]; [0; 4; 3]; [2; 3; 1]]
 * [2; 3; 2]
 * >>> closest_node 4 [[0; 1]; [1; 2]; [1; 3]] [[3; 2; 0]; [2; 3; 1]; [0; 3; 2]]
 * [1; 1; 1]
 * >>> closest_node 5 [[0; 1]; [1; 2]; [2; 3]; [3; 4]] [[4; 0; 2]; [0; 2; 1]; [1; 3; 2]]
 * [2; 1; 2]
*)
let closest_node (n : int) (edges : int list list) (query : int list list) : int list =","  []","let () =
  assert (closest_node 5 [[0; 1]; [1; 2]; [2; 3]; [3; 4]] [[4; 0; 2]; [0; 4; 3]; [2; 3; 1]] = [2; 3; 2]);
  assert (closest_node 4 [[0; 1]; [1; 2]; [1; 3]] [[3; 2; 0]; [2; 3; 1]; [0; 3; 2]] = [1; 1; 1]);
  assert (closest_node 5 [[0; 1]; [1; 2]; [2; 3]; [3; 4]] [[4; 0; 2]; [0; 2; 1]; [1; 3; 2]] = [2; 1; 2]);
  assert (closest_node 5 [[0; 1]; [1; 2]; [2; 3]; [2; 4]] [[0; 4; 1]; [3; 0; 2]; [4; 1; 3]] = [1; 2; 2]);
  assert (closest_node 3 [[0; 1]; [1; 2]] [[0; 1; 2]] = [1]);
  assert (closest_node 4 [[0; 1]; [1; 2]; [1; 3]] [[2; 3; 0]; [0; 3; 2]] = [1; 1]);
  assert (closest_node 7 [[0; 1]; [0; 2]; [0; 3]; [1; 4]; [2; 5]; [2; 6]] [[5; 3; 4]; [5; 3; 6]] = [0; 2]);
;;","hard","hard_015","hard"
"(**A substring is a contiguous (non-empty) sequence of characters within a string.
 * >>> count_vowel_substrings ""aeiou""
 * 1
 * >>> count_vowel_substrings ""aeiofvuaeiou""
 * 3
 * >>> count_vowel_substrings ""uoiea""
 * 1
*)
let count_vowel_substrings (word : string) : int =","  0","let () =
  assert (count_vowel_substrings ""aeiou"" = 1);
  assert (count_vowel_substrings ""aeiofvuaeiou"" = 3);
  assert (count_vowel_substrings ""uoiea"" = 1);
  assert (count_vowel_substrings ""aeiouxaeeiaouoieua"" = 28);
  assert (count_vowel_substrings ""aeiaaioaaaaeiiiiouuuooaauuaeiu"" = 175);
  assert (count_vowel_substrings ""aeiaaioaaaaeiiiiouuuoo"" = 55);
  assert (count_vowel_substrings ""aeiouaeiouaeiou"" = 66);
;;","easy","easy_083","easy"
"(**Given strings s1 and s2, return the minimum contiguous substring part of s1, so that s2 is a subs...
 * >>> min_window ""abcd"" ""abcd""
 * abcd
 * >>> min_window ""abcbabc"" ""abc""
 * abc
 * >>> min_window ""abcdefgh"" ""efg""
 * efg
*)
let min_window (s1 : string) (s2 : string) : string =","  """"","let () =
  assert (min_window ""abcd"" ""abcd"" = abcd);
  assert (min_window ""abcbabc"" ""abc"" = abc);
  assert (min_window ""abcdefgh"" ""efg"" = efg);
  assert (min_window ""zzzzz"" ""z"" = z);
  assert (min_window ""abcdebdde"" ""bde"" = bcde);
;;","hard","hard_028","hard"
"(**You are given a 0-indexed integer array nums.
 * >>> maximum_triplet_value [3; 2; 1; 5; 4; 6]
 * 12
 * >>> maximum_triplet_value [10; 20; 3; 40; 5; 60; 7; 80; 9; 10]
 * 4240
 * >>> maximum_triplet_value [12; 6; 1; 2; 7]
 * 77
*)
let maximum_triplet_value (nums : int list) : int =","  0","let () =
  assert (maximum_triplet_value [3; 2; 1; 5; 4; 6] = 12);
  assert (maximum_triplet_value [10; 20; 3; 40; 5; 60; 7; 80; 9; 10] = 4240);
  assert (maximum_triplet_value [12; 6; 1; 2; 7] = 77);
  assert (maximum_triplet_value [8; 6; 4; 2; 10; 9; 7; 5; 3; 1] = 60);
  assert (maximum_triplet_value [1; 2; 3; 4; 5; 6; 7; 8; 9; 100] = 0);
  assert (maximum_triplet_value [10; 9; 8; 7; 6; 5; 4; 3; 2; 1] = 20);
  assert (maximum_triplet_value [9; 8; 7; 6; 5; 4; 3; 2; 1] = 16);
;;","easy","easy_152","easy"
"(**Given a string s, return true if s is a good string, or false otherwise.
 * >>> are_occurrences_equal ""aabbccc""
 * false
 * >>> are_occurrences_equal ""abacbc""
 * true
 * >>> are_occurrences_equal ""abcabcabc""
 * true
*)
let are_occurrences_equal (s : string) : bool =","  false","let () =
  assert (are_occurrences_equal ""aabbccc"" = false);
  assert (are_occurrences_equal ""abacbc"" = true);
  assert (are_occurrences_equal ""abcabcabc"" = true);
  assert (are_occurrences_equal ""qqqq"" = true);
  assert (are_occurrences_equal ""aabbcc"" = true);
  assert (are_occurrences_equal ""zzzzzzzzzz"" = true);
  assert (are_occurrences_equal ""aabbc"" = false);
;;","easy","easy_188","easy"
"(**Given a linked list, swap every two adjacent nodes and return its head. You must solve the proble...
 * >>> swap_pairs [1; 2; 3; 4]
 * [2; 1; 4; 3]
 * >>> swap_pairs [1; 2; 3]
 * [2; 1; 3]
 * >>> swap_pairs []
 * None
*)
let swap_pairs (head : 'a option) : 'a option =","  None","let () =
  assert (swap_pairs [1; 2; 3; 4] = [2; 1; 4; 3]);
  assert (swap_pairs [1; 2; 3] = [2; 1; 3]);
  assert (swap_pairs [] = None);
  assert (swap_pairs [1] = [1]);
  assert (swap_pairs [1; 3; 5; 7; 9; 11; 13; 15; 17; 19; 21] = [3; 1; 7; 5; 11; 9; 15; 13; 19; 17; 21]);
  assert (swap_pairs [1; 2; 2; 3; 3; 4; 4; 5; 5; 6; 6] = [2; 1; 3; 2; 4; 3; 5; 4; 6; 5; 6]);
  assert (swap_pairs [0; 0; 0; 0; 0; 0; 0; 0; 0; 0] = [0; 0; 0; 0; 0; 0; 0; 0; 0; 0]);
;;","medium","medium_012","medium"
"(**Given two strings word1 and word2, return the minimum number of steps required to make word1 and ...
 * >>> min_distance 'abc' 'def'
 * 6
 * >>> min_distance ""abcde"" ""fghij""
 * 10
 * >>> min_distance ""abcdefghijklmnopqrstuvwxyz"" ""zyxwvutsrqponmlkjihgfedcba""
 * 50
*)
let min_distance (word1 : string) (word2 : string) : int =","  0","let () =
  assert (min_distance 'abc' 'def' = 6);
  assert (min_distance ""abcde"" ""fghij"" = 10);
  assert (min_distance ""abcdefghijklmnopqrstuvwxyz"" ""zyxwvutsrqponmlkjihgfedcba"" = 50);
  assert (min_distance ""sea"" ""eat"" = 2);
  assert (min_distance 'abcd' 'dcba' = 6);
  assert (min_distance 'leetcode' 'etco' = 4);
  assert (min_distance ""abc"" ""abc"" = 0);
;;","medium","medium_164","medium"
"(**Given a string expression of numbers and operators, return all possible results from computing al...
 * >>> diff_ways_to_compute ""4*5-2*3""
 * [-4; 36; 14; 36; 54]
 * >>> diff_ways_to_compute ""9-3*2+1""
 * [0; 2; 18; 4; 13]
 * >>> diff_ways_to_compute ""3+5/2*3""
 * []
*)
let diff_ways_to_compute (expression : string) : int list =","  []","let () =
  assert (diff_ways_to_compute ""4*5-2*3"" = [-4; 36; 14; 36; 54]);
  assert (diff_ways_to_compute ""9-3*2+1"" = [0; 2; 18; 4; 13]);
  assert (diff_ways_to_compute ""3+5/2*3"" = []);
  assert (diff_ways_to_compute ""1+1+1+1"" = [4; 4; 4; 4; 4]);
  assert (diff_ways_to_compute ""9*8+7*6-5*4+3*2-1"" = [-1755; -2385; -1755; -2385; -3645; -999; -1125; -1755; -999; -2637; -3897; -1125; -3897; -2385; 513; 639; 513; 639; 891; -621; -495; 513; 639; -1755; -999; 513; -621; 513; -2763; -4023; -1251; -4023; -2511; 639; 891; -495; 639; -3645; -2133; 891; -1377; 891; 135; 45; 135; 45; -135; 243; 225; 135; 243; 9; -171; 225; -171; 45; 513; 639; 513; 639; 891; 2403; 3069; 2403; 3069; 4401; -783; -765; 351; 369; 297; 315; 351; 369; 1431; 1449; -1755; -999; 513; -621; 513; 135; 243; 513; 2403; -783; 351; 297; 351; 1431; -2709; -3969; -1197; -3969; -2457; 693; 945; -441; 693; -3591; -2079; 945; -1323; 945; -9; -189; 207; -189; 27; 693; 945; 3393; 4725; -765; 369; 315; 369; 1449; -3591; -2079; 945; -1323; 945; 189; 405; 945; 4725; -1647; 621; 513; 621; 2781; -3915; -5265; -3915; -5265; -7965; -2295; -2565; -3915; -2295; -5805; -8505; -2565; -8505; -5265; 945; 1215; 945; 1215; 1755; -1485; -1215; 945; 1215; -3915; -2295; 945; -1485; 945; -6075; -8775; -2835; -8775; -5535; 1215; 1755; -1215; 1215; -7965; -4725; 1755; -3105; 1755; 135; 45; 135; 45; -135; 243; 225; 135; 243; 9; -171; 225; -171; 45; 495; 405; 495; 405; 225; 603; 585; 495; 603; 369; 189; 585; 189; 405; 945; 1215; 945; 1215; 1755; 2835; 3645; 2835; 3645; 5265; 945; 1215; 945; 1215; 1755; 2835; 3645; 2835; 3645; 5265; 5355; 6885; 5355; 6885; 9945; -783; -765; 351; 369; 297; 315; 351; 369; 1431; 1449; -1863; -1845; 567; 585; 297; 315; 657; 675; 567; 585; 1647; 1665; 567; 585; 1647; 1665; 3087; 3105; -1755; -999; 513; -621; 513; 135; 243; 513; 2403; -783; 351; 297; 351; 1431; -3915; -2295; 945; -1485; 945; 135; 243; 495; 603; 945; 2835; 945; 2835; 5355; -783; 351; 297; 351; 1431; -1863; 567; 297; 657; 567; 1647; 567; 1647; 3087; -2709; -3969; -1197; -3969; -2457; 693; 945; -441; 693; -3591; -2079; 945; -1323; 945; -9; -189; 207; -189; 27; 693; 945; 3393; 4725; -765; 369; 315; 369; 1449; -3591; -2079; 945; -1323; 945; 189; 405; 945; 4725; -1647; 621; 513; 621; 2781; -5949; -8649; -2709; -8649; -5409; 1341; 1881; -1089; 1341; -7839; -4599; 1881; -2979; 1881; -9; -189; 207; -189; 27; 351; 171; 567; 171; 387; 1341; 1881; 4041; 5661; 1341; 1881; 4041; 5661; 7641; 10701; -765; 369; 315; 369; 1449; -1845; 585; 315; 675; 585; 1665; 585; 1665; 3105; -3519; -2007; 1017; -1251; 1017; 261; 477; 1017; 4797; -1575; 693; 585; 693; 2853; -7839; -4599; 1881; -2979; 1881; 261; 477; 981; 1197; 1881; 5661; 1881; 5661; 10701; -1575; 693; 585; 693; 2853; -3735; 1125; 585; 1305; 1125; 3285; 1125; 3285; 6165; -131; -201; -131; -201; -341; -47; -61; -131; -47; -229; -369; -61; -369; -201; 121; 135; 121; 135; 163; -5; 9; 121; 135; -131; -47; 121; -5; 121; -243; -383; -75; -383; -215; 135; 163; 9; 135; -341; -173; 163; -89; 163; 79; 69; 79; 69; 49; 91; 89; 79; 91; 65; 45; 89; 45; 69; 121; 135; 121; 135; 163; 331; 405; 331; 405; 553; -23; -21; 103; 105; 97; 99; 103; 105; 223; 225; -131; -47; 121; -5; 121; 79; 91; 121; 331; -23; 103; 97; 103; 223; -237; -377; -69; -377; -209; 141; 169; 15; 141; -335; -167; 169; -83; 169; 63; 43; 87; 43; 67; 141; 169; 441; 589; -21; 105; 99; 105; 225; -335; -167; 169; -83; 169; 85; 109; 169; 589; -119; 133; 121; 133; 373; -3915; -5265; -3915; -5265; -7965; -2295; -2565; -3915; -2295; -5805; -8505; -2565; -8505; -5265; 945; 1215; 945; 1215; 1755; -1485; -1215; 945; 1215; -3915; -2295; 945; -1485; 945; -6075; -8775; -2835; -8775; -5535; 1215; 1755; -1215; 1215; -7965; -4725; 1755; -3105; 1755; -2291; -3081; -2291; -3081; -4661; -1343; -1501; -2291; -1343; -3397; -4977; -1501; -4977; -3081; 553; 711; 553; 711; 1027; -869; -711; 553; 711; -2291; -1343; 553; -869; 553; -3555; -5135; -1659; -5135; -3239; 711; 1027; -711; 711; -4661; -2765; 1027; -1817; 1027; 415; 405; 415; 405; 385; 427; 425; 415; 427; 401; 381; 425; 381; 405; 775; 765; 775; 765; 745; 787; 785; 775; 787; 761; 741; 785; 741; 765; 79; 69; 79; 69; 49; 91; 89; 79; 91; 65; 45; 89; 45; 69; 775; 765; 775; 765; 745; 787; 785; 775; 787; 761; 741; 785; 741; 765; 439; 429; 439; 429; 409; 451; 449; 439; 451; 425; 405; 449; 405; 429; 945; 1215; 945; 1215; 1755; 2835; 3645; 2835; 3645; 5265; 945; 1215; 945; 1215; 1755; 2835; 3645; 2835; 3645; 5265; 5355; 6885; 5355; 6885; 9945; 553; 711; 553; 711; 1027; 763; 981; 763; 981; 1417; 945; 1215; 945; 1215; 1755; 553; 711; 553; 711; 1027; 3115; 4005; 3115; 4005; 5785; 5635; 7245; 5635; 7245; 10465; 763; 981; 763; 981; 1417; 5635; 7245; 5635; 7245; 10465; 3283; 4221; 3283; 4221; 6097; -807; -805; 327; 329; 273; 275; 327; 329; 1407; 1409; -1887; -1885; 543; 545; 273; 275; 633; 635; 543; 545; 1623; 1625; 543; 545; 1623; 1625; 3063; 3065; -23; -21; 103; 105; 97; 99; 103; 105; 223; 225; -1887; -1885; 543; 545; -1103; -1101; 319; 321; 433; 435; 793; 795; 97; 99; 793; 795; 457; 459; 543; 545; 1623; 1625; 543; 545; 1623; 1625; 3063; 3065; 319; 321; 439; 441; 543; 545; 319; 321; 1783; 1785; 3223; 3225; 439; 441; 3223; 3225; 1879; 1881; -1755; -999; 513; -621; 513; 135; 243; 513; 2403; -783; 351; 297; 351; 1431; -3915; -2295; 945; -1485; 945; 135; 243; 495; 603; 945; 2835; 945; 2835; 5355; -783; 351; 297; 351; 1431; -1863; 567; 297; 657; 567; 1647; 567; 1647; 3087; -131; -47; 121; -5; 121; 79; 91; 121; 331; -23; 103; 97; 103; 223; -3915; -2295; 945; -1485; 945; -2291; -1343; 553; -869; 553; 415; 427; 775; 787; 79; 91; 775; 787; 439; 451; 945; 2835; 945; 2835; 5355; 553; 763; 945; 553; 3115; 5635; 763; 5635; 3283; -807; 327; 273; 327; 1407; -1887; 543; 273; 633; 543; 1623; 543; 1623; 3063; -23; 103; 97; 103; 223; -1887; 543; -1103; 319; 433; 793; 97; 793; 457; 543; 1623; 543; 1623; 3063; 319; 439; 543; 319; 1783; 3223; 439; 3223; 1879; -2701; -3961; -1189; -3961; -2449; 701; 953; -433; 701; -3583; -2071; 953; -1315; 953; -1; -181; 215; -181; 35; 701; 953; 3401; 4733; -757; 377; 323; 377; 1457; -3583; -2071; 953; -1315; 953; 197; 413; 953; 4733; -1639; 629; 521; 629; 2789; -5941; -8641; -2701; -8641; -5401; 1349; 1889; -1081; 1349; -7831; -4591; 1889; -2971; 1889; -1; -181; 215; -181; 35; 359; 179; 575; 179; 395; 1349; 1889; 4049; 5669; 1349; 1889; 4049; 5669; 7649; 10709; -757; 377; 323; 377; 1457; -1837; 593; 323; 683; 593; 1673; 593; 1673; 3113; -3511; -1999; 1025; -1243; 1025; 269; 485; 1025; 4805; -1567; 701; 593; 701; 2861; -7831; -4591; 1889; -2971; 1889; 269; 485; 989; 1205; 1889; 5669; 1889; 5669; 10709; -1567; 701; 593; 701; 2861; -3727; 1133; 593; 1313; 1133; 3293; 1133; 3293; 6173; -237; -377; -69; -377; -209; 141; 169; 15; 141; -335; -167; 169; -83; 169; 63; 43; 87; 43; 67; 141; 169; 441; 589; -21; 105; 99; 105; 225; -335; -167; 169; -83; 169; 85; 109; 169; 589; -119; 133; 121; 133; 373; -5941; -8641; -2701; -8641; -5401; 1349; 1889; -1081; 1349; -7831; -4591; 1889; -2971; 1889; -3477; -5057; -1581; -5057; -3161; 789; 1105; -633; 789; -4583; -2687; 1105; -1739; 1105; 399; 379; 423; 379; 403; 759; 739; 783; 739; 763; 63; 43; 87; 43; 67; 759; 739; 783; 739; 763; 423; 403; 447; 403; 427; 1349; 1889; 4049; 5669; 1349; 1889; 4049; 5669; 7649; 10709; 789; 1105; 1089; 1525; 1349; 1889; 789; 1105; 4449; 6229; 8049; 11269; 1089; 1525; 8049; 11269; 4689; 6565; -805; 329; 275; 329; 1409; -1885; 545; 275; 635; 545; 1625; 545; 1625; 3065; -21; 105; 99; 105; 225; -1885; 545; -1101; 321; 435; 795; 99; 795; 459; 545; 1625; 545; 1625; 3065; 321; 441; 545; 321; 1785; 3225; 441; 3225; 1881; -3511; -1999; 1025; -1243; 1025; 269; 485; 1025; 4805; -1567; 701; 593; 701; 2861; -7831; -4591; 1889; -2971; 1889; 269; 485; 989; 1205; 1889; 5669; 1889; 5669; 10709; -1567; 701; 593; 701; 2861; -3727; 1133; 593; 1313; 1133; 3293; 1133; 3293; 6173; -263; -95; 241; -11; 241; 157; 181; 241; 661; -47; 205; 193; 205; 445; -7831; -4591; 1889; -2971; 1889; -4583; -2687; 1105; -1739; 1105; 829; 853; 1549; 1573; 157; 181; 1549; 1573; 877; 901; 1889; 5669; 1889; 5669; 10709; 1105; 1525; 1889; 1105; 6229; 11269; 1525; 11269; 6565; -1615; 653; 545; 653; 2813; -3775; 1085; 545; 1265; 1085; 3245; 1085; 3245; 6125; -47; 205; 193; 205; 445; -3775; 1085; -2207; 637; 865; 1585; 193; 1585; 913; 1085; 3245; 1085; 3245; 6125; 637; 877; 1085; 637; 3565; 6445; 877; 6445; 3757]);
  assert (diff_ways_to_compute ""10+5-3*2"" = [9; 14; 9; 24; 24]);
  assert (diff_ways_to_compute ""3+5*2"" = [13; 16]);
;;","medium","medium_094","medium"
"(**You are given an integer array ribbons, where ribbons[i] represents the length of the ith ribbon,...
 * >>> max_length [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 15
 * 3
 * >>> max_length [1; 1; 1; 1; 1] 10
 * 0
 * >>> max_length [5; 5; 5; 5; 5] 5
 * 5
*)
let max_length (ribbons : int list) (k : int) : int =","  0","let () =
  assert (max_length [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 15 = 3);
  assert (max_length [1; 1; 1; 1; 1] 10 = 0);
  assert (max_length [5; 5; 5; 5; 5] 5 = 5);
  assert (max_length [1; 2; 3; 4; 5] 1 = 5);
  assert (max_length [1; 2; 3; 4; 5] 15 = 1);
  assert (max_length [100000; 100000; 100000] 100000 = 2);
  assert (max_length [10; 10; 10; 10] 8 = 5);
;;","medium","medium_048","medium"
"(**A binary watch has 4 LEDs on the top to represent the hours (0-11), and 6 LEDs on the bottom to r...
 * >>> read_binary_watch 5
 * ['0:31'; '0:47'; '0:55'; '0:59'; '1:15'; '1:23'; '1:27'; '1:29'; '1:30'; '1:39'; '1:43'; '1:45'; '1:46'; '1:51'; '1:53'; '1:54'; '1:57'; '1:58'; '2:15'; '2:23'; '2:27'; '2:29'; '2:30'; '2:39'; '2:43'; '2:45'; '2:46'; '2:51'; '2:53'; '2:54'; '2:57'; '2:58'; '3:07'; '3:11'; '3:13'; '3:14'; '3:19'; '3:21'; '3:22'; '3:25'; '3:26'; '3:28'; '3:35'; '3:37'; '3:38'; '3:41'; '3:42'; '3:44'; '3:49'; '3:50'; '3:52'; '3:56'; '4:15'; '4:23'; '4:27'; '4:29'; '4:30'; '4:39'; '4:43'; '4:45'; '4:46'; '4:51'; '4:53'; '4:54'; '4:57'; '4:58'; '5:07'; '5:11'; '5:13'; '5:14'; '5:19'; '5:21'; '5:22'; '5:25'; '5:26'; '5:28'; '5:35'; '5:37'; '5:38'; '5:41'; '5:42'; '5:44'; '5:49'; '5:50'; '5:52'; '5:56'; '6:07'; '6:11'; '6:13'; '6:14'; '6:19'; '6:21'; '6:22'; '6:25'; '6:26'; '6:28'; '6:35'; '6:37'; '6:38'; '6:41'; '6:42'; '6:44'; '6:49'; '6:50'; '6:52'; '6:56'; '7:03'; '7:05'; '7:06'; '7:09'; '7:10'; '7:12'; '7:17'; '7:18'; '7:20'; '7:24'; '7:33'; '7:34'; '7:36'; '7:40'; '7:48'; '8:15'; '8:23'; '8:27'; '8:29'; '8:30'; '8:39'; '8:43'; '8:45'; '8:46'; '8:51'; '8:53'; '8:54'; '8:57'; '8:58'; '9:07'; '9:11'; '9:13'; '9:14'; '9:19'; '9:21'; '9:22'; '9:25'; '9:26'; '9:28'; '9:35'; '9:37'; '9:38'; '9:41'; '9:42'; '9:44'; '9:49'; '9:50'; '9:52'; '9:56'; '10:07'; '10:11'; '10:13'; '10:14'; '10:19'; '10:21'; '10:22'; '10:25'; '10:26'; '10:28'; '10:35'; '10:37'; '10:38'; '10:41'; '10:42'; '10:44'; '10:49'; '10:50'; '10:52'; '10:56'; '11:03'; '11:05'; '11:06'; '11:09'; '11:10'; '11:12'; '11:17'; '11:18'; '11:20'; '11:24'; '11:33'; '11:34'; '11:36'; '11:40'; '11:48']
 * >>> read_binary_watch 8
 * ['7:31'; '7:47'; '7:55'; '7:59'; '11:31'; '11:47'; '11:55'; '11:59']
 * >>> read_binary_watch 0
 * ['0:00']
*)
let read_binary_watch (turnedOn : int) : string list =","  []","let () =
  assert (read_binary_watch 5 = ['0:31'; '0:47'; '0:55'; '0:59'; '1:15'; '1:23'; '1:27'; '1:29'; '1:30'; '1:39'; '1:43'; '1:45'; '1:46'; '1:51'; '1:53'; '1:54'; '1:57'; '1:58'; '2:15'; '2:23'; '2:27'; '2:29'; '2:30'; '2:39'; '2:43'; '2:45'; '2:46'; '2:51'; '2:53'; '2:54'; '2:57'; '2:58'; '3:07'; '3:11'; '3:13'; '3:14'; '3:19'; '3:21'; '3:22'; '3:25'; '3:26'; '3:28'; '3:35'; '3:37'; '3:38'; '3:41'; '3:42'; '3:44'; '3:49'; '3:50'; '3:52'; '3:56'; '4:15'; '4:23'; '4:27'; '4:29'; '4:30'; '4:39'; '4:43'; '4:45'; '4:46'; '4:51'; '4:53'; '4:54'; '4:57'; '4:58'; '5:07'; '5:11'; '5:13'; '5:14'; '5:19'; '5:21'; '5:22'; '5:25'; '5:26'; '5:28'; '5:35'; '5:37'; '5:38'; '5:41'; '5:42'; '5:44'; '5:49'; '5:50'; '5:52'; '5:56'; '6:07'; '6:11'; '6:13'; '6:14'; '6:19'; '6:21'; '6:22'; '6:25'; '6:26'; '6:28'; '6:35'; '6:37'; '6:38'; '6:41'; '6:42'; '6:44'; '6:49'; '6:50'; '6:52'; '6:56'; '7:03'; '7:05'; '7:06'; '7:09'; '7:10'; '7:12'; '7:17'; '7:18'; '7:20'; '7:24'; '7:33'; '7:34'; '7:36'; '7:40'; '7:48'; '8:15'; '8:23'; '8:27'; '8:29'; '8:30'; '8:39'; '8:43'; '8:45'; '8:46'; '8:51'; '8:53'; '8:54'; '8:57'; '8:58'; '9:07'; '9:11'; '9:13'; '9:14'; '9:19'; '9:21'; '9:22'; '9:25'; '9:26'; '9:28'; '9:35'; '9:37'; '9:38'; '9:41'; '9:42'; '9:44'; '9:49'; '9:50'; '9:52'; '9:56'; '10:07'; '10:11'; '10:13'; '10:14'; '10:19'; '10:21'; '10:22'; '10:25'; '10:26'; '10:28'; '10:35'; '10:37'; '10:38'; '10:41'; '10:42'; '10:44'; '10:49'; '10:50'; '10:52'; '10:56'; '11:03'; '11:05'; '11:06'; '11:09'; '11:10'; '11:12'; '11:17'; '11:18'; '11:20'; '11:24'; '11:33'; '11:34'; '11:36'; '11:40'; '11:48']);
  assert (read_binary_watch 8 = ['7:31'; '7:47'; '7:55'; '7:59'; '11:31'; '11:47'; '11:55'; '11:59']);
  assert (read_binary_watch 0 = ['0:00']);
  assert (read_binary_watch 9 = []);
  assert (read_binary_watch 3 = ['0:07'; '0:11'; '0:13'; '0:14'; '0:19'; '0:21'; '0:22'; '0:25'; '0:26'; '0:28'; '0:35'; '0:37'; '0:38'; '0:41'; '0:42'; '0:44'; '0:49'; '0:50'; '0:52'; '0:56'; '1:03'; '1:05'; '1:06'; '1:09'; '1:10'; '1:12'; '1:17'; '1:18'; '1:20'; '1:24'; '1:33'; '1:34'; '1:36'; '1:40'; '1:48'; '2:03'; '2:05'; '2:06'; '2:09'; '2:10'; '2:12'; '2:17'; '2:18'; '2:20'; '2:24'; '2:33'; '2:34'; '2:36'; '2:40'; '2:48'; '3:01'; '3:02'; '3:04'; '3:08'; '3:16'; '3:32'; '4:03'; '4:05'; '4:06'; '4:09'; '4:10'; '4:12'; '4:17'; '4:18'; '4:20'; '4:24'; '4:33'; '4:34'; '4:36'; '4:40'; '4:48'; '5:01'; '5:02'; '5:04'; '5:08'; '5:16'; '5:32'; '6:01'; '6:02'; '6:04'; '6:08'; '6:16'; '6:32'; '7:00'; '8:03'; '8:05'; '8:06'; '8:09'; '8:10'; '8:12'; '8:17'; '8:18'; '8:20'; '8:24'; '8:33'; '8:34'; '8:36'; '8:40'; '8:48'; '9:01'; '9:02'; '9:04'; '9:08'; '9:16'; '9:32'; '10:01'; '10:02'; '10:04'; '10:08'; '10:16'; '10:32'; '11:00']);
  assert (read_binary_watch 10 = []);
  assert (read_binary_watch 4 = ['0:15'; '0:23'; '0:27'; '0:29'; '0:30'; '0:39'; '0:43'; '0:45'; '0:46'; '0:51'; '0:53'; '0:54'; '0:57'; '0:58'; '1:07'; '1:11'; '1:13'; '1:14'; '1:19'; '1:21'; '1:22'; '1:25'; '1:26'; '1:28'; '1:35'; '1:37'; '1:38'; '1:41'; '1:42'; '1:44'; '1:49'; '1:50'; '1:52'; '1:56'; '2:07'; '2:11'; '2:13'; '2:14'; '2:19'; '2:21'; '2:22'; '2:25'; '2:26'; '2:28'; '2:35'; '2:37'; '2:38'; '2:41'; '2:42'; '2:44'; '2:49'; '2:50'; '2:52'; '2:56'; '3:03'; '3:05'; '3:06'; '3:09'; '3:10'; '3:12'; '3:17'; '3:18'; '3:20'; '3:24'; '3:33'; '3:34'; '3:36'; '3:40'; '3:48'; '4:07'; '4:11'; '4:13'; '4:14'; '4:19'; '4:21'; '4:22'; '4:25'; '4:26'; '4:28'; '4:35'; '4:37'; '4:38'; '4:41'; '4:42'; '4:44'; '4:49'; '4:50'; '4:52'; '4:56'; '5:03'; '5:05'; '5:06'; '5:09'; '5:10'; '5:12'; '5:17'; '5:18'; '5:20'; '5:24'; '5:33'; '5:34'; '5:36'; '5:40'; '5:48'; '6:03'; '6:05'; '6:06'; '6:09'; '6:10'; '6:12'; '6:17'; '6:18'; '6:20'; '6:24'; '6:33'; '6:34'; '6:36'; '6:40'; '6:48'; '7:01'; '7:02'; '7:04'; '7:08'; '7:16'; '7:32'; '8:07'; '8:11'; '8:13'; '8:14'; '8:19'; '8:21'; '8:22'; '8:25'; '8:26'; '8:28'; '8:35'; '8:37'; '8:38'; '8:41'; '8:42'; '8:44'; '8:49'; '8:50'; '8:52'; '8:56'; '9:03'; '9:05'; '9:06'; '9:09'; '9:10'; '9:12'; '9:17'; '9:18'; '9:20'; '9:24'; '9:33'; '9:34'; '9:36'; '9:40'; '9:48'; '10:03'; '10:05'; '10:06'; '10:09'; '10:10'; '10:12'; '10:17'; '10:18'; '10:20'; '10:24'; '10:33'; '10:34'; '10:36'; '10:40'; '10:48'; '11:01'; '11:02'; '11:04'; '11:08'; '11:16'; '11:32']);
;;","easy","easy_139","easy"
"(**You want to schedule a list of jobs in d days. Jobs are dependent (i.e To work on the ith job, yo...
 * >>> min_difficulty [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 10
 * 55
 * >>> min_difficulty [300; 500; 1000] 3
 * 1800
 * >>> min_difficulty [6; 5; 4; 3; 2; 1] 2
 * 7
*)
let min_difficulty (jobDifficulty : int list) (d : int) : int =","  0","let () =
  assert (min_difficulty [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 10 = 55);
  assert (min_difficulty [300; 500; 1000] 3 = 1800);
  assert (min_difficulty [6; 5; 4; 3; 2; 1] 2 = 7);
  assert (min_difficulty [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 5 = 20);
  assert (min_difficulty [15; 97; 88; 92; 49] 2 = 112);
  assert (min_difficulty [7; 1; 7; 1; 7; 1] 3 = 15);
  assert (min_difficulty [5; 5; 5; 5; 5; 5; 5; 5; 5; 5] 5 = 25);
;;","hard","hard_038","hard"
"(**Given an integer array hours representing times in hours, return an integer denoting the number o...
 * >>> count_complete_day_pairs [5; 19; 15; 1; 23; 7; 17; 11; 3; 21; 9; 13; 20; 18; 4; 16; 8; 12; 6; 22; 14; 2; 10; 10; 10]
 * 13
 * >>> count_complete_day_pairs [24; 48; 72; 96; 120; 144; 168; 192; 216; 240; 264; 288; 312; 336; 360; 384; 408; 432; 456; 480; 504; 528; 552; 576; 600]
 * 300
 * >>> count_complete_day_pairs [24; 48; 72; 96; 120]
 * 10
*)
let count_complete_day_pairs (hours : int list) : int =","  0","let () =
  assert (count_complete_day_pairs [5; 19; 15; 1; 23; 7; 17; 11; 3; 21; 9; 13; 20; 18; 4; 16; 8; 12; 6; 22; 14; 2; 10; 10; 10] = 13);
  assert (count_complete_day_pairs [24; 48; 72; 96; 120; 144; 168; 192; 216; 240; 264; 288; 312; 336; 360; 384; 408; 432; 456; 480; 504; 528; 552; 576; 600] = 300);
  assert (count_complete_day_pairs [24; 48; 72; 96; 120] = 10);
  assert (count_complete_day_pairs [1; 2; 3; 23; 47; 71] = 3);
  assert (count_complete_day_pairs [10; 10; 10; 10; 10; 10; 10; 10; 10; 10] = 0);
  assert (count_complete_day_pairs [12; 12; 30; 24; 24] = 2);
  assert (count_complete_day_pairs [1; 23; 2; 22; 3; 21; 4; 20; 5; 19] = 5);
;;","medium","medium_023","medium"
"(**Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. ...
 * >>> search_matrix [[-5; -4; -3; -2; -1]; [5; 6; 7; 8; 9]; [15; 16; 17; 18; 19]; [25; 26; 27; 28; 29]; [35; 36; 37; 38; 39]] 0
 * false
 * >>> search_matrix [[1; 4; 7; 11; 15]; [2; 5; 8; 12; 19]; [3; 6; 9; 16; 22]; [10; 13; 14; 17; 24]; [18; 21; 23; 26; 30]] 20
 * false
 * >>> search_matrix [[-10; -5; -3; -1; -1]; [0; 1; 1; 2; 2]; [3; 3; 4; 4; 5]; [6; 7; 8; 8; 9]; [10; 10; 12; 13; 15]] 8
 * true
*)
let search_matrix (matrix : int list list) (target : int) : bool =","  false","let () =
  assert (search_matrix [[-5; -4; -3; -2; -1]; [5; 6; 7; 8; 9]; [15; 16; 17; 18; 19]; [25; 26; 27; 28; 29]; [35; 36; 37; 38; 39]] 0 = false);
  assert (search_matrix [[1; 4; 7; 11; 15]; [2; 5; 8; 12; 19]; [3; 6; 9; 16; 22]; [10; 13; 14; 17; 24]; [18; 21; 23; 26; 30]] 20 = false);
  assert (search_matrix [[-10; -5; -3; -1; -1]; [0; 1; 1; 2; 2]; [3; 3; 4; 4; 5]; [6; 7; 8; 8; 9]; [10; 10; 12; 13; 15]] 8 = true);
  assert (search_matrix [[1; 3; 5; 7]; [10; 11; 16; 20]; [23; 30; 34; 60]] 3 = true);
  assert (search_matrix [[1; 4; 7; 11; 15]; [2; 5; 8; 12; 19]; [3; 6; 9; 16; 22]; [10; 13; 14; 17; 24]; [18; 21; 23; 26; 30]] 5 = true);
  assert (search_matrix [[-5; -4; -3; -2; -1]; [5; 6; 7; 8; 9]; [10; 11; 12; 13; 14]; [15; 16; 17; 18; 19]; [20; 21; 22; 23; 24]] 0 = false);
  assert (search_matrix [[-10; -8; -6; -4; -3]; [-9; -7; -5; -3; -1]; [-4; -2; 0; 2; 4]; [-3; 1; 3; 5; 7]; [2; 4; 6; 8; 10]] 0 = true);
;;","medium","medium_101","medium"
"(**You are given a string s, which is known to be a concatenation of anagrams of some string t.
 * >>> min_anagram_length ""zzzzzzzzz""
 * 1
 * >>> min_anagram_length ""abcdefghijklmnopqrstuvwxyz""
 * 26
 * >>> min_anagram_length ""zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz""
 * 1
*)
let min_anagram_length (s : string) : int =","  0","let () =
  assert (min_anagram_length ""zzzzzzzzz"" = 1);
  assert (min_anagram_length ""abcdefghijklmnopqrstuvwxyz"" = 26);
  assert (min_anagram_length ""zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz"" = 1);
  assert (min_anagram_length ""abababab"" = 2);
  assert (min_anagram_length ""a"" = 1);
  assert (min_anagram_length ""abcabcabcabc"" = 3);
  assert (min_anagram_length ""zzzzzzzzzzzzzzzzzzzz"" = 1);
;;","medium","medium_036","medium"
"(**Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the ...
 * >>> get_minimum_difference [4; 2; 6; 1; 3]
 * 1
 * >>> get_minimum_difference [1; 30; null; 10; null; null; 15; null; 18]
 * -29
 * >>> get_minimum_difference [1; null; 2; null; 3; null; 4; null; 5]
 * 1
*)
let get_minimum_difference (root : 'a option) : int =","  0","let () =
  assert (get_minimum_difference [4; 2; 6; 1; 3] = 1);
  assert (get_minimum_difference [1; 30; null; 10; null; null; 15; null; 18] = -29);
  assert (get_minimum_difference [1; null; 2; null; 3; null; 4; null; 5] = 1);
  assert (get_minimum_difference [236; 104; 701; null; 227; null; 911] = 9);
  assert (get_minimum_difference [5; 4; 7] = 1);
  assert (get_minimum_difference [1; 0; 48; null; null; 12; 49] = 1);
  assert (get_minimum_difference [5; 3; 7; 2; 4; 6; 8] = 1);
;;","easy","easy_186","easy"
"(**You are given two strings s1 and s2 of equal length consisting of letters ""x"" and ""y"" only. Your ...
 * >>> minimum_swap ""xyyy"" ""yxxx""
 * 3
 * >>> minimum_swap ""xx"" ""yy""
 * 1
 * >>> minimum_swap ""xxyy"" ""xyxy""
 * 2
*)
let minimum_swap (s1 : string) (s2 : string) : int =","  0","let () =
  assert (minimum_swap ""xyyy"" ""yxxx"" = 3);
  assert (minimum_swap ""xx"" ""yy"" = 1);
  assert (minimum_swap ""xxyy"" ""xyxy"" = 2);
  assert (minimum_swap ""xxyyxyxyxx"" ""xyyxyxxxyx"" = 4);
  assert (minimum_swap ""xxxyyy"" ""yyyxxx"" = 4);
  assert (minimum_swap ""xyyx"" ""xxyy"" = 2);
  assert (minimum_swap ""yx"" ""xy"" = 2);
;;","medium","medium_022","medium"
"(**You have n packages that you are trying to place in boxes, one package in each box. There are m s...
 * >>> min_wasted_space [10; 20; 30] [[10]; [20]; [30]; [40]]
 * 30
 * >>> min_wasted_space [100000] [[100000]]
 * 0
 * >>> min_wasted_space [10; 20; 30] [[10; 20; 30]; [15; 25; 35]]
 * 0
*)
let min_wasted_space (packages : int list) (boxes : int list list) : int =","  0","let () =
  assert (min_wasted_space [10; 20; 30] [[10]; [20]; [30]; [40]] = 30);
  assert (min_wasted_space [100000] [[100000]] = 0);
  assert (min_wasted_space [10; 20; 30] [[10; 20; 30]; [15; 25; 35]] = 0);
  assert (min_wasted_space [1; 100000] [[1]; [100000]] = 99999);
  assert (min_wasted_space [2; 3; 5] [[4; 8]; [2; 8]] = 6);
  assert (min_wasted_space [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] [[10; 10; 10; 10; 10; 10; 10; 10; 10; 10]] = 45);
  assert (min_wasted_space [3; 5; 8; 10; 11; 12] [[12]; [11; 9]; [10; 5; 14]] = 9);
;;","hard","hard_042","hard"
"(**You are given n item's value and label as two integer arrays values and labels. You are also give...
 * >>> largest_vals_from_labels [10; 10; 10; 10] [1; 1; 1; 1] 3 2
 * 20
 * >>> largest_vals_from_labels [10; 10; 10; 10] [1; 2; 3; 4] 4 1
 * 40
 * >>> largest_vals_from_labels [9; 8; 8; 7; 6] [0; 0; 0; 1; 1] 3 1
 * 16
*)
let largest_vals_from_labels (values : int list) (labels : int list) (numWanted : int) (useLimit : int) : int =","  0","let () =
  assert (largest_vals_from_labels [10; 10; 10; 10] [1; 1; 1; 1] 3 2 = 20);
  assert (largest_vals_from_labels [10; 10; 10; 10] [1; 2; 3; 4] 4 1 = 40);
  assert (largest_vals_from_labels [9; 8; 8; 7; 6] [0; 0; 0; 1; 1] 3 1 = 16);
  assert (largest_vals_from_labels [10; 20; 30; 40; 50] [1; 2; 3; 4; 5] 5 1 = 150);
  assert (largest_vals_from_labels [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 5 1 = 40);
  assert (largest_vals_from_labels [10; 20; 30; 40; 50] [1; 1; 1; 1; 1] 3 2 = 90);
  assert (largest_vals_from_labels [1; 2; 3; 4; 5] [1; 1; 1; 1; 1] 3 1 = 5);
;;","medium","medium_051","medium"
"(**You are given an array of strings tokens that represents an arithmetic expression in a Reverse Po...
 * >>> eval_rpn [""4""; ""13""; ""5""; ""/""; ""+""]
 * 6
 * >>> eval_rpn [""2""; ""1""; ""+""; ""3""; ""*""]
 * 9
 * >>> eval_rpn [""10""; ""6""; ""9""; ""3""; ""+""; ""-11""; ""*""; ""/""; ""*""; ""17""; ""+""; ""5""; ""+""]
 * 22
*)
let eval_rpn (tokens : string list) : int =","  0","let () =
  assert (eval_rpn [""4""; ""13""; ""5""; ""/""; ""+""] = 6);
  assert (eval_rpn [""2""; ""1""; ""+""; ""3""; ""*""] = 9);
  assert (eval_rpn [""10""; ""6""; ""9""; ""3""; ""+""; ""-11""; ""*""; ""/""; ""*""; ""17""; ""+""; ""5""; ""+""] = 22);
  assert (eval_rpn [""20""; ""5""; ""/""; ""2""; ""+""; ""10""; ""3""; ""/""; ""-""; ""3""; ""4""; ""*""; ""+""; ""2""; ""-""; ""1""; ""*""] = 13);
  assert (eval_rpn [""100""; ""50""; ""/""; ""3""; ""-""; ""2""; ""*""; ""4""; ""1""; ""+""; ""/""; ""5""; ""-""; ""2""; ""*""] = -10);
  assert (eval_rpn [""-10""; ""-3""; ""/""; ""2""; ""*""] = 6);
  assert (eval_rpn [""20""; ""5""; ""*""] = 100);
;;","medium","medium_116","medium"
"(**A perfect number is a positive integer that is equal to the sum of its positive divisors, excludi...
 * >>> check_perfect_number 8128
 * true
 * >>> check_perfect_number 10
 * false
 * >>> check_perfect_number 100000000
 * false
*)
let check_perfect_number (num : int) : bool =","  false","let () =
  assert (check_perfect_number 8128 = true);
  assert (check_perfect_number 10 = false);
  assert (check_perfect_number 100000000 = false);
  assert (check_perfect_number 28 = true);
  assert (check_perfect_number 12 = false);
  assert (check_perfect_number 7 = false);
  assert (check_perfect_number 6 = true);
;;","easy","easy_007","easy"
"(**You are playing the following Nim Game with your friend:
 * >>> can_win_nim 3
 * true
 * >>> can_win_nim 21
 * true
 * >>> can_win_nim 2147483647
 * true
*)
let can_win_nim (n : int) : bool =","  false","let () =
  assert (can_win_nim 3 = true);
  assert (can_win_nim 21 = true);
  assert (can_win_nim 2147483647 = true);
  assert (can_win_nim 104 = false);
  assert (can_win_nim 100 = false);
  assert (can_win_nim 10 = true);
  assert (can_win_nim 5 = true);
;;","easy","easy_175","easy"
"(**You are given an integer array coins representing coins of different denominations and an integer...
 * >>> coin_change [186; 419; 83; 408] 6249
 * 20
 * >>> coin_change [3; 7; 405; 436] 8839
 * 25
 * >>> coin_change [3; 7; 405] 8839
 * 71
*)
let coin_change (coins : int list) (amount : int) : int =","  0","let () =
  assert (coin_change [186; 419; 83; 408] 6249 = 20);
  assert (coin_change [3; 7; 405; 436] 8839 = 25);
  assert (coin_change [3; 7; 405] 8839 = 71);
  assert (coin_change [2; 5; 10; 1] 27 = 4);
  assert (coin_change [1; 2; 5] 1 = 1);
  assert (coin_change [1; 3; 4; 5] 7 = 2);
  assert (coin_change [1] 0 = 0);
;;","medium","medium_060","medium"
"(**Given a pattern and a string s, return true if s matches the pattern.
 * >>> word_pattern_match ""ab"" ""dogdog""
 * true
 * >>> word_pattern_match ""aaaa"" ""catcatcatcat""
 * true
 * >>> word_pattern_match ""aabb"" ""xyzabcxzyabc""
 * false
*)
let word_pattern_match (pattern : string) (s : string) : bool =","  false","let () =
  assert (word_pattern_match ""ab"" ""dogdog"" = true);
  assert (word_pattern_match ""aaaa"" ""catcatcatcat"" = true);
  assert (word_pattern_match ""aabb"" ""xyzabcxzyabc"" = false);
  assert (word_pattern_match ""abcd"" ""oneonetwothree"" = true);
  assert (word_pattern_match ""ab"" ""aa"" = false);
  assert (word_pattern_match ""abc"" ""bagg"" = true);
  assert (word_pattern_match ""abba"" ""dogcatcatdog"" = true);
;;","medium","medium_107","medium"
"(**You are given two integers, x and y, which represent your current location on a Cartesian grid: (...
 * >>> nearest_valid_point 3 4 [[3; 4]]
 * 0
 * >>> nearest_valid_point 5 5 [[1; 5]; [2; 5]; [3; 5]; [4; 5]; [5; 1]; [5; 2]; [5; 3]; [5; 4]]
 * 3
 * >>> nearest_valid_point 1 1 [[2; 2]; [3; 3]; [4; 4]]
 * -1
*)
let nearest_valid_point (x : int) (y : int) (points : int list list) : int =","  0","let () =
  assert (nearest_valid_point 3 4 [[3; 4]] = 0);
  assert (nearest_valid_point 5 5 [[1; 5]; [2; 5]; [3; 5]; [4; 5]; [5; 1]; [5; 2]; [5; 3]; [5; 4]] = 3);
  assert (nearest_valid_point 1 1 [[2; 2]; [3; 3]; [4; 4]] = -1);
  assert (nearest_valid_point 3 4 [[2; 3]] = -1);
  assert (nearest_valid_point 1 1 [[1; 1]; [1; 2]; [1; 3]; [2; 1]; [3; 1]] = 0);
  assert (nearest_valid_point 10 10 [[1; 1]; [2; 2]; [3; 3]; [4; 4]; [5; 5]; [6; 6]; [7; 7]; [8; 8]; [9; 9]] = -1);
  assert (nearest_valid_point 1 1 [[1; 1]; [1; 2]; [2; 1]; [2; 2]] = 0);
;;","easy","easy_190","easy"
"(**Given an m x n binary matrix mat, return the length of the longest line of consecutive one in the...
 * >>> longest_line [[1; 0; 0; 1]; [0; 1; 1; 0]; [0; 0; 0; 1]]
 * 2
 * >>> longest_line [[1; 1; 1; 1]; [1; 1; 1; 1]; [1; 1; 1; 1]]
 * 4
 * >>> longest_line [[1; 0; 0; 0]; [0; 1; 0; 0]; [0; 0; 1; 0]; [0; 0; 0; 1]]
 * 4
*)
let longest_line (mat : int list list) : int =","  0","let () =
  assert (longest_line [[1; 0; 0; 1]; [0; 1; 1; 0]; [0; 0; 0; 1]] = 2);
  assert (longest_line [[1; 1; 1; 1]; [1; 1; 1; 1]; [1; 1; 1; 1]] = 4);
  assert (longest_line [[1; 0; 0; 0]; [0; 1; 0; 0]; [0; 0; 1; 0]; [0; 0; 0; 1]] = 4);
  assert (longest_line [[0; 0; 0; 0]; [0; 0; 0; 0]; [0; 0; 0; 0]] = 0);
  assert (longest_line [[1; 1; 1]; [1; 1; 1]; [1; 1; 1]] = 3);
  assert (longest_line [[0; 1; 1; 0]; [0; 1; 1; 0]; [0; 0; 0; 1]] = 3);
  assert (longest_line [[1; 1; 1; 1; 1]; [1; 1; 1; 1; 1]; [1; 1; 1; 1; 1]; [1; 1; 1; 1; 1]] = 5);
;;","medium","medium_131","medium"
"(**Given an integer array of even length arr, return true if it is possible to reorder arr such that...
 * >>> can_reorder_doubled [1; 4; 2; 2]
 * true
 * >>> can_reorder_doubled [1; 2; 4; 16; 8; 4]
 * false
 * >>> can_reorder_doubled [-5; -2; -10; -1; -1; -5]
 * false
*)
let can_reorder_doubled (arr : int list) : bool =","  false","let () =
  assert (can_reorder_doubled [1; 4; 2; 2] = true);
  assert (can_reorder_doubled [1; 2; 4; 16; 8; 4] = false);
  assert (can_reorder_doubled [-5; -2; -10; -1; -1; -5] = false);
  assert (can_reorder_doubled [5; -3; 3; -2; 2; -4] = false);
  assert (can_reorder_doubled [0; 0] = true);
  assert (can_reorder_doubled [4; -2; 2; -4] = true);
  assert (can_reorder_doubled [1; 2; 3; 6; 4; 8] = true);
;;","medium","medium_073","medium"
"(**Balanced strings are those that have an equal quantity of 'L' and 'R' characters.
 * >>> balanced_string_split ""RRLLRRLL""
 * 2
 * >>> balanced_string_split ""RLRRRLLRLL""
 * 2
 * >>> balanced_string_split ""RRRRLLLLRRRRLLLL""
 * 2
*)
let balanced_string_split (s : string) : int =","  0","let () =
  assert (balanced_string_split ""RRLLRRLL"" = 2);
  assert (balanced_string_split ""RLRRRLLRLL"" = 2);
  assert (balanced_string_split ""RRRRLLLLRRRRLLLL"" = 2);
  assert (balanced_string_split ""LRRLLRRL"" = 4);
  assert (balanced_string_split ""LLLLRRRRLLRRRR"" = 2);
  assert (balanced_string_split ""RLLLLRRR"" = 2);
  assert (balanced_string_split ""RLLRRLRR"" = 3);
;;","easy","easy_178","easy"
"(**You are given two integers red and blue representing the count of red and blue colored balls. You...
 * >>> max_height_of_triangle 100 1
 * 2
 * >>> max_height_of_triangle 3 7
 * 3
 * >>> max_height_of_triangle 50 50
 * 13
*)
let max_height_of_triangle (red : int) (blue : int) : int =","  0","let () =
  assert (max_height_of_triangle 100 1 = 2);
  assert (max_height_of_triangle 3 7 = 3);
  assert (max_height_of_triangle 50 50 = 13);
  assert (max_height_of_triangle 5 5 = 3);
  assert (max_height_of_triangle 1 1 = 1);
  assert (max_height_of_triangle 10 1 = 2);
  assert (max_height_of_triangle 1 100 = 2);
;;","easy","easy_022","easy"
"(**You are given the strings key and message, which represent a cipher key and a secret message, res...
 * >>> decode_message ""zyxwvutsrqponmlkjihgfedcba"" ""cba zyx""
 * xyz abc
 * >>> decode_message ""a quick movement of the enemy will jeopardize five gunboats"" ""yfcj myj pyjl ufcj myj pyjl ufcj myj pyjl""
 * omer gor sorq cmer gor sorq cmer gor sorq
 * >>> decode_message ""the five boxing wizards jump quickly on this yellow pig"" ""jhxuh lqdj efxgh lpuaz fxdyjzjw""
 * rbisb yvpr cdikb yusnm dipzrmrl
*)
let decode_message (key : string) (message : string) : string =","  """"","let () =
  assert (decode_message ""zyxwvutsrqponmlkjihgfedcba"" ""cba zyx"" = xyz abc);
  assert (decode_message ""a quick movement of the enemy will jeopardize five gunboats"" ""yfcj myj pyjl ufcj myj pyjl ufcj myj pyjl"" = omer gor sorq cmer gor sorq cmer gor sorq);
  assert (decode_message ""the five boxing wizards jump quickly on this yellow pig"" ""jhxuh lqdj efxgh lpuaz fxdyjzjw"" = rbisb yvpr cdikb yusnm dipzrmrl);
  assert (decode_message ""dvhfujngcpqxlwokzriebastmy"" ""mwtiaz azr"" = ynxsvq vqr);
  assert (decode_message ""abcdefghijklmnopqrstuvwxyz"" ""xyz abc"" = xyz abc);
  assert (decode_message ""the quick brown fox jumps over the lazy dog"" ""vkbs bs t suepuv"" = this is a secret);
  assert (decode_message ""byvzkgxfnqmpalwodjtrshceui"" ""xsm wv zmz"" = guk oc dkd);
;;","easy","easy_062","easy"
"(**You are entering a competition, and are given two positive integers initialEnergy and initialExpe...
 * >>> min_number_of_hours 50 50 [50; 50] [50; 50]
 * 52
 * >>> min_number_of_hours 5 3 [1; 4; 3; 2] [2; 6; 3; 1]
 * 8
 * >>> min_number_of_hours 1 1 [100] [100]
 * 200
*)
let min_number_of_hours (initialEnergy : int) (initialExperience : int) (energy : int list) (experience : int list) : int =","  0","let () =
  assert (min_number_of_hours 50 50 [50; 50] [50; 50] = 52);
  assert (min_number_of_hours 5 3 [1; 4; 3; 2] [2; 6; 3; 1] = 8);
  assert (min_number_of_hours 1 1 [100] [100] = 200);
  assert (min_number_of_hours 100 100 [50; 25; 25] [50; 25; 25] = 1);
  assert (min_number_of_hours 50 50 [10; 20; 30] [10; 20; 30] = 11);
  assert (min_number_of_hours 100 100 [100] [100] = 2);
  assert (min_number_of_hours 100 100 [50; 50] [50; 50] = 1);
;;","easy","easy_155","easy"
"(**Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in ...
 * >>> intersection [1; 2; 3; 4] [4; 3; 2; 1]
 * [1; 2; 3; 4]
 * >>> intersection [1; 1; 1; 1] [1; 1; 1; 1]
 * [1]
 * >>> intersection [1; 3; 5; 7] [2; 4; 6; 8]
 * []
*)
let intersection (nums1 : int list) (nums2 : int list) : int list =","  []","let () =
  assert (intersection [1; 2; 3; 4] [4; 3; 2; 1] = [1; 2; 3; 4]);
  assert (intersection [1; 1; 1; 1] [1; 1; 1; 1] = [1]);
  assert (intersection [1; 3; 5; 7] [2; 4; 6; 8] = []);
  assert (intersection [0; 0; 0; 0] [0; 0; 0; 0] = [0]);
  assert (intersection [0; 1; 2; 3; 4; 5] [5; 4; 3; 2; 1; 0] = [0; 1; 2; 3; 4; 5]);
  assert (intersection [10; 20; 30; 40] [30; 40; 50; 60] = [40; 30]);
  assert (intersection [1000] [1000] = [1000]);
;;","easy","easy_053","easy"
"(**You are an ant tasked with adding n new rooms numbered 0 to n-1 to your colony. You are given the...
 * >>> ways_to_build_rooms [-1; 0; 0; 1; 1; 2; 2; 3; 3; 4; 4; 5; 5; 6; 6; 7; 7; 8; 8; 9]
 * 258365767
 * >>> ways_to_build_rooms [-1; 0; 1; 1; 2; 2]
 * 8
 * >>> ways_to_build_rooms [-1; 0; 0; 1; 2]
 * 6
*)
let ways_to_build_rooms (prevRoom : int list) : int =","  0","let () =
  assert (ways_to_build_rooms [-1; 0; 0; 1; 1; 2; 2; 3; 3; 4; 4; 5; 5; 6; 6; 7; 7; 8; 8; 9] = 258365767);
  assert (ways_to_build_rooms [-1; 0; 1; 1; 2; 2] = 8);
  assert (ways_to_build_rooms [-1; 0; 0; 1; 2] = 6);
  assert (ways_to_build_rooms [-1; 0; 0; 1; 1; 2; 2] = 80);
  assert (ways_to_build_rooms [-1; 0; 1] = 1);
  assert (ways_to_build_rooms [-1; 0; 0; 0] = 6);
  assert (ways_to_build_rooms [-1; 0; 0; 0; 1; 2; 2] = 120);
;;","hard","hard_050","hard"
"(**The next greater element of some element x in an array is the first greater element that is to th...
 * >>> next_greater_element [2; 3; 5; 6] [5; 6; 2; 3; 8; 9]
 * [3; 8; 6; 8]
 * >>> next_greater_element [1; 2] [2; 1]
 * [-1; -1]
 * >>> next_greater_element [1; 2; 3; 4] [4; 3; 2; 1]
 * [-1; -1; -1; -1]
*)
let next_greater_element (nums1 : int list) (nums2 : int list) : int list =","  []","let () =
  assert (next_greater_element [2; 3; 5; 6] [5; 6; 2; 3; 8; 9] = [3; 8; 6; 8]);
  assert (next_greater_element [1; 2] [2; 1] = [-1; -1]);
  assert (next_greater_element [1; 2; 3; 4] [4; 3; 2; 1] = [-1; -1; -1; -1]);
  assert (next_greater_element [5] [5] = [-1]);
  assert (next_greater_element [1; 6; 4; 8] [4; 5; 1; 8; 6; 7; 9] = [8; 7; 5; 9]);
  assert (next_greater_element [5; 2; 6] [4; 1; 5; 2; 3; 6] = [6; 3; -1]);
  assert (next_greater_element [2; 4] [1; 2; 3; 4] = [3; -1]);
;;","easy","easy_039","easy"
"(**There are n items each belonging to zero or one of m groups where group[i] is the group that the ...
 * >>> sort_items 4 2 [-1; -1; -1; -1] [[]; [2; 3]; [3]; [3]]
 * []
 * >>> sort_items 8 2 [-1; -1; 1; 0; 0; 1; 0; -1] [[]; [6]; [5]; [6]; [3; 6]; []; []; []]
 * [6; 3; 4; 5; 2; 0; 7; 1]
 * >>> sort_items 5 3 [0; 0; 1; 1; -1] [[]; [2]; [3]; []; [1; 3]]
 * [3; 2; 0; 1; 4]
*)
let sort_items (n : int) (m : int) (group : int list) (beforeItems : int list list) : int list =","  []","let () =
  assert (sort_items 4 2 [-1; -1; -1; -1] [[]; [2; 3]; [3]; [3]] = []);
  assert (sort_items 8 2 [-1; -1; 1; 0; 0; 1; 0; -1] [[]; [6]; [5]; [6]; [3; 6]; []; []; []] = [6; 3; 4; 5; 2; 0; 7; 1]);
  assert (sort_items 5 3 [0; 0; 1; 1; -1] [[]; [2]; [3]; []; [1; 3]] = [3; 2; 0; 1; 4]);
  assert (sort_items 8 2 [-1; -1; 1; 0; 0; 1; 0; -1] [[]; [6]; [5]; [6]; [3]; []; [4]; []] = []);
  assert (sort_items 5 3 [-1; 0; 0; 1; -1] [[]; [2; 3]; [3]; []; []] = [3; 0; 4; 2; 1]);
  assert (sort_items 5 3 [1; 2; 0; -1; -1] [[]; [2; 4; 3]; [3; 0]; [4; ]; [4]] = []);
  assert (sort_items 3 1 [-1; -1; -1] [[]; [2]; [1]] = []);
;;","hard","hard_071","hard"
"(**Given an array of integers citations where citations[i] is the number of citations a researcher r...
 * >>> h_index [10; 8; 5; 4; 3]
 * 4
 * >>> h_index [1]
 * 1
 * >>> h_index [3; 0; 6; 1; 5]
 * 3
*)
let h_index (citations : int list) : int =","  0","let () =
  assert (h_index [10; 8; 5; 4; 3] = 4);
  assert (h_index [1] = 1);
  assert (h_index [3; 0; 6; 1; 5] = 3);
  assert (h_index [0; 1; 2; 3; 4] = 2);
  assert (h_index [1000; 999; 998; 997; 996] = 5);
  assert (h_index [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = 5);
  assert (h_index [0; 0; 0; 0; 0] = 0);
;;","medium","medium_004","medium"
"(**You are given an integer array nums containing positive integers. We define a function encrypt su...
 * >>> sum_of_encrypted_int [523; 213; 111]
 * 999
 * >>> sum_of_encrypted_int [523; 213; 111]
 * 999
 * >>> sum_of_encrypted_int [1; 10; 100; 1000]
 * 1234
*)
let sum_of_encrypted_int (nums : int list) : int =","  0","let () =
  assert (sum_of_encrypted_int [523; 213; 111] = 999);
  assert (sum_of_encrypted_int [523; 213; 111] = 999);
  assert (sum_of_encrypted_int [1; 10; 100; 1000] = 1234);
  assert (sum_of_encrypted_int [999; 100; 101] = 1221);
  assert (sum_of_encrypted_int [9; 8; 7; 6; 5; 4; 3; 2; 1] = 45);
  assert (sum_of_encrypted_int [456; 789; 321] = 1998);
  assert (sum_of_encrypted_int [1111; 2222; 3333; 4444; 5555] = 16665);
;;","easy","easy_193","easy"
"(**There are n cities numbered from 0 to n-1. Given the array edges where edges[i] = [fromi, toi, we...
 * >>> find_the_city 5 [[0; 1; 2]; [0; 4; 8]; [1; 2; 3]; [1; 4; 2]; [2; 3; 1]; [3; 4; 1]] 2
 * 0
 * >>> find_the_city 4 [[0; 1; 3]; [1; 2; 1]; [1; 3; 4]; [2; 3; 1]] 4
 * 3
 * >>> find_the_city 6 [[0; 1; 10]; [0; 2; 3]; [1; 2; 1]; [1; 3; 7]; [2; 4; 2]; [3; 4; 8]; [4; 5; 6]] 20
 * 5
*)
let find_the_city (n : int) (edges : int list list) (distanceThreshold : int) : int =","  0","let () =
  assert (find_the_city 5 [[0; 1; 2]; [0; 4; 8]; [1; 2; 3]; [1; 4; 2]; [2; 3; 1]; [3; 4; 1]] 2 = 0);
  assert (find_the_city 4 [[0; 1; 3]; [1; 2; 1]; [1; 3; 4]; [2; 3; 1]] 4 = 3);
  assert (find_the_city 6 [[0; 1; 10]; [0; 2; 3]; [1; 2; 1]; [1; 3; 7]; [2; 4; 2]; [3; 4; 8]; [4; 5; 6]] 20 = 5);
  assert (find_the_city 3 [[0; 1; 5]; [1; 2; 5]; [0; 2; 5]] 10 = 2);
  assert (find_the_city 7 [[0; 1; 1]; [0; 2; 1]; [1; 2; 1]; [1; 3; 1]; [2; 3; 1]; [2; 4; 1]; [3; 4; 1]; [3; 5; 1]; [4; 5; 1]; [4; 6; 1]; [5; 6; 1]] 1 = 6);
  assert (find_the_city 10 [[0; 1; 2]; [0; 5; 3]; [1; 2; 1]; [1; 3; 4]; [2; 4; 3]; [2; 5; 2]; [3; 4; 1]; [3; 6; 5]; [4; 7; 2]; [5; 6; 1]; [6; 7; 3]; [7; 8; 1]; [8; 9; 4]] 5 = 9);
  assert (find_the_city 6 [[0; 1; 1]; [0; 2; 5]; [1; 2; 1]; [1; 3; 3]; [1; 4; 7]; [2; 3; 1]; [2; 4; 2]; [3; 4; 1]; [3; 5; 2]; [4; 5; 2]] 4 = 5);
;;","medium","medium_088","medium"
"(**You are given an array arr of size n consisting of non-empty strings.
 * >>> shortest_substrings [""abcabc""; ""bcabc""; ""cabc""; ""abcd""]
 * ['abca'; ''; ''; 'd']
 * >>> shortest_substrings [""aaa""; ""aab""; ""aba""; ""abb""]
 * ['aaa'; 'aab'; 'ba'; 'bb']
 * >>> shortest_substrings [""abc""; ""bcd""; ""abcd""]
 * [''; ''; 'abcd']
*)
let shortest_substrings (arr : string list) : string list =","  []","let () =
  assert (shortest_substrings [""abcabc""; ""bcabc""; ""cabc""; ""abcd""] = ['abca'; ''; ''; 'd']);
  assert (shortest_substrings [""aaa""; ""aab""; ""aba""; ""abb""] = ['aaa'; 'aab'; 'ba'; 'bb']);
  assert (shortest_substrings [""abc""; ""bcd""; ""abcd""] = [''; ''; 'abcd']);
  assert (shortest_substrings [""abcd""; ""bcde""; ""cdef""; ""defg""] = ['a'; 'bcde'; 'cdef'; 'g']);
  assert (shortest_substrings [""hello""; ""world""; ""hel""; ""wor""; ""ld""] = ['ll'; 'rl'; ''; ''; '']);
  assert (shortest_substrings [""unique""; ""strings""; ""array""; ""test""] = ['q'; 'g'; 'a'; 'es']);
  assert (shortest_substrings [""cab""; ""ad""; ""bad""; ""c""] = ['ab'; ''; 'ba'; '']);
;;","medium","medium_133","medium"
"(**You are given an integer array prices where prices[i] is the price of the ith item in a shop.
 * >>> final_prices [5; 5; 5; 5; 5]
 * [0; 0; 0; 0; 5]
 * >>> final_prices [10; 9; 8; 7; 6; 5; 4; 3; 2; 1]
 * [1; 1; 1; 1; 1; 1; 1; 1; 1; 1]
 * >>> final_prices [8; 4; 6; 2; 3]
 * [4; 2; 4; 2; 3]
*)
let final_prices (prices : int list) : int list =","  []","let () =
  assert (final_prices [5; 5; 5; 5; 5] = [0; 0; 0; 0; 5]);
  assert (final_prices [10; 9; 8; 7; 6; 5; 4; 3; 2; 1] = [1; 1; 1; 1; 1; 1; 1; 1; 1; 1]);
  assert (final_prices [8; 4; 6; 2; 3] = [4; 2; 4; 2; 3]);
  assert (final_prices [5; 10; 15; 20; 25; 30; 35; 40; 45; 50] = [5; 10; 15; 20; 25; 30; 35; 40; 45; 50]);
  assert (final_prices [9; 8; 7; 6; 5] = [1; 1; 1; 1; 5]);
  assert (final_prices [1; 1; 1; 1; 1; 1; 1; 1; 1] = [0; 0; 0; 0; 0; 0; 0; 0; 1]);
  assert (final_prices [1; 3; 5; 7; 9; 11; 13; 15; 17] = [1; 3; 5; 7; 9; 11; 13; 15; 17]);
;;","easy","easy_056","easy"
"(**You are given a string s of lowercase English letters and an array widths denoting how many pixel...
 * >>> number_of_lines [2; 3; 4; 5; 6; 7; 8; 9; 10; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 1; 2; 3; 4; 5; 6; 7] ""examplestring""
 * [1; 76]
 * >>> number_of_lines [1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1] ""bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb""
 * [1; 43]
 * >>> number_of_lines [4; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10] ""bbbcccdddaaa""
 * [2; 4]
*)
let number_of_lines (widths : int list) (s : string) : int list =","  []","let () =
  assert (number_of_lines [2; 3; 4; 5; 6; 7; 8; 9; 10; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 1; 2; 3; 4; 5; 6; 7] ""examplestring"" = [1; 76]);
  assert (number_of_lines [1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1] ""bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"" = [1; 43]);
  assert (number_of_lines [4; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10] ""bbbcccdddaaa"" = [2; 4]);
  assert (number_of_lines [5; 7; 9; 11; 13; 15; 17; 19; 21; 23; 25; 27; 29; 31; 33; 35; 37; 39; 41; 43; 45; 47; 49; 51; 53; 55] ""abcdefghijklmnopqrstuvwxyz"" = [10; 55]);
  assert (number_of_lines [2; 3; 4; 5; 6; 7; 8; 9; 10; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 1; 2; 3; 4; 5; 6; 7] ""akjflsajflsajfljsaljfljsalfjsalkfjsalkfjsalkfjsalkfjsalkfj"" = [3; 38]);
  assert (number_of_lines [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 1; 2; 3; 4; 5; 6] ""aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz"" = [3; 62]);
  assert (number_of_lines [10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10; 10] ""a"" = [1; 10]);
;;","easy","easy_160","easy"
"(**Given two integer arrays arr1 and arr2, and the integer d, return the distance value between the ...
 * >>> find_the_distance_value [10; 20; 30] [5; 15; 25] 4
 * 3
 * >>> find_the_distance_value [-1000; 1000] [-500; 500] 499
 * 2
 * >>> find_the_distance_value [4; 5; 8] [10; 9; 1; 8] 2
 * 2
*)
let find_the_distance_value (arr1 : int list) (arr2 : int list) (d : int) : int =","  0","let () =
  assert (find_the_distance_value [10; 20; 30] [5; 15; 25] 4 = 3);
  assert (find_the_distance_value [-1000; 1000] [-500; 500] 499 = 2);
  assert (find_the_distance_value [4; 5; 8] [10; 9; 1; 8] 2 = 2);
  assert (find_the_distance_value [1; 4; 2; 3] [-4; -3; 6; 10; 20; 30] 3 = 2);
  assert (find_the_distance_value [-1; -2; -3] [1; 2; 3] 2 = 2);
  assert (find_the_distance_value [0; 0; 0; 0] [1; 2; 3; 4] 0 = 4);
  assert (find_the_distance_value [1000] [-1000] 1999 = 1);
;;","easy","easy_084","easy"
"(**You are given a 0-indexed integer array nums of length n.
 * >>> maximum_sum_score [-10; -20; -30; -40; -50]
 * -10
 * >>> maximum_sum_score [100000; -100000; 100000; -100000; 100000]
 * 100000
 * >>> maximum_sum_score [-1]
 * -1
*)
let maximum_sum_score (nums : int list) : int =","  0","let () =
  assert (maximum_sum_score [-10; -20; -30; -40; -50] = -10);
  assert (maximum_sum_score [100000; -100000; 100000; -100000; 100000] = 100000);
  assert (maximum_sum_score [-1] = -1);
  assert (maximum_sum_score [5] = 5);
  assert (maximum_sum_score [-1; 1; -1; 1; -1] = 0);
  assert (maximum_sum_score [1; -1; 1; -1; 1] = 1);
  assert (maximum_sum_score [10; 20; 30; 40; 50] = 150);
;;","medium","medium_097","medium"
"(**Given a list of the scores of different students, items, where items[i] = [IDi, scorei] represent...
 * >>> high_five [[1; 91]; [1; 92]; [2; 93]; [2; 97]; [1; 60]; [2; 77]; [1; 65]; [1; 87]; [1; 100]; [2; 100]; [2; 76]]
 * [[1; 87]; [2; 88]]
 * >>> high_five [[3; 95]; [3; 85]; [3; 75]; [3; 65]; [3; 55]; [4; 90]; [4; 80]; [4; 70]; [4; 60]; [4; 50]]
 * [[3; 75]; [4; 70]]
 * >>> high_five [[5; 90]; [5; 85]; [5; 95]; [5; 80]; [5; 92]; [3; 78]; [3; 85]; [3; 80]; [3; 82]; [3; 79]]
 * [[3; 80]; [5; 88]]
*)
let high_five (items : int list list) : int list list =","  [[]]","let () =
  assert (high_five [[1; 91]; [1; 92]; [2; 93]; [2; 97]; [1; 60]; [2; 77]; [1; 65]; [1; 87]; [1; 100]; [2; 100]; [2; 76]] = [[1; 87]; [2; 88]]);
  assert (high_five [[3; 95]; [3; 85]; [3; 75]; [3; 65]; [3; 55]; [4; 90]; [4; 80]; [4; 70]; [4; 60]; [4; 50]] = [[3; 75]; [4; 70]]);
  assert (high_five [[5; 90]; [5; 85]; [5; 95]; [5; 80]; [5; 92]; [3; 78]; [3; 85]; [3; 80]; [3; 82]; [3; 79]] = [[3; 80]; [5; 88]]);
  assert (high_five [[1; 100]; [7; 100]; [1; 100]; [7; 100]; [1; 100]; [7; 100]; [1; 100]; [7; 100]; [1; 100]; [7; 100]] = [[1; 100]; [7; 100]]);
  assert (high_five [[10; 80]; [10; 85]; [10; 90]; [10; 95]; [10; 100]; [20; 60]; [20; 70]; [20; 80]; [20; 90]; [20; 100]] = [[10; 90]; [20; 80]]);
  assert (high_five [[1; 80]; [1; 70]; [1; 90]; [1; 60]; [1; 50]; [2; 90]; [2; 80]; [2; 70]; [2; 60]; [2; 50]; [3; 100]; [3; 90]; [3; 80]; [3; 70]; [3; 60]] = [[1; 70]; [2; 70]; [3; 80]]);
  assert (high_five [[1; 85]; [1; 90]; [1; 78]; [1; 92]; [1; 88]; [2; 76]; [2; 82]; [2; 90]; [2; 88]; [2; 79]] = [[1; 86]; [2; 83]]);
;;","easy","easy_086","easy"
"(**You are given two positive integers n and limit.
 * >>> distribute_candies 10 5
 * 21
 * >>> distribute_candies 3 3
 * 10
 * >>> distribute_candies 5 2
 * 3
*)
let distribute_candies (n : int) (limit : int) : int =","  0","let () =
  assert (distribute_candies 10 5 = 21);
  assert (distribute_candies 3 3 = 10);
  assert (distribute_candies 5 2 = 3);
  assert (distribute_candies 4 2 = 6);
  assert (distribute_candies 7 3 = 6);
  assert (distribute_candies 4 4 = 15);
  assert (distribute_candies 25 10 = 21);
;;","easy","easy_189","easy"
"(**You are given an array nums of non-negative integers. nums is considered special if there exists ...
 * >>> special_array [6; 5; 4; 3; 2; 1]
 * -1
 * >>> special_array [100; 100; 100; 100; 100; 100; 100; 100; 100; 100]
 * 10
 * >>> special_array [0; 1; 2; 3; 4; 5]
 * 3
*)
let special_array (nums : int list) : int =","  0","let () =
  assert (special_array [6; 5; 4; 3; 2; 1] = -1);
  assert (special_array [100; 100; 100; 100; 100; 100; 100; 100; 100; 100] = 10);
  assert (special_array [0; 1; 2; 3; 4; 5] = 3);
  assert (special_array [0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = -1);
  assert (special_array [100; 200; 300; 400; 500] = 5);
  assert (special_array [0; 0] = -1);
  assert (special_array [1] = 1);
;;","easy","easy_132","easy"
"(**Given two integer arrays pushed and popped each with distinct values, return true if this could h...
 * >>> validate_stack_sequences [1; 2; 3; 4; 5] [4; 5; 3; 2; 1]
 * true
 * >>> validate_stack_sequences [2; 1; 0] [0; 1; 2]
 * true
 * >>> validate_stack_sequences [1; 2; 3; 4; 5] [1; 3; 2; 5; 4]
 * true
*)
let validate_stack_sequences (pushed : int list) (popped : int list) : bool =","  false","let () =
  assert (validate_stack_sequences [1; 2; 3; 4; 5] [4; 5; 3; 2; 1] = true);
  assert (validate_stack_sequences [2; 1; 0] [0; 1; 2] = true);
  assert (validate_stack_sequences [1; 2; 3; 4; 5] [1; 3; 2; 5; 4] = true);
  assert (validate_stack_sequences [1; 2; 3; 4; 5] [5; 4; 3; 2; 1] = true);
  assert (validate_stack_sequences [1; 2; 3; 4; 5] [4; 3; 5; 1; 2] = false);
  assert (validate_stack_sequences [1] [1] = true);
  assert (validate_stack_sequences [1; 2; 3; 4; 5] [3; 5; 4; 2; 1] = true);
;;","medium","medium_173","medium"
"(**Given a string s and an array of strings words, determine whether s is a prefix string of words.
 * >>> is_prefix_string ""aaaa"" [""aa""; ""aa""]
 * true
 * >>> is_prefix_string ""hello"" [""he""; ""ll""; ""o""]
 * true
 * >>> is_prefix_string ""abc"" [""a""]
 * false
*)
let is_prefix_string (s : string) (words : string list) : bool =","  false","let () =
  assert (is_prefix_string ""aaaa"" [""aa""; ""aa""] = true);
  assert (is_prefix_string ""hello"" [""he""; ""ll""; ""o""] = true);
  assert (is_prefix_string ""abc"" [""a""] = false);
  assert (is_prefix_string ""abc"" [""a""; ""bc""] = true);
  assert (is_prefix_string ""a"" [""a""; ""b""; ""c""] = true);
  assert (is_prefix_string ""abcd"" [""a""; ""bcd""] = true);
  assert (is_prefix_string ""cat"" [""ca""; ""t""] = true);
;;","easy","easy_112","easy"
"(**Given a string s consisting only of characters a, b and c.
 * >>> number_of_substrings ""aaabbbccc""
 * 9
 * >>> number_of_substrings ""abcba""
 * 5
 * >>> number_of_substrings ""cba""
 * 1
*)
let number_of_substrings (s : string) : int =","  0","let () =
  assert (number_of_substrings ""aaabbbccc"" = 9);
  assert (number_of_substrings ""abcba"" = 5);
  assert (number_of_substrings ""cba"" = 1);
  assert (number_of_substrings ""cbaacb"" = 8);
  assert (number_of_substrings ""bbbacbac"" = 18);
  assert (number_of_substrings ""ccccabc"" = 9);
  assert (number_of_substrings ""abcabcabc"" = 28);
;;","medium","medium_134","medium"
"(**You are given an integer array score of size n, where score[i] is the score of the ith athlete in...
 * >>> find_relative_ranks [100; 90; 80; 70; 60; 50; 40; 30; 20; 10]
 * ['Gold Medal'; 'Silver Medal'; 'Bronze Medal'; '4'; '5'; '6'; '7'; '8'; '9'; '10']
 * >>> find_relative_ranks [5; 4; 3; 2; 1]
 * ['Gold Medal'; 'Silver Medal'; 'Bronze Medal'; '4'; '5']
 * >>> find_relative_ranks [0; 1000000]
 * ['Silver Medal'; 'Gold Medal']
*)
let find_relative_ranks (score : int list) : string list =","  []","let () =
  assert (find_relative_ranks [100; 90; 80; 70; 60; 50; 40; 30; 20; 10] = ['Gold Medal'; 'Silver Medal'; 'Bronze Medal'; '4'; '5'; '6'; '7'; '8'; '9'; '10']);
  assert (find_relative_ranks [5; 4; 3; 2; 1] = ['Gold Medal'; 'Silver Medal'; 'Bronze Medal'; '4'; '5']);
  assert (find_relative_ranks [0; 1000000] = ['Silver Medal'; 'Gold Medal']);
  assert (find_relative_ranks [100; 90; 95; 80; 75] = ['Gold Medal'; 'Bronze Medal'; 'Silver Medal'; '4'; '5']);
  assert (find_relative_ranks [10; 3; 8; 9; 4] = ['Gold Medal'; '5'; 'Bronze Medal'; 'Silver Medal'; '4']);
  assert (find_relative_ranks [100] = ['Gold Medal']);
  assert (find_relative_ranks [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = ['10'; '9'; '8'; '7'; '6'; '5'; '4'; 'Bronze Medal'; 'Silver Medal'; 'Gold Medal']);
;;","easy","easy_059","easy"
"(**You are given an integer array nums and an integer goal.
 * >>> min_abs_difference [1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1] 10
 * 0
 * >>> min_abs_difference [-10; -20; -30; -40; -50] -100
 * 0
 * >>> min_abs_difference [10; 20; 30; 40; 50] 100
 * 0
*)
let min_abs_difference (nums : int list) (goal : int) : int =","  0","let () =
  assert (min_abs_difference [1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1] 10 = 0);
  assert (min_abs_difference [-10; -20; -30; -40; -50] -100 = 0);
  assert (min_abs_difference [10; 20; 30; 40; 50] 100 = 0);
  assert (min_abs_difference [10; 22; 9; -24; -33; 21; 4; 19; 29; -14; 34; 10; -11; 8; -8; -7; 13; 24; -29; -10; -28; 10; -32; -23; 7; 31; 2; 25; -31; -40; -4; -23] 100 = 0);
  assert (min_abs_difference [1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1] 15 = 0);
  assert (min_abs_difference [7; -9; 15; -2] -5 = 1);
  assert (min_abs_difference [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 25 = 0);
;;","hard","hard_093","hard"
"(**Given a 0-indexed integer array nums, return true if it can be made strictly increasing after rem...
 * >>> can_be_increasing [1; 3; 2; 4; 5]
 * true
 * >>> can_be_increasing [1; 2; 2; 3; 4; 5]
 * true
 * >>> can_be_increasing [1; 2; 2; 3]
 * true
*)
let can_be_increasing (nums : int list) : bool =","  false","let () =
  assert (can_be_increasing [1; 3; 2; 4; 5] = true);
  assert (can_be_increasing [1; 2; 2; 3; 4; 5] = true);
  assert (can_be_increasing [1; 2; 2; 3] = true);
  assert (can_be_increasing [1; 1; 1] = false);
  assert (can_be_increasing [10; 9; 2; 5; 3; 7; 101; 18] = false);
  assert (can_be_increasing [1; 2; 3; 4; 5; 3] = true);
  assert (can_be_increasing [3; 5; 4; 6; 7] = true);
;;","easy","easy_065","easy"
"(**You are given a positive integer n, indicating that we initially have an n x n 0-indexed integer ...
 * >>> range_add_queries 5 [[0; 0; 0; 0]; [1; 1; 1; 1]; [2; 2; 2; 2]; [3; 3; 3; 3]; [4; 4; 4; 4]]
 * [[1; 0; 0; 0; 0]; [0; 1; 0; 0; 0]; [0; 0; 1; 0; 0]; [0; 0; 0; 1; 0]; [0; 0; 0; 0; 1]]
 * >>> range_add_queries 1 [[0; 0; 0; 0]]
 * [[1]]
 * >>> range_add_queries 5 [[0; 0; 4; 4]; [1; 1; 3; 3]; [2; 2; 2; 2]]
 * [[1; 1; 1; 1; 1]; [1; 2; 2; 2; 1]; [1; 2; 3; 2; 1]; [1; 2; 2; 2; 1]; [1; 1; 1; 1; 1]]
*)
let range_add_queries (n : int) (queries : int list list) : int list list =","  [[]]","let () =
  assert (range_add_queries 5 [[0; 0; 0; 0]; [1; 1; 1; 1]; [2; 2; 2; 2]; [3; 3; 3; 3]; [4; 4; 4; 4]] = [[1; 0; 0; 0; 0]; [0; 1; 0; 0; 0]; [0; 0; 1; 0; 0]; [0; 0; 0; 1; 0]; [0; 0; 0; 0; 1]]);
  assert (range_add_queries 1 [[0; 0; 0; 0]] = [[1]]);
  assert (range_add_queries 5 [[0; 0; 4; 4]; [1; 1; 3; 3]; [2; 2; 2; 2]] = [[1; 1; 1; 1; 1]; [1; 2; 2; 2; 1]; [1; 2; 3; 2; 1]; [1; 2; 2; 2; 1]; [1; 1; 1; 1; 1]]);
  assert (range_add_queries 3 [[0; 0; 2; 2]; [1; 1; 1; 1]; [0; 1; 1; 2]] = [[1; 2; 2]; [1; 3; 2]; [1; 1; 1]]);
  assert (range_add_queries 4 [[0; 0; 0; 0]; [1; 1; 1; 1]; [2; 2; 2; 2]; [3; 3; 3; 3]] = [[1; 0; 0; 0]; [0; 1; 0; 0]; [0; 0; 1; 0]; [0; 0; 0; 1]]);
  assert (range_add_queries 4 [[0; 0; 3; 3]; [0; 0; 3; 3]; [0; 0; 3; 3]] = [[3; 3; 3; 3]; [3; 3; 3; 3]; [3; 3; 3; 3]; [3; 3; 3; 3]]);
  assert (range_add_queries 500 [[0; 0; 499; 499]; [100; 100; 399; 399]; [200; 200; 299; 299]] = Execution timed out);
;;","medium","medium_198","medium"
"(**Given an array of strings words, return the smallest string that contains each string in words as...
 * >>> shortest_superstring [""a""; ""ab""; ""abc""]
 * abc
 * >>> shortest_superstring [""abcde""; ""bcdef""; ""cdefg""]
 * abcdefg
 * >>> shortest_superstring [""a""; ""b""; ""c""]
 * abc
*)
let shortest_superstring (words : string list) : string =","  """"","let () =
  assert (shortest_superstring [""a""; ""ab""; ""abc""] = abc);
  assert (shortest_superstring [""abcde""; ""bcdef""; ""cdefg""] = abcdefg);
  assert (shortest_superstring [""a""; ""b""; ""c""] = abc);
  assert (shortest_superstring [""shortest""; ""superstring""; ""string""; ""abc""] = superstringshortestabc);
  assert (shortest_superstring [""abc""; ""bcd""; ""xyz""; ""zyx""] = zyxyzabcd);
  assert (shortest_superstring [""aaa""; ""bbb""; ""ccc""] = aaabbbccc);
  assert (shortest_superstring [""abcd""; ""cde""; ""efg""; ""ghij""] = abcdefghij);
;;","hard","hard_027","hard"
"(**A transaction is possibly invalid if:
 * >>> invalid_transactions [""alice; 20; 800; mtv""; ""alice; 50; 1200; mtv""]
 * ['alice; 50; 1200; mtv']
 * >>> invalid_transactions [""alice; 20; 800; mtv""; ""alice; 50; 100; beijing""; ""bob; 25; 800; mtv""; ""bob; 100; 100; beijing""]
 * ['alice; 20; 800; mtv'; 'alice; 50; 100; beijing']
 * >>> invalid_transactions [""alice; 10; 500; mtv""; ""bob; 20; 600; mtv""; ""alice; 30; 1100; newyork""; ""bob; 40; 100; beijing""]
 * ['alice; 10; 500; mtv'; 'bob; 20; 600; mtv'; 'alice; 30; 1100; newyork'; 'bob; 40; 100; beijing']
*)
let invalid_transactions (transactions : string list) : string list =","  []","let () =
  assert (invalid_transactions [""alice; 20; 800; mtv""; ""alice; 50; 1200; mtv""] = ['alice; 50; 1200; mtv']);
  assert (invalid_transactions [""alice; 20; 800; mtv""; ""alice; 50; 100; beijing""; ""bob; 25; 800; mtv""; ""bob; 100; 100; beijing""] = ['alice; 20; 800; mtv'; 'alice; 50; 100; beijing']);
  assert (invalid_transactions [""alice; 10; 500; mtv""; ""bob; 20; 600; mtv""; ""alice; 30; 1100; newyork""; ""bob; 40; 100; beijing""] = ['alice; 10; 500; mtv'; 'bob; 20; 600; mtv'; 'alice; 30; 1100; newyork'; 'bob; 40; 100; beijing']);
  assert (invalid_transactions [""alice; 20; 1100; mtv""; ""bob; 50; 2000; mtv""; ""alice; 100; 1000; beijing""] = ['alice; 20; 1100; mtv'; 'bob; 50; 2000; mtv']);
  assert (invalid_transactions [""alice; 20; 800; mtv""; ""alice; 50; 100; mtv""; ""alice; 61; 100; mtv""] = []);
  assert (invalid_transactions [""alice; 20; 800; mtv""; ""alice; 60; 100; mtv""; ""alice; 120; 100; beijing""] = ['alice; 60; 100; mtv'; 'alice; 120; 100; beijing']);
  assert (invalid_transactions [""alice; 20; 800; mtv""; ""alice; 20; 1000; mtv""; ""alice; 21; 800; beijing""] = ['alice; 20; 800; mtv'; 'alice; 20; 1000; mtv'; 'alice; 21; 800; beijing']);
;;","medium","medium_165","medium"
"(**Given an array nums sorted in non-decreasing order, return the maximum between the number of posi...
 * >>> maximum_count [0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
 * 10
 * >>> maximum_count [-2; -1; -1; 1; 2; 3]
 * 3
 * >>> maximum_count [-10; -9; -8; -7; -6; -5; -4; -3; -2; -1; 0]
 * 10
*)
let maximum_count (nums : int list) : int =","  0","let () =
  assert (maximum_count [0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = 10);
  assert (maximum_count [-2; -1; -1; 1; 2; 3] = 3);
  assert (maximum_count [-10; -9; -8; -7; -6; -5; -4; -3; -2; -1; 0] = 10);
  assert (maximum_count [5; 20; 66; 1314] = 4);
  assert (maximum_count [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = 10);
  assert (maximum_count [-1000; -500; -250; -100; -50; -25; -10; -5; -2; -1; 0; 1; 2; 5; 10; 25; 50; 100; 250; 500; 1000] = 10);
  assert (maximum_count [-10; -5; -1; -1; 0; 0; 1; 2; 3; 5; 10] = 5);
;;","easy","easy_103","easy"
"(**You are given two strings, word1 and word2. You want to construct a string in the following manner:
 * >>> longest_palindrome ""race"" ""car""
 * 7
 * >>> longest_palindrome ""a"" ""a""
 * 2
 * >>> longest_palindrome ""aabb"" ""bbcc""
 * 4
*)
let longest_palindrome (word1 : string) (word2 : string) : int =","  0","let () =
  assert (longest_palindrome ""race"" ""car"" = 7);
  assert (longest_palindrome ""a"" ""a"" = 2);
  assert (longest_palindrome ""aabb"" ""bbcc"" = 4);
  assert (longest_palindrome ""race"" ""care"" = 7);
  assert (longest_palindrome ""abcde"" ""edcba"" = 10);
  assert (longest_palindrome ""madam"" ""madam"" = 10);
  assert (longest_palindrome ""aabb"" ""bbaa"" = 8);
;;","hard","hard_006","hard"
"(**You have some apples and a basket that can carry up to 5000 units of weight.
 * >>> max_number_of_apples [1000; 1000; 1000; 1000; 1000]
 * 5
 * >>> max_number_of_apples [1000; 1000; 1000; 1000; 1000; 1000; 1000]
 * 5
 * >>> max_number_of_apples [1000; 1000; 1000; 1000; 1000; 1000; 1000; 1000; 1000; 1000; 1000; 1000; 1000; 1000; 1000; 1000; 1000; 1000; 1000; 1000]
 * 5
*)
let max_number_of_apples (weight : int list) : int =","  0","let () =
  assert (max_number_of_apples [1000; 1000; 1000; 1000; 1000] = 5);
  assert (max_number_of_apples [1000; 1000; 1000; 1000; 1000; 1000; 1000] = 5);
  assert (max_number_of_apples [1000; 1000; 1000; 1000; 1000; 1000; 1000; 1000; 1000; 1000; 1000; 1000; 1000; 1000; 1000; 1000; 1000; 1000; 1000; 1000] = 5);
  assert (max_number_of_apples [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = 10);
  assert (max_number_of_apples [1; 3; 5; 7; 9; 11; 13; 15; 17; 19; 21; 23; 25; 27; 29; 31; 33; 35; 37; 39; 41; 43; 45; 47; 49; 51; 53; 55; 57; 59] = 30);
  assert (max_number_of_apples [900; 950; 800; 1000; 700; 800] = 5);
  assert (max_number_of_apples [100; 200; 150; 1000] = 4);
;;","easy","easy_016","easy"
"(**You are given the root of a binary tree where each node has a value 0 or 1. Each root-to-leaf pat...
 * >>> sum_root_to_leaf [1; 1; 0; 1; 0; 0; 1]
 * 22
 * >>> sum_root_to_leaf [0; 0; 0; 0; 0; 0; 0]
 * 0
 * >>> sum_root_to_leaf [1; 1; 1]
 * 6
*)
let sum_root_to_leaf (root : 'a option) : int =","  0","let () =
  assert (sum_root_to_leaf [1; 1; 0; 1; 0; 0; 1] = 22);
  assert (sum_root_to_leaf [0; 0; 0; 0; 0; 0; 0] = 0);
  assert (sum_root_to_leaf [1; 1; 1] = 6);
  assert (sum_root_to_leaf [0] = 0);
  assert (sum_root_to_leaf [1; 0; 1; 0; 1; 0; 1] = 22);
  assert (sum_root_to_leaf [1; 1; 0; 0; 1; 0; 1] = 22);
  assert (sum_root_to_leaf [1; 0; 0; 1; 0; 0; 1] = 18);
;;","easy","easy_021","easy"
"(**There is a circle of red and blue tiles. You are given an array of integers colors. The color of ...
 * >>> number_of_alternating_groups [1; 1; 1; 0; 0; 0; 1; 1; 1]
 * 0
 * >>> number_of_alternating_groups [1; 0; 0; 0; 1; 1; 1; 0]
 * 2
 * >>> number_of_alternating_groups [0; 1; 0; 1; 0; 1; 0; 1; 0]
 * 7
*)
let number_of_alternating_groups (colors : int list) : int =","  0","let () =
  assert (number_of_alternating_groups [1; 1; 1; 0; 0; 0; 1; 1; 1] = 0);
  assert (number_of_alternating_groups [1; 0; 0; 0; 1; 1; 1; 0] = 2);
  assert (number_of_alternating_groups [0; 1; 0; 1; 0; 1; 0; 1; 0] = 7);
  assert (number_of_alternating_groups [0; 0; 1; 1; 0; 0; 1] = 1);
  assert (number_of_alternating_groups [0; 0; 1; 1; 0; 0; 1; 1; 0] = 0);
  assert (number_of_alternating_groups [0; 1; 1; 0; 0; 1] = 2);
  assert (number_of_alternating_groups [0; 1; 0; 1; 0] = 3);
;;","easy","easy_036","easy"
"(**You are given a large integer represented as an integer array digits, where each digits[i] is the...
 * >>> plus_one [5; 8; 9; 9; 9]
 * [5; 9; 0; 0; 0]
 * >>> plus_one [2; 0; 0; 0; 0]
 * [2; 0; 0; 0; 1]
 * >>> plus_one [1; 0; 0; 0]
 * [1; 0; 0; 1]
*)
let plus_one (digits : int list) : int list =","  []","let () =
  assert (plus_one [5; 8; 9; 9; 9] = [5; 9; 0; 0; 0]);
  assert (plus_one [2; 0; 0; 0; 0] = [2; 0; 0; 0; 1]);
  assert (plus_one [1; 0; 0; 0] = [1; 0; 0; 1]);
  assert (plus_one [1; 9; 9; 9; 9; 9; 9; 9; 9; 9] = [2; 0; 0; 0; 0; 0; 0; 0; 0; 0]);
  assert (plus_one [1; 2; 3] = [1; 2; 4]);
  assert (plus_one [1; 2; 9] = [1; 3; 0]);
  assert (plus_one [9] = [1; 0]);
;;","easy","easy_115","easy"
"(**Given an integer array nums, return the third distinct maximum number in this array. If the third...
 * >>> third_max [10; 10; 10; 9; 9; 8; 7; 6; 5; 4; 3; 2; 1]
 * 8
 * >>> third_max [3; 3; 3; 3; 3; 3; 3; 3; 3; 3]
 * 3
 * >>> third_max [1; 2; -2147483648]
 * -2147483648
*)
let third_max (nums : int list) : int =","  0","let () =
  assert (third_max [10; 10; 10; 9; 9; 8; 7; 6; 5; 4; 3; 2; 1] = 8);
  assert (third_max [3; 3; 3; 3; 3; 3; 3; 3; 3; 3] = 3);
  assert (third_max [1; 2; -2147483648] = -2147483648);
  assert (third_max [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = 8);
  assert (third_max [1; 2; 2; 3; 3; 4] = 2);
  assert (third_max [1] = 1);
  assert (third_max [2; 2; 3; 1] = 1);
;;","easy","easy_180","easy"
"(**You are given a string s containing lowercase English letters, and a matrix shift, where shift[i]...
 * >>> string_shift ""abcdefg"" [[1; 1]; [1; 1]; [0; 2]; [1; 3]]
 * efgabcd
 * >>> string_shift ""abc"" [[0; 1]; [1; 2]]
 * cab
 * >>> string_shift ""a"" [[0; 100]; [1; 100]; [0; 50]; [1; 50]; [0; 25]; [1; 25]]
 * a
*)
let string_shift (s : string) (shift : int list list) : string =","  """"","let () =
  assert (string_shift ""abcdefg"" [[1; 1]; [1; 1]; [0; 2]; [1; 3]] = efgabcd);
  assert (string_shift ""abc"" [[0; 1]; [1; 2]] = cab);
  assert (string_shift ""a"" [[0; 100]; [1; 100]; [0; 50]; [1; 50]; [0; 25]; [1; 25]] = a);
  assert (string_shift ""helloalibabacloud"" [[0; 1]; [0; 2]; [0; 3]; [1; 4]; [1; 5]; [0; 6]; [1; 7]; [0; 8]; [1; 9]] = cloudhelloalibaba);
  assert (string_shift ""pqrstuvwxyz"" [[0; 10]; [1; 10]; [0; 10]; [1; 10]] = pqrstuvwxyz);
  assert (string_shift ""abcd"" [[0; 1]; [0; 2]; [0; 3]; [0; 4]] = cdab);
  assert (string_shift ""qwen"" [[1; 1]; [0; 1]; [1; 1]; [0; 1]] = qwen);
;;","easy","easy_027","easy"
"(**Given an array of integers nums and an integer k, return the total number of subarrays whose sum ...
 * >>> subarray_sum [2; 2; 2; 2; 2] 4
 * 4
 * >>> subarray_sum [5; 5; 5; 5; 5; 5; 5; 5; 5; 5] 15
 * 8
 * >>> subarray_sum [0; 0; 0; 0; 0; 0; 0; 0; 0; 0] 0
 * 55
*)
let subarray_sum (nums : int list) (k : int) : int =","  0","let () =
  assert (subarray_sum [2; 2; 2; 2; 2] 4 = 4);
  assert (subarray_sum [5; 5; 5; 5; 5; 5; 5; 5; 5; 5] 15 = 8);
  assert (subarray_sum [0; 0; 0; 0; 0; 0; 0; 0; 0; 0] 0 = 55);
  assert (subarray_sum [1; 2; 1; 2; 1] 3 = 4);
  assert (subarray_sum [100; 200; 300; 400; 500] 1500 = 1);
  assert (subarray_sum [1000; -1000; 1000; -1000; 1000] 0 = 6);
  assert (subarray_sum [1; 2; 3; 4; 5] 9 = 2);
;;","medium","medium_188","medium"
"(**You are given an array apple of size n and an array capacity of size m.
 * >>> minimum_boxes [10; 20; 30] [15; 10; 25]
 * None
 * >>> minimum_boxes [10; 20; 30; 40] [10; 10; 10; 10; 10; 10; 10]
 * None
 * >>> minimum_boxes [45; 5] [50]
 * 1
*)
let minimum_boxes (apple : int list) (capacity : int list) : int =","  0","let () =
  assert (minimum_boxes [10; 20; 30] [15; 10; 25] = None);
  assert (minimum_boxes [10; 20; 30; 40] [10; 10; 10; 10; 10; 10; 10] = None);
  assert (minimum_boxes [45; 5] [50] = 1);
  assert (minimum_boxes [1; 1; 1; 1; 1] [1; 1; 1; 1; 1; 1] = 5);
  assert (minimum_boxes [10; 20; 30] [5; 15; 10; 20] = None);
  assert (minimum_boxes [2; 2; 2; 2] [1; 1; 1; 1; 1; 1; 1; 1] = 8);
  assert (minimum_boxes [1; 1; 1; 1] [1; 1; 1; 1; 1] = 4);
;;","easy","easy_010","easy"
"(**You are given the head of a linked list, which contains a series of integers separated by 0's. Th...
 * >>> merge_nodes [0; 3; 1; 0; 4; 5; 2; 0]
 * [4; 11]
 * >>> merge_nodes [0; 1; 2; 3; 4; 5; 0; 6; 7; 8; 9; 0]
 * [15; 30]
 * >>> merge_nodes [0; 10; 0]
 * [10]
*)
let merge_nodes (head : 'a option) : 'a option =","  None","let () =
  assert (merge_nodes [0; 3; 1; 0; 4; 5; 2; 0] = [4; 11]);
  assert (merge_nodes [0; 1; 2; 3; 4; 5; 0; 6; 7; 8; 9; 0] = [15; 30]);
  assert (merge_nodes [0; 10; 0] = [10]);
  assert (merge_nodes [0; 5; 6; 7; 8; 0; 9; 10; 11; 0] = [26; 30]);
  assert (merge_nodes [0; 10; 20; 30; 0; 40; 50; 60; 0] = [60; 150]);
  assert (merge_nodes [0; 1; 2; 3; 0; 4; 5; 6; 0] = [6; 15]);
  assert (merge_nodes [0; 999; 0; 1; 2; 3; 0; 1000; 0] = [999; 6; 1000]);
;;","medium","medium_041","medium"
"(**A game is played by a cat and a mouse named Cat and Mouse.
 * >>> can_mouse_win [""...M.""; "".F#C.""; "".....""] 2 2
 * true
 * >>> can_mouse_win [""M....""; "".....""; ""C.F..""] 1 1
 * false
 * >>> can_mouse_win [""C.......""; ""........""; ""........""; ""........""; ""........""; ""........""; ""........""; "".......M""] 5 5
 * false
*)
let can_mouse_win (grid : string list) (catJump : int) (mouseJump : int) : bool =","  false","let () =
  assert (can_mouse_win [""...M.""; "".F#C.""; "".....""] 2 2 = true);
  assert (can_mouse_win [""M....""; "".....""; ""C.F..""] 1 1 = false);
  assert (can_mouse_win [""C.......""; ""........""; ""........""; ""........""; ""........""; ""........""; ""........""; "".......M""] 5 5 = false);
  assert (can_mouse_win [""M......""; ""#F.C.#.""] 2 3 = false);
  assert (can_mouse_win [""M....""; "".F.C.""; "".....""] 1 1 = true);
  assert (can_mouse_win [""M....""; "".#C..""; ""..#F.""; "".....""] 3 1 = false);
  assert (can_mouse_win [""M....""; "".....""; "".F.C.""] 1 1 = false);
;;","hard","hard_078","hard"
"(**Given an array of meeting time intervals where intervals[i] = [starti, endi], determine if a pers...
 * >>> can_attend_meetings [[1; 5]; [2; 3]]
 * false
 * >>> can_attend_meetings [[1; 2]]
 * true
 * >>> can_attend_meetings [[1; 2]; [2; 3]]
 * true
*)
let can_attend_meetings (intervals : int list list) : bool =","  false","let () =
  assert (can_attend_meetings [[1; 5]; [2; 3]] = false);
  assert (can_attend_meetings [[1; 2]] = true);
  assert (can_attend_meetings [[1; 2]; [2; 3]] = true);
  assert (can_attend_meetings [[1; 2]; [3; 4]; [5; 6]] = true);
  assert (can_attend_meetings [[1; 10]] = true);
  assert (can_attend_meetings [[1; 1000000]; [1000001; 2000000]] = true);
  assert (can_attend_meetings [[1; 2]; [2; 3]; [3; 4]] = true);
;;","easy","easy_130","easy"
"(**A chef has collected data on the satisfaction level of his n dishes. Chef can cook any dish in 1 ...
 * >>> max_satisfaction [1; -1; 2; -2; 3; -3]
 * 22
 * >>> max_satisfaction [0]
 * 0
 * >>> max_satisfaction [-1]
 * 0
*)
let max_satisfaction (satisfaction : int list) : int =","  0","let () =
  assert (max_satisfaction [1; -1; 2; -2; 3; -3] = 22);
  assert (max_satisfaction [0] = 0);
  assert (max_satisfaction [-1] = 0);
  assert (max_satisfaction [-500; -500; -500; -500; -500] = 0);
  assert (max_satisfaction [0; 0; 0; 0; 0] = 0);
  assert (max_satisfaction [-1000; 1000; -500; 500] = 3500);
  assert (max_satisfaction [0; 0; 0; 0] = 0);
;;","hard","hard_017","hard"
"(**You are given a 0-indexed array nums of length n containing distinct positive integers. Return th...
 * >>> minimum_right_shifts [100; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
 * 10
 * >>> minimum_right_shifts [4; 5; 6; 1; 2; 3]
 * 3
 * >>> minimum_right_shifts [1]
 * 0
*)
let minimum_right_shifts (nums : int list) : int =","  0","let () =
  assert (minimum_right_shifts [100; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = 10);
  assert (minimum_right_shifts [4; 5; 6; 1; 2; 3] = 3);
  assert (minimum_right_shifts [1] = 0);
  assert (minimum_right_shifts [50; 10; 20; 30; 40] = 4);
  assert (minimum_right_shifts [1; 3; 5] = 0);
  assert (minimum_right_shifts [2; 1; 4] = -1);
  assert (minimum_right_shifts [4; 5; 1; 2; 3] = 3);
;;","easy","easy_143","easy"
"(**Given an integer n, return a list of all simplified fractions between 0 and 1 (exclusive) such th...
 * >>> simplified_fractions 3
 * ['1/2'; '1/3'; '2/3']
 * >>> simplified_fractions 4
 * ['1/2'; '1/3'; '1/4'; '2/3'; '3/4']
 * >>> simplified_fractions 2
 * ['1/2']
*)
let simplified_fractions (n : int) : string list =","  []","let () =
  assert (simplified_fractions 3 = ['1/2'; '1/3'; '2/3']);
  assert (simplified_fractions 4 = ['1/2'; '1/3'; '1/4'; '2/3'; '3/4']);
  assert (simplified_fractions 2 = ['1/2']);
  assert (simplified_fractions 20 = ['1/2'; '1/3'; '1/4'; '1/5'; '1/6'; '1/7'; '1/8'; '1/9'; '1/10'; '1/11'; '1/12'; '1/13'; '1/14'; '1/15'; '1/16'; '1/17'; '1/18'; '1/19'; '1/20'; '2/3'; '2/5'; '2/7'; '2/9'; '2/11'; '2/13'; '2/15'; '2/17'; '2/19'; '3/4'; '3/5'; '3/7'; '3/8'; '3/10'; '3/11'; '3/13'; '3/14'; '3/16'; '3/17'; '3/19'; '3/20'; '4/5'; '4/7'; '4/9'; '4/11'; '4/13'; '4/15'; '4/17'; '4/19'; '5/6'; '5/7'; '5/8'; '5/9'; '5/11'; '5/12'; '5/13'; '5/14'; '5/16'; '5/17'; '5/18'; '5/19'; '6/7'; '6/11'; '6/13'; '6/17'; '6/19'; '7/8'; '7/9'; '7/10'; '7/11'; '7/12'; '7/13'; '7/15'; '7/16'; '7/17'; '7/18'; '7/19'; '7/20'; '8/9'; '8/11'; '8/13'; '8/15'; '8/17'; '8/19'; '9/10'; '9/11'; '9/13'; '9/14'; '9/16'; '9/17'; '9/19'; '9/20'; '10/11'; '10/13'; '10/17'; '10/19'; '11/12'; '11/13'; '11/14'; '11/15'; '11/16'; '11/17'; '11/18'; '11/19'; '11/20'; '12/13'; '12/17'; '12/19'; '13/14'; '13/15'; '13/16'; '13/17'; '13/18'; '13/19'; '13/20'; '14/15'; '14/17'; '14/19'; '15/16'; '15/17'; '15/19'; '16/17'; '16/19'; '17/18'; '17/19'; '17/20'; '18/19'; '19/20']);
  assert (simplified_fractions 100 = ['1/2'; '1/3'; '1/4'; '1/5'; '1/6'; '1/7'; '1/8'; '1/9'; '1/10'; '1/11'; '1/12'; '1/13'; '1/14'; '1/15'; '1/16'; '1/17'; '1/18'; '1/19'; '1/20'; '1/21'; '1/22'; '1/23'; '1/24'; '1/25'; '1/26'; '1/27'; '1/28'; '1/29'; '1/30'; '1/31'; '1/32'; '1/33'; '1/34'; '1/35'; '1/36'; '1/37'; '1/38'; '1/39'; '1/40'; '1/41'; '1/42'; '1/43'; '1/44'; '1/45'; '1/46'; '1/47'; '1/48'; '1/49'; '1/50'; '1/51'; '1/52'; '1/53'; '1/54'; '1/55'; '1/56'; '1/57'; '1/58'; '1/59'; '1/60'; '1/61'; '1/62'; '1/63'; '1/64'; '1/65'; '1/66'; '1/67'; '1/68'; '1/69'; '1/70'; '1/71'; '1/72'; '1/73'; '1/74'; '1/75'; '1/76'; '1/77'; '1/78'; '1/79'; '1/80'; '1/81'; '1/82'; '1/83'; '1/84'; '1/85'; '1/86'; '1/87'; '1/88'; '1/89'; '1/90'; '1/91'; '1/92'; '1/93'; '1/94'; '1/95'; '1/96'; '1/97'; '1/98'; '1/99'; '1/100'; '2/3'; '2/5'; '2/7'; '2/9'; '2/11'; '2/13'; '2/15'; '2/17'; '2/19'; '2/21'; '2/23'; '2/25'; '2/27'; '2/29'; '2/31'; '2/33'; '2/35'; '2/37'; '2/39'; '2/41'; '2/43'; '2/45'; '2/47'; '2/49'; '2/51'; '2/53'; '2/55'; '2/57'; '2/59'; '2/61'; '2/63'; '2/65'; '2/67'; '2/69'; '2/71'; '2/73'; '2/75'; '2/77'; '2/79'; '2/81'; '2/83'; '2/85'; '2/87'; '2/89'; '2/91'; '2/93'; '2/95'; '2/97'; '2/99'; '3/4'; '3/5'; '3/7'; '3/8'; '3/10'; '3/11'; '3/13'; '3/14'; '3/16'; '3/17'; '3/19'; '3/20'; '3/22'; '3/23'; '3/25'; '3/26'; '3/28'; '3/29'; '3/31'; '3/32'; '3/34'; '3/35'; '3/37'; '3/38'; '3/40'; '3/41'; '3/43'; '3/44'; '3/46'; '3/47'; '3/49'; '3/50'; '3/52'; '3/53'; '3/55'; '3/56'; '3/58'; '3/59'; '3/61'; '3/62'; '3/64'; '3/65'; '3/67'; '3/68'; '3/70'; '3/71'; '3/73'; '3/74'; '3/76'; '3/77'; '3/79'; '3/80'; '3/82'; '3/83'; '3/85'; '3/86'; '3/88'; '3/89'; '3/91'; '3/92'; '3/94'; '3/95'; '3/97'; '3/98'; '3/100'; '4/5'; '4/7'; '4/9'; '4/11'; '4/13'; '4/15'; '4/17'; '4/19'; '4/21'; '4/23'; '4/25'; '4/27'; '4/29'; '4/31'; '4/33'; '4/35'; '4/37'; '4/39'; '4/41'; '4/43'; '4/45'; '4/47'; '4/49'; '4/51'; '4/53'; '4/55'; '4/57'; '4/59'; '4/61'; '4/63'; '4/65'; '4/67'; '4/69'; '4/71'; '4/73'; '4/75'; '4/77'; '4/79'; '4/81'; '4/83'; '4/85'; '4/87'; '4/89'; '4/91'; '4/93'; '4/95'; '4/97'; '4/99'; '5/6'; '5/7'; '5/8'; '5/9'; '5/11'; '5/12'; '5/13'; '5/14'; '5/16'; '5/17'; '5/18'; '5/19'; '5/21'; '5/22'; '5/23'; '5/24'; '5/26'; '5/27'; '5/28'; '5/29'; '5/31'; '5/32'; '5/33'; '5/34'; '5/36'; '5/37'; '5/38'; '5/39'; '5/41'; '5/42'; '5/43'; '5/44'; '5/46'; '5/47'; '5/48'; '5/49'; '5/51'; '5/52'; '5/53'; '5/54'; '5/56'; '5/57'; '5/58'; '5/59'; '5/61'; '5/62'; '5/63'; '5/64'; '5/66'; '5/67'; '5/68'; '5/69'; '5/71'; '5/72'; '5/73'; '5/74'; '5/76'; '5/77'; '5/78'; '5/79'; '5/81'; '5/82'; '5/83'; '5/84'; '5/86'; '5/87'; '5/88'; '5/89'; '5/91'; '5/92'; '5/93'; '5/94'; '5/96'; '5/97'; '5/98'; '5/99'; '6/7'; '6/11'; '6/13'; '6/17'; '6/19'; '6/23'; '6/25'; '6/29'; '6/31'; '6/35'; '6/37'; '6/41'; '6/43'; '6/47'; '6/49'; '6/53'; '6/55'; '6/59'; '6/61'; '6/65'; '6/67'; '6/71'; '6/73'; '6/77'; '6/79'; '6/83'; '6/85'; '6/89'; '6/91'; '6/95'; '6/97'; '7/8'; '7/9'; '7/10'; '7/11'; '7/12'; '7/13'; '7/15'; '7/16'; '7/17'; '7/18'; '7/19'; '7/20'; '7/22'; '7/23'; '7/24'; '7/25'; '7/26'; '7/27'; '7/29'; '7/30'; '7/31'; '7/32'; '7/33'; '7/34'; '7/36'; '7/37'; '7/38'; '7/39'; '7/40'; '7/41'; '7/43'; '7/44'; '7/45'; '7/46'; '7/47'; '7/48'; '7/50'; '7/51'; '7/52'; '7/53'; '7/54'; '7/55'; '7/57'; '7/58'; '7/59'; '7/60'; '7/61'; '7/62'; '7/64'; '7/65'; '7/66'; '7/67'; '7/68'; '7/69'; '7/71'; '7/72'; '7/73'; '7/74'; '7/75'; '7/76'; '7/78'; '7/79'; '7/80'; '7/81'; '7/82'; '7/83'; '7/85'; '7/86'; '7/87'; '7/88'; '7/89'; '7/90'; '7/92'; '7/93'; '7/94'; '7/95'; '7/96'; '7/97'; '7/99'; '7/100'; '8/9'; '8/11'; '8/13'; '8/15'; '8/17'; '8/19'; '8/21'; '8/23'; '8/25'; '8/27'; '8/29'; '8/31'; '8/33'; '8/35'; '8/37'; '8/39'; '8/41'; '8/43'; '8/45'; '8/47'; '8/49'; '8/51'; '8/53'; '8/55'; '8/57'; '8/59'; '8/61'; '8/63'; '8/65'; '8/67'; '8/69'; '8/71'; '8/73'; '8/75'; '8/77'; '8/79'; '8/81'; '8/83'; '8/85'; '8/87'; '8/89'; '8/91'; '8/93'; '8/95'; '8/97'; '8/99'; '9/10'; '9/11'; '9/13'; '9/14'; '9/16'; '9/17'; '9/19'; '9/20'; '9/22'; '9/23'; '9/25'; '9/26'; '9/28'; '9/29'; '9/31'; '9/32'; '9/34'; '9/35'; '9/37'; '9/38'; '9/40'; '9/41'; '9/43'; '9/44'; '9/46'; '9/47'; '9/49'; '9/50'; '9/52'; '9/53'; '9/55'; '9/56'; '9/58'; '9/59'; '9/61'; '9/62'; '9/64'; '9/65'; '9/67'; '9/68'; '9/70'; '9/71'; '9/73'; '9/74'; '9/76'; '9/77'; '9/79'; '9/80'; '9/82'; '9/83'; '9/85'; '9/86'; '9/88'; '9/89'; '9/91'; '9/92'; '9/94'; '9/95'; '9/97'; '9/98'; '9/100'; '10/11'; '10/13'; '10/17'; '10/19'; '10/21'; '10/23'; '10/27'; '10/29'; '10/31'; '10/33'; '10/37'; '10/39'; '10/41'; '10/43'; '10/47'; '10/49'; '10/51'; '10/53'; '10/57'; '10/59'; '10/61'; '10/63'; '10/67'; '10/69'; '10/71'; '10/73'; '10/77'; '10/79'; '10/81'; '10/83'; '10/87'; '10/89'; '10/91'; '10/93'; '10/97'; '10/99'; '11/12'; '11/13'; '11/14'; '11/15'; '11/16'; '11/17'; '11/18'; '11/19'; '11/20'; '11/21'; '11/23'; '11/24'; '11/25'; '11/26'; '11/27'; '11/28'; '11/29'; '11/30'; '11/31'; '11/32'; '11/34'; '11/35'; '11/36'; '11/37'; '11/38'; '11/39'; '11/40'; '11/41'; '11/42'; '11/43'; '11/45'; '11/46'; '11/47'; '11/48'; '11/49'; '11/50'; '11/51'; '11/52'; '11/53'; '11/54'; '11/56'; '11/57'; '11/58'; '11/59'; '11/60'; '11/61'; '11/62'; '11/63'; '11/64'; '11/65'; '11/67'; '11/68'; '11/69'; '11/70'; '11/71'; '11/72'; '11/73'; '11/74'; '11/75'; '11/76'; '11/78'; '11/79'; '11/80'; '11/81'; '11/82'; '11/83'; '11/84'; '11/85'; '11/86'; '11/87'; '11/89'; '11/90'; '11/91'; '11/92'; '11/93'; '11/94'; '11/95'; '11/96'; '11/97'; '11/98'; '11/100'; '12/13'; '12/17'; '12/19'; '12/23'; '12/25'; '12/29'; '12/31'; '12/35'; '12/37'; '12/41'; '12/43'; '12/47'; '12/49'; '12/53'; '12/55'; '12/59'; '12/61'; '12/65'; '12/67'; '12/71'; '12/73'; '12/77'; '12/79'; '12/83'; '12/85'; '12/89'; '12/91'; '12/95'; '12/97'; '13/14'; '13/15'; '13/16'; '13/17'; '13/18'; '13/19'; '13/20'; '13/21'; '13/22'; '13/23'; '13/24'; '13/25'; '13/27'; '13/28'; '13/29'; '13/30'; '13/31'; '13/32'; '13/33'; '13/34'; '13/35'; '13/36'; '13/37'; '13/38'; '13/40'; '13/41'; '13/42'; '13/43'; '13/44'; '13/45'; '13/46'; '13/47'; '13/48'; '13/49'; '13/50'; '13/51'; '13/53'; '13/54'; '13/55'; '13/56'; '13/57'; '13/58'; '13/59'; '13/60'; '13/61'; '13/62'; '13/63'; '13/64'; '13/66'; '13/67'; '13/68'; '13/69'; '13/70'; '13/71'; '13/72'; '13/73'; '13/74'; '13/75'; '13/76'; '13/77'; '13/79'; '13/80'; '13/81'; '13/82'; '13/83'; '13/84'; '13/85'; '13/86'; '13/87'; '13/88'; '13/89'; '13/90'; '13/92'; '13/93'; '13/94'; '13/95'; '13/96'; '13/97'; '13/98'; '13/99'; '13/100'; '14/15'; '14/17'; '14/19'; '14/23'; '14/25'; '14/27'; '14/29'; '14/31'; '14/33'; '14/37'; '14/39'; '14/41'; '14/43'; '14/45'; '14/47'; '14/51'; '14/53'; '14/55'; '14/57'; '14/59'; '14/61'; '14/65'; '14/67'; '14/69'; '14/71'; '14/73'; '14/75'; '14/79'; '14/81'; '14/83'; '14/85'; '14/87'; '14/89'; '14/93'; '14/95'; '14/97'; '14/99'; '15/16'; '15/17'; '15/19'; '15/22'; '15/23'; '15/26'; '15/28'; '15/29'; '15/31'; '15/32'; '15/34'; '15/37'; '15/38'; '15/41'; '15/43'; '15/44'; '15/46'; '15/47'; '15/49'; '15/52'; '15/53'; '15/56'; '15/58'; '15/59'; '15/61'; '15/62'; '15/64'; '15/67'; '15/68'; '15/71'; '15/73'; '15/74'; '15/76'; '15/77'; '15/79'; '15/82'; '15/83'; '15/86'; '15/88'; '15/89'; '15/91'; '15/92'; '15/94'; '15/97'; '15/98'; '16/17'; '16/19'; '16/21'; '16/23'; '16/25'; '16/27'; '16/29'; '16/31'; '16/33'; '16/35'; '16/37'; '16/39'; '16/41'; '16/43'; '16/45'; '16/47'; '16/49'; '16/51'; '16/53'; '16/55'; '16/57'; '16/59'; '16/61'; '16/63'; '16/65'; '16/67'; '16/69'; '16/71'; '16/73'; '16/75'; '16/77'; '16/79'; '16/81'; '16/83'; '16/85'; '16/87'; '16/89'; '16/91'; '16/93'; '16/95'; '16/97'; '16/99'; '17/18'; '17/19'; '17/20'; '17/21'; '17/22'; '17/23'; '17/24'; '17/25'; '17/26'; '17/27'; '17/28'; '17/29'; '17/30'; '17/31'; '17/32'; '17/33'; '17/35'; '17/36'; '17/37'; '17/38'; '17/39'; '17/40'; '17/41'; '17/42'; '17/43'; '17/44'; '17/45'; '17/46'; '17/47'; '17/48'; '17/49'; '17/50'; '17/52'; '17/53'; '17/54'; '17/55'; '17/56'; '17/57'; '17/58'; '17/59'; '17/60'; '17/61'; '17/62'; '17/63'; '17/64'; '17/65'; '17/66'; '17/67'; '17/69'; '17/70'; '17/71'; '17/72'; '17/73'; '17/74'; '17/75'; '17/76'; '17/77'; '17/78'; '17/79'; '17/80'; '17/81'; '17/82'; '17/83'; '17/84'; '17/86'; '17/87'; '17/88'; '17/89'; '17/90'; '17/91'; '17/92'; '17/93'; '17/94'; '17/95'; '17/96'; '17/97'; '17/98'; '17/99'; '17/100'; '18/19'; '18/23'; '18/25'; '18/29'; '18/31'; '18/35'; '18/37'; '18/41'; '18/43'; '18/47'; '18/49'; '18/53'; '18/55'; '18/59'; '18/61'; '18/65'; '18/67'; '18/71'; '18/73'; '18/77'; '18/79'; '18/83'; '18/85'; '18/89'; '18/91'; '18/95'; '18/97'; '19/20'; '19/21'; '19/22'; '19/23'; '19/24'; '19/25'; '19/26'; '19/27'; '19/28'; '19/29'; '19/30'; '19/31'; '19/32'; '19/33'; '19/34'; '19/35'; '19/36'; '19/37'; '19/39'; '19/40'; '19/41'; '19/42'; '19/43'; '19/44'; '19/45'; '19/46'; '19/47'; '19/48'; '19/49'; '19/50'; '19/51'; '19/52'; '19/53'; '19/54'; '19/55'; '19/56'; '19/58'; '19/59'; '19/60'; '19/61'; '19/62'; '19/63'; '19/64'; '19/65'; '19/66'; '19/67'; '19/68'; '19/69'; '19/70'; '19/71'; '19/72'; '19/73'; '19/74'; '19/75'; '19/77'; '19/78'; '19/79'; '19/80'; '19/81'; '19/82'; '19/83'; '19/84'; '19/85'; '19/86'; '19/87'; '19/88'; '19/89'; '19/90'; '19/91'; '19/92'; '19/93'; '19/94'; '19/96'; '19/97'; '19/98'; '19/99'; '19/100'; '20/21'; '20/23'; '20/27'; '20/29'; '20/31'; '20/33'; '20/37'; '20/39'; '20/41'; '20/43'; '20/47'; '20/49'; '20/51'; '20/53'; '20/57'; '20/59'; '20/61'; '20/63'; '20/67'; '20/69'; '20/71'; '20/73'; '20/77'; '20/79'; '20/81'; '20/83'; '20/87'; '20/89'; '20/91'; '20/93'; '20/97'; '20/99'; '21/22'; '21/23'; '21/25'; '21/26'; '21/29'; '21/31'; '21/32'; '21/34'; '21/37'; '21/38'; '21/40'; '21/41'; '21/43'; '21/44'; '21/46'; '21/47'; '21/50'; '21/52'; '21/53'; '21/55'; '21/58'; '21/59'; '21/61'; '21/62'; '21/64'; '21/65'; '21/67'; '21/68'; '21/71'; '21/73'; '21/74'; '21/76'; '21/79'; '21/80'; '21/82'; '21/83'; '21/85'; '21/86'; '21/88'; '21/89'; '21/92'; '21/94'; '21/95'; '21/97'; '21/100'; '22/23'; '22/25'; '22/27'; '22/29'; '22/31'; '22/35'; '22/37'; '22/39'; '22/41'; '22/43'; '22/45'; '22/47'; '22/49'; '22/51'; '22/53'; '22/57'; '22/59'; '22/61'; '22/63'; '22/65'; '22/67'; '22/69'; '22/71'; '22/73'; '22/75'; '22/79'; '22/81'; '22/83'; '22/85'; '22/87'; '22/89'; '22/91'; '22/93'; '22/95'; '22/97'; '23/24'; '23/25'; '23/26'; '23/27'; '23/28'; '23/29'; '23/30'; '23/31'; '23/32'; '23/33'; '23/34'; '23/35'; '23/36'; '23/37'; '23/38'; '23/39'; '23/40'; '23/41'; '23/42'; '23/43'; '23/44'; '23/45'; '23/47'; '23/48'; '23/49'; '23/50'; '23/51'; '23/52'; '23/53'; '23/54'; '23/55'; '23/56'; '23/57'; '23/58'; '23/59'; '23/60'; '23/61'; '23/62'; '23/63'; '23/64'; '23/65'; '23/66'; '23/67'; '23/68'; '23/70'; '23/71'; '23/72'; '23/73'; '23/74'; '23/75'; '23/76'; '23/77'; '23/78'; '23/79'; '23/80'; '23/81'; '23/82'; '23/83'; '23/84'; '23/85'; '23/86'; '23/87'; '23/88'; '23/89'; '23/90'; '23/91'; '23/93'; '23/94'; '23/95'; '23/96'; '23/97'; '23/98'; '23/99'; '23/100'; '24/25'; '24/29'; '24/31'; '24/35'; '24/37'; '24/41'; '24/43'; '24/47'; '24/49'; '24/53'; '24/55'; '24/59'; '24/61'; '24/65'; '24/67'; '24/71'; '24/73'; '24/77'; '24/79'; '24/83'; '24/85'; '24/89'; '24/91'; '24/95'; '24/97'; '25/26'; '25/27'; '25/28'; '25/29'; '25/31'; '25/32'; '25/33'; '25/34'; '25/36'; '25/37'; '25/38'; '25/39'; '25/41'; '25/42'; '25/43'; '25/44'; '25/46'; '25/47'; '25/48'; '25/49'; '25/51'; '25/52'; '25/53'; '25/54'; '25/56'; '25/57'; '25/58'; '25/59'; '25/61'; '25/62'; '25/63'; '25/64'; '25/66'; '25/67'; '25/68'; '25/69'; '25/71'; '25/72'; '25/73'; '25/74'; '25/76'; '25/77'; '25/78'; '25/79'; '25/81'; '25/82'; '25/83'; '25/84'; '25/86'; '25/87'; '25/88'; '25/89'; '25/91'; '25/92'; '25/93'; '25/94'; '25/96'; '25/97'; '25/98'; '25/99'; '26/27'; '26/29'; '26/31'; '26/33'; '26/35'; '26/37'; '26/41'; '26/43'; '26/45'; '26/47'; '26/49'; '26/51'; '26/53'; '26/55'; '26/57'; '26/59'; '26/61'; '26/63'; '26/67'; '26/69'; '26/71'; '26/73'; '26/75'; '26/77'; '26/79'; '26/81'; '26/83'; '26/85'; '26/87'; '26/89'; '26/93'; '26/95'; '26/97'; '26/99'; '27/28'; '27/29'; '27/31'; '27/32'; '27/34'; '27/35'; '27/37'; '27/38'; '27/40'; '27/41'; '27/43'; '27/44'; '27/46'; '27/47'; '27/49'; '27/50'; '27/52'; '27/53'; '27/55'; '27/56'; '27/58'; '27/59'; '27/61'; '27/62'; '27/64'; '27/65'; '27/67'; '27/68'; '27/70'; '27/71'; '27/73'; '27/74'; '27/76'; '27/77'; '27/79'; '27/80'; '27/82'; '27/83'; '27/85'; '27/86'; '27/88'; '27/89'; '27/91'; '27/92'; '27/94'; '27/95'; '27/97'; '27/98'; '27/100'; '28/29'; '28/31'; '28/33'; '28/37'; '28/39'; '28/41'; '28/43'; '28/45'; '28/47'; '28/51'; '28/53'; '28/55'; '28/57'; '28/59'; '28/61'; '28/65'; '28/67'; '28/69'; '28/71'; '28/73'; '28/75'; '28/79'; '28/81'; '28/83'; '28/85'; '28/87'; '28/89'; '28/93'; '28/95'; '28/97'; '28/99'; '29/30'; '29/31'; '29/32'; '29/33'; '29/34'; '29/35'; '29/36'; '29/37'; '29/38'; '29/39'; '29/40'; '29/41'; '29/42'; '29/43'; '29/44'; '29/45'; '29/46'; '29/47'; '29/48'; '29/49'; '29/50'; '29/51'; '29/52'; '29/53'; '29/54'; '29/55'; '29/56'; '29/57'; '29/59'; '29/60'; '29/61'; '29/62'; '29/63'; '29/64'; '29/65'; '29/66'; '29/67'; '29/68'; '29/69'; '29/70'; '29/71'; '29/72'; '29/73'; '29/74'; '29/75'; '29/76'; '29/77'; '29/78'; '29/79'; '29/80'; '29/81'; '29/82'; '29/83'; '29/84'; '29/85'; '29/86'; '29/88'; '29/89'; '29/90'; '29/91'; '29/92'; '29/93'; '29/94'; '29/95'; '29/96'; '29/97'; '29/98'; '29/99'; '29/100'; '30/31'; '30/37'; '30/41'; '30/43'; '30/47'; '30/49'; '30/53'; '30/59'; '30/61'; '30/67'; '30/71'; '30/73'; '30/77'; '30/79'; '30/83'; '30/89'; '30/91'; '30/97'; '31/32'; '31/33'; '31/34'; '31/35'; '31/36'; '31/37'; '31/38'; '31/39'; '31/40'; '31/41'; '31/42'; '31/43'; '31/44'; '31/45'; '31/46'; '31/47'; '31/48'; '31/49'; '31/50'; '31/51'; '31/52'; '31/53'; '31/54'; '31/55'; '31/56'; '31/57'; '31/58'; '31/59'; '31/60'; '31/61'; '31/63'; '31/64'; '31/65'; '31/66'; '31/67'; '31/68'; '31/69'; '31/70'; '31/71'; '31/72'; '31/73'; '31/74'; '31/75'; '31/76'; '31/77'; '31/78'; '31/79'; '31/80'; '31/81'; '31/82'; '31/83'; '31/84'; '31/85'; '31/86'; '31/87'; '31/88'; '31/89'; '31/90'; '31/91'; '31/92'; '31/94'; '31/95'; '31/96'; '31/97'; '31/98'; '31/99'; '31/100'; '32/33'; '32/35'; '32/37'; '32/39'; '32/41'; '32/43'; '32/45'; '32/47'; '32/49'; '32/51'; '32/53'; '32/55'; '32/57'; '32/59'; '32/61'; '32/63'; '32/65'; '32/67'; '32/69'; '32/71'; '32/73'; '32/75'; '32/77'; '32/79'; '32/81'; '32/83'; '32/85'; '32/87'; '32/89'; '32/91'; '32/93'; '32/95'; '32/97'; '32/99'; '33/34'; '33/35'; '33/37'; '33/38'; '33/40'; '33/41'; '33/43'; '33/46'; '33/47'; '33/49'; '33/50'; '33/52'; '33/53'; '33/56'; '33/58'; '33/59'; '33/61'; '33/62'; '33/64'; '33/65'; '33/67'; '33/68'; '33/70'; '33/71'; '33/73'; '33/74'; '33/76'; '33/79'; '33/80'; '33/82'; '33/83'; '33/85'; '33/86'; '33/89'; '33/91'; '33/92'; '33/94'; '33/95'; '33/97'; '33/98'; '33/100'; '34/35'; '34/37'; '34/39'; '34/41'; '34/43'; '34/45'; '34/47'; '34/49'; '34/53'; '34/55'; '34/57'; '34/59'; '34/61'; '34/63'; '34/65'; '34/67'; '34/69'; '34/71'; '34/73'; '34/75'; '34/77'; '34/79'; '34/81'; '34/83'; '34/87'; '34/89'; '34/91'; '34/93'; '34/95'; '34/97'; '34/99'; '35/36'; '35/37'; '35/38'; '35/39'; '35/41'; '35/43'; '35/44'; '35/46'; '35/47'; '35/48'; '35/51'; '35/52'; '35/53'; '35/54'; '35/57'; '35/58'; '35/59'; '35/61'; '35/62'; '35/64'; '35/66'; '35/67'; '35/68'; '35/69'; '35/71'; '35/72'; '35/73'; '35/74'; '35/76'; '35/78'; '35/79'; '35/81'; '35/82'; '35/83'; '35/86'; '35/87'; '35/88'; '35/89'; '35/92'; '35/93'; '35/94'; '35/96'; '35/97'; '35/99'; '36/37'; '36/41'; '36/43'; '36/47'; '36/49'; '36/53'; '36/55'; '36/59'; '36/61'; '36/65'; '36/67'; '36/71'; '36/73'; '36/77'; '36/79'; '36/83'; '36/85'; '36/89'; '36/91'; '36/95'; '36/97'; '37/38'; '37/39'; '37/40'; '37/41'; '37/42'; '37/43'; '37/44'; '37/45'; '37/46'; '37/47'; '37/48'; '37/49'; '37/50'; '37/51'; '37/52'; '37/53'; '37/54'; '37/55'; '37/56'; '37/57'; '37/58'; '37/59'; '37/60'; '37/61'; '37/62'; '37/63'; '37/64'; '37/65'; '37/66'; '37/67'; '37/68'; '37/69'; '37/70'; '37/71'; '37/72'; '37/73'; '37/75'; '37/76'; '37/77'; '37/78'; '37/79'; '37/80'; '37/81'; '37/82'; '37/83'; '37/84'; '37/85'; '37/86'; '37/87'; '37/88'; '37/89'; '37/90'; '37/91'; '37/92'; '37/93'; '37/94'; '37/95'; '37/96'; '37/97'; '37/98'; '37/99'; '37/100'; '38/39'; '38/41'; '38/43'; '38/45'; '38/47'; '38/49'; '38/51'; '38/53'; '38/55'; '38/59'; '38/61'; '38/63'; '38/65'; '38/67'; '38/69'; '38/71'; '38/73'; '38/75'; '38/77'; '38/79'; '38/81'; '38/83'; '38/85'; '38/87'; '38/89'; '38/91'; '38/93'; '38/97'; '38/99'; '39/40'; '39/41'; '39/43'; '39/44'; '39/46'; '39/47'; '39/49'; '39/50'; '39/53'; '39/55'; '39/56'; '39/58'; '39/59'; '39/61'; '39/62'; '39/64'; '39/67'; '39/68'; '39/70'; '39/71'; '39/73'; '39/74'; '39/76'; '39/77'; '39/79'; '39/80'; '39/82'; '39/83'; '39/85'; '39/86'; '39/88'; '39/89'; '39/92'; '39/94'; '39/95'; '39/97'; '39/98'; '39/100'; '40/41'; '40/43'; '40/47'; '40/49'; '40/51'; '40/53'; '40/57'; '40/59'; '40/61'; '40/63'; '40/67'; '40/69'; '40/71'; '40/73'; '40/77'; '40/79'; '40/81'; '40/83'; '40/87'; '40/89'; '40/91'; '40/93'; '40/97'; '40/99'; '41/42'; '41/43'; '41/44'; '41/45'; '41/46'; '41/47'; '41/48'; '41/49'; '41/50'; '41/51'; '41/52'; '41/53'; '41/54'; '41/55'; '41/56'; '41/57'; '41/58'; '41/59'; '41/60'; '41/61'; '41/62'; '41/63'; '41/64'; '41/65'; '41/66'; '41/67'; '41/68'; '41/69'; '41/70'; '41/71'; '41/72'; '41/73'; '41/74'; '41/75'; '41/76'; '41/77'; '41/78'; '41/79'; '41/80'; '41/81'; '41/83'; '41/84'; '41/85'; '41/86'; '41/87'; '41/88'; '41/89'; '41/90'; '41/91'; '41/92'; '41/93'; '41/94'; '41/95'; '41/96'; '41/97'; '41/98'; '41/99'; '41/100'; '42/43'; '42/47'; '42/53'; '42/55'; '42/59'; '42/61'; '42/65'; '42/67'; '42/71'; '42/73'; '42/79'; '42/83'; '42/85'; '42/89'; '42/95'; '42/97'; '43/44'; '43/45'; '43/46'; '43/47'; '43/48'; '43/49'; '43/50'; '43/51'; '43/52'; '43/53'; '43/54'; '43/55'; '43/56'; '43/57'; '43/58'; '43/59'; '43/60'; '43/61'; '43/62'; '43/63'; '43/64'; '43/65'; '43/66'; '43/67'; '43/68'; '43/69'; '43/70'; '43/71'; '43/72'; '43/73'; '43/74'; '43/75'; '43/76'; '43/77'; '43/78'; '43/79'; '43/80'; '43/81'; '43/82'; '43/83'; '43/84'; '43/85'; '43/87'; '43/88'; '43/89'; '43/90'; '43/91'; '43/92'; '43/93'; '43/94'; '43/95'; '43/96'; '43/97'; '43/98'; '43/99'; '43/100'; '44/45'; '44/47'; '44/49'; '44/51'; '44/53'; '44/57'; '44/59'; '44/61'; '44/63'; '44/65'; '44/67'; '44/69'; '44/71'; '44/73'; '44/75'; '44/79'; '44/81'; '44/83'; '44/85'; '44/87'; '44/89'; '44/91'; '44/93'; '44/95'; '44/97'; '45/46'; '45/47'; '45/49'; '45/52'; '45/53'; '45/56'; '45/58'; '45/59'; '45/61'; '45/62'; '45/64'; '45/67'; '45/68'; '45/71'; '45/73'; '45/74'; '45/76'; '45/77'; '45/79'; '45/82'; '45/83'; '45/86'; '45/88'; '45/89'; '45/91'; '45/92'; '45/94'; '45/97'; '45/98'; '46/47'; '46/49'; '46/51'; '46/53'; '46/55'; '46/57'; '46/59'; '46/61'; '46/63'; '46/65'; '46/67'; '46/71'; '46/73'; '46/75'; '46/77'; '46/79'; '46/81'; '46/83'; '46/85'; '46/87'; '46/89'; '46/91'; '46/93'; '46/95'; '46/97'; '46/99'; '47/48'; '47/49'; '47/50'; '47/51'; '47/52'; '47/53'; '47/54'; '47/55'; '47/56'; '47/57'; '47/58'; '47/59'; '47/60'; '47/61'; '47/62'; '47/63'; '47/64'; '47/65'; '47/66'; '47/67'; '47/68'; '47/69'; '47/70'; '47/71'; '47/72'; '47/73'; '47/74'; '47/75'; '47/76'; '47/77'; '47/78'; '47/79'; '47/80'; '47/81'; '47/82'; '47/83'; '47/84'; '47/85'; '47/86'; '47/87'; '47/88'; '47/89'; '47/90'; '47/91'; '47/92'; '47/93'; '47/95'; '47/96'; '47/97'; '47/98'; '47/99'; '47/100'; '48/49'; '48/53'; '48/55'; '48/59'; '48/61'; '48/65'; '48/67'; '48/71'; '48/73'; '48/77'; '48/79'; '48/83'; '48/85'; '48/89'; '48/91'; '48/95'; '48/97'; '49/50'; '49/51'; '49/52'; '49/53'; '49/54'; '49/55'; '49/57'; '49/58'; '49/59'; '49/60'; '49/61'; '49/62'; '49/64'; '49/65'; '49/66'; '49/67'; '49/68'; '49/69'; '49/71'; '49/72'; '49/73'; '49/74'; '49/75'; '49/76'; '49/78'; '49/79'; '49/80'; '49/81'; '49/82'; '49/83'; '49/85'; '49/86'; '49/87'; '49/88'; '49/89'; '49/90'; '49/92'; '49/93'; '49/94'; '49/95'; '49/96'; '49/97'; '49/99'; '49/100'; '50/51'; '50/53'; '50/57'; '50/59'; '50/61'; '50/63'; '50/67'; '50/69'; '50/71'; '50/73'; '50/77'; '50/79'; '50/81'; '50/83'; '50/87'; '50/89'; '50/91'; '50/93'; '50/97'; '50/99'; '51/52'; '51/53'; '51/55'; '51/56'; '51/58'; '51/59'; '51/61'; '51/62'; '51/64'; '51/65'; '51/67'; '51/70'; '51/71'; '51/73'; '51/74'; '51/76'; '51/77'; '51/79'; '51/80'; '51/82'; '51/83'; '51/86'; '51/88'; '51/89'; '51/91'; '51/92'; '51/94'; '51/95'; '51/97'; '51/98'; '51/100'; '52/53'; '52/55'; '52/57'; '52/59'; '52/61'; '52/63'; '52/67'; '52/69'; '52/71'; '52/73'; '52/75'; '52/77'; '52/79'; '52/81'; '52/83'; '52/85'; '52/87'; '52/89'; '52/93'; '52/95'; '52/97'; '52/99'; '53/54'; '53/55'; '53/56'; '53/57'; '53/58'; '53/59'; '53/60'; '53/61'; '53/62'; '53/63'; '53/64'; '53/65'; '53/66'; '53/67'; '53/68'; '53/69'; '53/70'; '53/71'; '53/72'; '53/73'; '53/74'; '53/75'; '53/76'; '53/77'; '53/78'; '53/79'; '53/80'; '53/81'; '53/82'; '53/83'; '53/84'; '53/85'; '53/86'; '53/87'; '53/88'; '53/89'; '53/90'; '53/91'; '53/92'; '53/93'; '53/94'; '53/95'; '53/96'; '53/97'; '53/98'; '53/99'; '53/100'; '54/55'; '54/59'; '54/61'; '54/65'; '54/67'; '54/71'; '54/73'; '54/77'; '54/79'; '54/83'; '54/85'; '54/89'; '54/91'; '54/95'; '54/97'; '55/56'; '55/57'; '55/58'; '55/59'; '55/61'; '55/62'; '55/63'; '55/64'; '55/67'; '55/68'; '55/69'; '55/71'; '55/72'; '55/73'; '55/74'; '55/76'; '55/78'; '55/79'; '55/81'; '55/82'; '55/83'; '55/84'; '55/86'; '55/87'; '55/89'; '55/91'; '55/92'; '55/93'; '55/94'; '55/96'; '55/97'; '55/98'; '56/57'; '56/59'; '56/61'; '56/65'; '56/67'; '56/69'; '56/71'; '56/73'; '56/75'; '56/79'; '56/81'; '56/83'; '56/85'; '56/87'; '56/89'; '56/93'; '56/95'; '56/97'; '56/99'; '57/58'; '57/59'; '57/61'; '57/62'; '57/64'; '57/65'; '57/67'; '57/68'; '57/70'; '57/71'; '57/73'; '57/74'; '57/77'; '57/79'; '57/80'; '57/82'; '57/83'; '57/85'; '57/86'; '57/88'; '57/89'; '57/91'; '57/92'; '57/94'; '57/97'; '57/98'; '57/100'; '58/59'; '58/61'; '58/63'; '58/65'; '58/67'; '58/69'; '58/71'; '58/73'; '58/75'; '58/77'; '58/79'; '58/81'; '58/83'; '58/85'; '58/89'; '58/91'; '58/93'; '58/95'; '58/97'; '58/99'; '59/60'; '59/61'; '59/62'; '59/63'; '59/64'; '59/65'; '59/66'; '59/67'; '59/68'; '59/69'; '59/70'; '59/71'; '59/72'; '59/73'; '59/74'; '59/75'; '59/76'; '59/77'; '59/78'; '59/79'; '59/80'; '59/81'; '59/82'; '59/83'; '59/84'; '59/85'; '59/86'; '59/87'; '59/88'; '59/89'; '59/90'; '59/91'; '59/92'; '59/93'; '59/94'; '59/95'; '59/96'; '59/97'; '59/98'; '59/99'; '59/100'; '60/61'; '60/67'; '60/71'; '60/73'; '60/77'; '60/79'; '60/83'; '60/89'; '60/91'; '60/97'; '61/62'; '61/63'; '61/64'; '61/65'; '61/66'; '61/67'; '61/68'; '61/69'; '61/70'; '61/71'; '61/72'; '61/73'; '61/74'; '61/75'; '61/76'; '61/77'; '61/78'; '61/79'; '61/80'; '61/81'; '61/82'; '61/83'; '61/84'; '61/85'; '61/86'; '61/87'; '61/88'; '61/89'; '61/90'; '61/91'; '61/92'; '61/93'; '61/94'; '61/95'; '61/96'; '61/97'; '61/98'; '61/99'; '61/100'; '62/63'; '62/65'; '62/67'; '62/69'; '62/71'; '62/73'; '62/75'; '62/77'; '62/79'; '62/81'; '62/83'; '62/85'; '62/87'; '62/89'; '62/91'; '62/95'; '62/97'; '62/99'; '63/64'; '63/65'; '63/67'; '63/68'; '63/71'; '63/73'; '63/74'; '63/76'; '63/79'; '63/80'; '63/82'; '63/83'; '63/85'; '63/86'; '63/88'; '63/89'; '63/92'; '63/94'; '63/95'; '63/97'; '63/100'; '64/65'; '64/67'; '64/69'; '64/71'; '64/73'; '64/75'; '64/77'; '64/79'; '64/81'; '64/83'; '64/85'; '64/87'; '64/89'; '64/91'; '64/93'; '64/95'; '64/97'; '64/99'; '65/66'; '65/67'; '65/68'; '65/69'; '65/71'; '65/72'; '65/73'; '65/74'; '65/76'; '65/77'; '65/79'; '65/81'; '65/82'; '65/83'; '65/84'; '65/86'; '65/87'; '65/88'; '65/89'; '65/92'; '65/93'; '65/94'; '65/96'; '65/97'; '65/98'; '65/99'; '66/67'; '66/71'; '66/73'; '66/79'; '66/83'; '66/85'; '66/89'; '66/91'; '66/95'; '66/97'; '67/68'; '67/69'; '67/70'; '67/71'; '67/72'; '67/73'; '67/74'; '67/75'; '67/76'; '67/77'; '67/78'; '67/79'; '67/80'; '67/81'; '67/82'; '67/83'; '67/84'; '67/85'; '67/86'; '67/87'; '67/88'; '67/89'; '67/90'; '67/91'; '67/92'; '67/93'; '67/94'; '67/95'; '67/96'; '67/97'; '67/98'; '67/99'; '67/100'; '68/69'; '68/71'; '68/73'; '68/75'; '68/77'; '68/79'; '68/81'; '68/83'; '68/87'; '68/89'; '68/91'; '68/93'; '68/95'; '68/97'; '68/99'; '69/70'; '69/71'; '69/73'; '69/74'; '69/76'; '69/77'; '69/79'; '69/80'; '69/82'; '69/83'; '69/85'; '69/86'; '69/88'; '69/89'; '69/91'; '69/94'; '69/95'; '69/97'; '69/98'; '69/100'; '70/71'; '70/73'; '70/79'; '70/81'; '70/83'; '70/87'; '70/89'; '70/93'; '70/97'; '70/99'; '71/72'; '71/73'; '71/74'; '71/75'; '71/76'; '71/77'; '71/78'; '71/79'; '71/80'; '71/81'; '71/82'; '71/83'; '71/84'; '71/85'; '71/86'; '71/87'; '71/88'; '71/89'; '71/90'; '71/91'; '71/92'; '71/93'; '71/94'; '71/95'; '71/96'; '71/97'; '71/98'; '71/99'; '71/100'; '72/73'; '72/77'; '72/79'; '72/83'; '72/85'; '72/89'; '72/91'; '72/95'; '72/97'; '73/74'; '73/75'; '73/76'; '73/77'; '73/78'; '73/79'; '73/80'; '73/81'; '73/82'; '73/83'; '73/84'; '73/85'; '73/86'; '73/87'; '73/88'; '73/89'; '73/90'; '73/91'; '73/92'; '73/93'; '73/94'; '73/95'; '73/96'; '73/97'; '73/98'; '73/99'; '73/100'; '74/75'; '74/77'; '74/79'; '74/81'; '74/83'; '74/85'; '74/87'; '74/89'; '74/91'; '74/93'; '74/95'; '74/97'; '74/99'; '75/76'; '75/77'; '75/79'; '75/82'; '75/83'; '75/86'; '75/88'; '75/89'; '75/91'; '75/92'; '75/94'; '75/97'; '75/98'; '76/77'; '76/79'; '76/81'; '76/83'; '76/85'; '76/87'; '76/89'; '76/91'; '76/93'; '76/97'; '76/99'; '77/78'; '77/79'; '77/80'; '77/81'; '77/82'; '77/83'; '77/85'; '77/86'; '77/87'; '77/89'; '77/90'; '77/92'; '77/93'; '77/94'; '77/95'; '77/96'; '77/97'; '77/100'; '78/79'; '78/83'; '78/85'; '78/89'; '78/95'; '78/97'; '79/80'; '79/81'; '79/82'; '79/83'; '79/84'; '79/85'; '79/86'; '79/87'; '79/88'; '79/89'; '79/90'; '79/91'; '79/92'; '79/93'; '79/94'; '79/95'; '79/96'; '79/97'; '79/98'; '79/99'; '79/100'; '80/81'; '80/83'; '80/87'; '80/89'; '80/91'; '80/93'; '80/97'; '80/99'; '81/82'; '81/83'; '81/85'; '81/86'; '81/88'; '81/89'; '81/91'; '81/92'; '81/94'; '81/95'; '81/97'; '81/98'; '81/100'; '82/83'; '82/85'; '82/87'; '82/89'; '82/91'; '82/93'; '82/95'; '82/97'; '82/99'; '83/84'; '83/85'; '83/86'; '83/87'; '83/88'; '83/89'; '83/90'; '83/91'; '83/92'; '83/93'; '83/94'; '83/95'; '83/96'; '83/97'; '83/98'; '83/99'; '83/100'; '84/85'; '84/89'; '84/95'; '84/97'; '85/86'; '85/87'; '85/88'; '85/89'; '85/91'; '85/92'; '85/93'; '85/94'; '85/96'; '85/97'; '85/98'; '85/99'; '86/87'; '86/89'; '86/91'; '86/93'; '86/95'; '86/97'; '86/99'; '87/88'; '87/89'; '87/91'; '87/92'; '87/94'; '87/95'; '87/97'; '87/98'; '87/100'; '88/89'; '88/91'; '88/93'; '88/95'; '88/97'; '89/90'; '89/91'; '89/92'; '89/93'; '89/94'; '89/95'; '89/96'; '89/97'; '89/98'; '89/99'; '89/100'; '90/91'; '90/97'; '91/92'; '91/93'; '91/94'; '91/95'; '91/96'; '91/97'; '91/99'; '91/100'; '92/93'; '92/95'; '92/97'; '92/99'; '93/94'; '93/95'; '93/97'; '93/98'; '93/100'; '94/95'; '94/97'; '94/99'; '95/96'; '95/97'; '95/98'; '95/99'; '96/97'; '97/98'; '97/99'; '97/100'; '98/99'; '99/100']);
  assert (simplified_fractions 50 = ['1/2'; '1/3'; '1/4'; '1/5'; '1/6'; '1/7'; '1/8'; '1/9'; '1/10'; '1/11'; '1/12'; '1/13'; '1/14'; '1/15'; '1/16'; '1/17'; '1/18'; '1/19'; '1/20'; '1/21'; '1/22'; '1/23'; '1/24'; '1/25'; '1/26'; '1/27'; '1/28'; '1/29'; '1/30'; '1/31'; '1/32'; '1/33'; '1/34'; '1/35'; '1/36'; '1/37'; '1/38'; '1/39'; '1/40'; '1/41'; '1/42'; '1/43'; '1/44'; '1/45'; '1/46'; '1/47'; '1/48'; '1/49'; '1/50'; '2/3'; '2/5'; '2/7'; '2/9'; '2/11'; '2/13'; '2/15'; '2/17'; '2/19'; '2/21'; '2/23'; '2/25'; '2/27'; '2/29'; '2/31'; '2/33'; '2/35'; '2/37'; '2/39'; '2/41'; '2/43'; '2/45'; '2/47'; '2/49'; '3/4'; '3/5'; '3/7'; '3/8'; '3/10'; '3/11'; '3/13'; '3/14'; '3/16'; '3/17'; '3/19'; '3/20'; '3/22'; '3/23'; '3/25'; '3/26'; '3/28'; '3/29'; '3/31'; '3/32'; '3/34'; '3/35'; '3/37'; '3/38'; '3/40'; '3/41'; '3/43'; '3/44'; '3/46'; '3/47'; '3/49'; '3/50'; '4/5'; '4/7'; '4/9'; '4/11'; '4/13'; '4/15'; '4/17'; '4/19'; '4/21'; '4/23'; '4/25'; '4/27'; '4/29'; '4/31'; '4/33'; '4/35'; '4/37'; '4/39'; '4/41'; '4/43'; '4/45'; '4/47'; '4/49'; '5/6'; '5/7'; '5/8'; '5/9'; '5/11'; '5/12'; '5/13'; '5/14'; '5/16'; '5/17'; '5/18'; '5/19'; '5/21'; '5/22'; '5/23'; '5/24'; '5/26'; '5/27'; '5/28'; '5/29'; '5/31'; '5/32'; '5/33'; '5/34'; '5/36'; '5/37'; '5/38'; '5/39'; '5/41'; '5/42'; '5/43'; '5/44'; '5/46'; '5/47'; '5/48'; '5/49'; '6/7'; '6/11'; '6/13'; '6/17'; '6/19'; '6/23'; '6/25'; '6/29'; '6/31'; '6/35'; '6/37'; '6/41'; '6/43'; '6/47'; '6/49'; '7/8'; '7/9'; '7/10'; '7/11'; '7/12'; '7/13'; '7/15'; '7/16'; '7/17'; '7/18'; '7/19'; '7/20'; '7/22'; '7/23'; '7/24'; '7/25'; '7/26'; '7/27'; '7/29'; '7/30'; '7/31'; '7/32'; '7/33'; '7/34'; '7/36'; '7/37'; '7/38'; '7/39'; '7/40'; '7/41'; '7/43'; '7/44'; '7/45'; '7/46'; '7/47'; '7/48'; '7/50'; '8/9'; '8/11'; '8/13'; '8/15'; '8/17'; '8/19'; '8/21'; '8/23'; '8/25'; '8/27'; '8/29'; '8/31'; '8/33'; '8/35'; '8/37'; '8/39'; '8/41'; '8/43'; '8/45'; '8/47'; '8/49'; '9/10'; '9/11'; '9/13'; '9/14'; '9/16'; '9/17'; '9/19'; '9/20'; '9/22'; '9/23'; '9/25'; '9/26'; '9/28'; '9/29'; '9/31'; '9/32'; '9/34'; '9/35'; '9/37'; '9/38'; '9/40'; '9/41'; '9/43'; '9/44'; '9/46'; '9/47'; '9/49'; '9/50'; '10/11'; '10/13'; '10/17'; '10/19'; '10/21'; '10/23'; '10/27'; '10/29'; '10/31'; '10/33'; '10/37'; '10/39'; '10/41'; '10/43'; '10/47'; '10/49'; '11/12'; '11/13'; '11/14'; '11/15'; '11/16'; '11/17'; '11/18'; '11/19'; '11/20'; '11/21'; '11/23'; '11/24'; '11/25'; '11/26'; '11/27'; '11/28'; '11/29'; '11/30'; '11/31'; '11/32'; '11/34'; '11/35'; '11/36'; '11/37'; '11/38'; '11/39'; '11/40'; '11/41'; '11/42'; '11/43'; '11/45'; '11/46'; '11/47'; '11/48'; '11/49'; '11/50'; '12/13'; '12/17'; '12/19'; '12/23'; '12/25'; '12/29'; '12/31'; '12/35'; '12/37'; '12/41'; '12/43'; '12/47'; '12/49'; '13/14'; '13/15'; '13/16'; '13/17'; '13/18'; '13/19'; '13/20'; '13/21'; '13/22'; '13/23'; '13/24'; '13/25'; '13/27'; '13/28'; '13/29'; '13/30'; '13/31'; '13/32'; '13/33'; '13/34'; '13/35'; '13/36'; '13/37'; '13/38'; '13/40'; '13/41'; '13/42'; '13/43'; '13/44'; '13/45'; '13/46'; '13/47'; '13/48'; '13/49'; '13/50'; '14/15'; '14/17'; '14/19'; '14/23'; '14/25'; '14/27'; '14/29'; '14/31'; '14/33'; '14/37'; '14/39'; '14/41'; '14/43'; '14/45'; '14/47'; '15/16'; '15/17'; '15/19'; '15/22'; '15/23'; '15/26'; '15/28'; '15/29'; '15/31'; '15/32'; '15/34'; '15/37'; '15/38'; '15/41'; '15/43'; '15/44'; '15/46'; '15/47'; '15/49'; '16/17'; '16/19'; '16/21'; '16/23'; '16/25'; '16/27'; '16/29'; '16/31'; '16/33'; '16/35'; '16/37'; '16/39'; '16/41'; '16/43'; '16/45'; '16/47'; '16/49'; '17/18'; '17/19'; '17/20'; '17/21'; '17/22'; '17/23'; '17/24'; '17/25'; '17/26'; '17/27'; '17/28'; '17/29'; '17/30'; '17/31'; '17/32'; '17/33'; '17/35'; '17/36'; '17/37'; '17/38'; '17/39'; '17/40'; '17/41'; '17/42'; '17/43'; '17/44'; '17/45'; '17/46'; '17/47'; '17/48'; '17/49'; '17/50'; '18/19'; '18/23'; '18/25'; '18/29'; '18/31'; '18/35'; '18/37'; '18/41'; '18/43'; '18/47'; '18/49'; '19/20'; '19/21'; '19/22'; '19/23'; '19/24'; '19/25'; '19/26'; '19/27'; '19/28'; '19/29'; '19/30'; '19/31'; '19/32'; '19/33'; '19/34'; '19/35'; '19/36'; '19/37'; '19/39'; '19/40'; '19/41'; '19/42'; '19/43'; '19/44'; '19/45'; '19/46'; '19/47'; '19/48'; '19/49'; '19/50'; '20/21'; '20/23'; '20/27'; '20/29'; '20/31'; '20/33'; '20/37'; '20/39'; '20/41'; '20/43'; '20/47'; '20/49'; '21/22'; '21/23'; '21/25'; '21/26'; '21/29'; '21/31'; '21/32'; '21/34'; '21/37'; '21/38'; '21/40'; '21/41'; '21/43'; '21/44'; '21/46'; '21/47'; '21/50'; '22/23'; '22/25'; '22/27'; '22/29'; '22/31'; '22/35'; '22/37'; '22/39'; '22/41'; '22/43'; '22/45'; '22/47'; '22/49'; '23/24'; '23/25'; '23/26'; '23/27'; '23/28'; '23/29'; '23/30'; '23/31'; '23/32'; '23/33'; '23/34'; '23/35'; '23/36'; '23/37'; '23/38'; '23/39'; '23/40'; '23/41'; '23/42'; '23/43'; '23/44'; '23/45'; '23/47'; '23/48'; '23/49'; '23/50'; '24/25'; '24/29'; '24/31'; '24/35'; '24/37'; '24/41'; '24/43'; '24/47'; '24/49'; '25/26'; '25/27'; '25/28'; '25/29'; '25/31'; '25/32'; '25/33'; '25/34'; '25/36'; '25/37'; '25/38'; '25/39'; '25/41'; '25/42'; '25/43'; '25/44'; '25/46'; '25/47'; '25/48'; '25/49'; '26/27'; '26/29'; '26/31'; '26/33'; '26/35'; '26/37'; '26/41'; '26/43'; '26/45'; '26/47'; '26/49'; '27/28'; '27/29'; '27/31'; '27/32'; '27/34'; '27/35'; '27/37'; '27/38'; '27/40'; '27/41'; '27/43'; '27/44'; '27/46'; '27/47'; '27/49'; '27/50'; '28/29'; '28/31'; '28/33'; '28/37'; '28/39'; '28/41'; '28/43'; '28/45'; '28/47'; '29/30'; '29/31'; '29/32'; '29/33'; '29/34'; '29/35'; '29/36'; '29/37'; '29/38'; '29/39'; '29/40'; '29/41'; '29/42'; '29/43'; '29/44'; '29/45'; '29/46'; '29/47'; '29/48'; '29/49'; '29/50'; '30/31'; '30/37'; '30/41'; '30/43'; '30/47'; '30/49'; '31/32'; '31/33'; '31/34'; '31/35'; '31/36'; '31/37'; '31/38'; '31/39'; '31/40'; '31/41'; '31/42'; '31/43'; '31/44'; '31/45'; '31/46'; '31/47'; '31/48'; '31/49'; '31/50'; '32/33'; '32/35'; '32/37'; '32/39'; '32/41'; '32/43'; '32/45'; '32/47'; '32/49'; '33/34'; '33/35'; '33/37'; '33/38'; '33/40'; '33/41'; '33/43'; '33/46'; '33/47'; '33/49'; '33/50'; '34/35'; '34/37'; '34/39'; '34/41'; '34/43'; '34/45'; '34/47'; '34/49'; '35/36'; '35/37'; '35/38'; '35/39'; '35/41'; '35/43'; '35/44'; '35/46'; '35/47'; '35/48'; '36/37'; '36/41'; '36/43'; '36/47'; '36/49'; '37/38'; '37/39'; '37/40'; '37/41'; '37/42'; '37/43'; '37/44'; '37/45'; '37/46'; '37/47'; '37/48'; '37/49'; '37/50'; '38/39'; '38/41'; '38/43'; '38/45'; '38/47'; '38/49'; '39/40'; '39/41'; '39/43'; '39/44'; '39/46'; '39/47'; '39/49'; '39/50'; '40/41'; '40/43'; '40/47'; '40/49'; '41/42'; '41/43'; '41/44'; '41/45'; '41/46'; '41/47'; '41/48'; '41/49'; '41/50'; '42/43'; '42/47'; '43/44'; '43/45'; '43/46'; '43/47'; '43/48'; '43/49'; '43/50'; '44/45'; '44/47'; '44/49'; '45/46'; '45/47'; '45/49'; '46/47'; '46/49'; '47/48'; '47/49'; '47/50'; '48/49'; '49/50']);
  assert (simplified_fractions 10 = ['1/2'; '1/3'; '1/4'; '1/5'; '1/6'; '1/7'; '1/8'; '1/9'; '1/10'; '2/3'; '2/5'; '2/7'; '2/9'; '3/4'; '3/5'; '3/7'; '3/8'; '3/10'; '4/5'; '4/7'; '4/9'; '5/6'; '5/7'; '5/8'; '5/9'; '6/7'; '7/8'; '7/9'; '7/10'; '8/9'; '9/10']);
;;","medium","medium_124","medium"
"(**There is a tournament where n players are participating. The players are standing in a single row...
 * >>> earliest_and_latest 10 4 9
 * [2; 4]
 * >>> earliest_and_latest 28 5 24
 * [1; 1]
 * >>> earliest_and_latest 16 5 12
 * [1; 1]
*)
let earliest_and_latest (n : int) (firstPlayer : int) (secondPlayer : int) : int list =","  []","let () =
  assert (earliest_and_latest 10 4 9 = [2; 4]);
  assert (earliest_and_latest 28 5 24 = [1; 1]);
  assert (earliest_and_latest 16 5 12 = [1; 1]);
  assert (earliest_and_latest 5 1 5 = [1; 1]);
  assert (earliest_and_latest 28 10 20 = [2; 5]);
  assert (earliest_and_latest 8 2 7 = [1; 1]);
  assert (earliest_and_latest 28 3 26 = [1; 1]);
;;","hard","hard_075","hard"
"(**You are given an integer array power where power[i] is the power of the ith monster.
 * >>> minimum_time [17]
 * 17
 * >>> minimum_time [2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2]
 * 17
 * >>> minimum_time [1000000000; 1; 1000000000; 1; 1000000000; 1; 1000000000; 1; 1000000000; 1; 1000000000; 1; 1000000000; 1; 1000000000; 1; 1000000000]
 * 721695391
*)
let minimum_time (power : int list) : int =","  0","let () =
  assert (minimum_time [17] = 17);
  assert (minimum_time [2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2] = 17);
  assert (minimum_time [1000000000; 1; 1000000000; 1; 1000000000; 1; 1000000000; 1; 1000000000; 1; 1000000000; 1; 1000000000; 1; 1000000000; 1; 1000000000] = 721695391);
  assert (minimum_time [10; 20; 30] = 30);
  assert (minimum_time [1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1] = 17);
  assert (minimum_time [1; 1; 4] = 4);
  assert (minimum_time [2; 4; 8; 16; 32; 64; 128] = 48);
;;","hard","hard_058","hard"
"(**You are given an array representing a row of seats where seats[i] = 1 represents a person sitting...
 * >>> max_dist_to_closest [0; 0; 0; 1; 0; 1; 0; 0; 0]
 * 3
 * >>> max_dist_to_closest [0; 0; 1; 0; 0; 0; 0; 1]
 * 2
 * >>> max_dist_to_closest [0; 0; 0; 1; 0; 0; 0]
 * 3
*)
let max_dist_to_closest (seats : int list) : int =","  0","let () =
  assert (max_dist_to_closest [0; 0; 0; 1; 0; 1; 0; 0; 0] = 3);
  assert (max_dist_to_closest [0; 0; 1; 0; 0; 0; 0; 1] = 2);
  assert (max_dist_to_closest [0; 0; 0; 1; 0; 0; 0] = 3);
  assert (max_dist_to_closest [1; 0; 0; 0] = 3);
  assert (max_dist_to_closest [0; 1] = 1);
  assert (max_dist_to_closest [1; 0; 0; 0; 0; 0; 1] = 3);
  assert (max_dist_to_closest [0; 0; 1; 0; 0; 0; 0; 1; 0; 0] = 2);
;;","medium","medium_033","medium"
"(**You are given an array nums of non-negative integers and an integer k.
 * >>> minimum_subarray_length [0; 0; 0] 1
 * -1
 * >>> minimum_subarray_length [5; 5; 5; 5] 5
 * 1
 * >>> minimum_subarray_length [1; 2] 0
 * 1
*)
let minimum_subarray_length (nums : int list) (k : int) : int =","  0","let () =
  assert (minimum_subarray_length [0; 0; 0] 1 = -1);
  assert (minimum_subarray_length [5; 5; 5; 5] 5 = 1);
  assert (minimum_subarray_length [1; 2] 0 = 1);
  assert (minimum_subarray_length [4; 5; 6; 7] 12 = -1);
  assert (minimum_subarray_length [1; 2; 3] 2 = 1);
  assert (minimum_subarray_length [30; 1; 4; 3; 2; 5] 6 = 1);
  assert (minimum_subarray_length [7; 14; 21; 28; 35] 21 = 1);
;;","easy","easy_109","easy"
"(**The letter value of a letter is its position in the alphabet starting from 0 (i.e. 'a' -> 0, 'b' ...
 * >>> is_sum_equal ""ij"" ""ji"" ""ii""
 * false
 * >>> is_sum_equal ""fgh"" ""ghf"" ""ggg""
 * false
 * >>> is_sum_equal ""ij"" ""ji"" ""jjj""
 * false
*)
let is_sum_equal (firstWord : string) (secondWord : string) (targetWord : string) : bool =","  false","let () =
  assert (is_sum_equal ""ij"" ""ji"" ""ii"" = false);
  assert (is_sum_equal ""fgh"" ""ghf"" ""ggg"" = false);
  assert (is_sum_equal ""ij"" ""ji"" ""jjj"" = false);
  assert (is_sum_equal ""b"" ""c"" ""d"" = true);
  assert (is_sum_equal ""abcdefghij"" ""abcdefghij"" ""aaaaaaaaaa"" = false);
  assert (is_sum_equal ""i"" ""j"" ""ji"" = false);
  assert (is_sum_equal ""ab"" ""ba"" ""bb"" = true);
;;","easy","easy_168","easy"
"(**You are given n points in the plane that are all distinct, where points[i] = [xi, yi]. A boomeran...
 * >>> number_of_boomerangs [[0; 0]; [1; 0]; [2; 0]; [3; 0]; [4; 0]]
 * 8
 * >>> number_of_boomerangs [[1; 0]; [0; 0]; [0; 1]]
 * 2
 * >>> number_of_boomerangs [[1; 2]; [2; 3]; [3; 4]; [4; 5]]
 * 4
*)
let number_of_boomerangs (points : int list list) : int =","  0","let () =
  assert (number_of_boomerangs [[0; 0]; [1; 0]; [2; 0]; [3; 0]; [4; 0]] = 8);
  assert (number_of_boomerangs [[1; 0]; [0; 0]; [0; 1]] = 2);
  assert (number_of_boomerangs [[1; 2]; [2; 3]; [3; 4]; [4; 5]] = 4);
  assert (number_of_boomerangs [[0; 0]; [1; 0]; [0; 1]; [0; 2]] = 4);
  assert (number_of_boomerangs [[0; 0]; [1; 0]; [2; 0]] = 2);
  assert (number_of_boomerangs [[0; 0]; [1; 0]; [-1; 0]; [0; 1]; [0; -1]] = 20);
  assert (number_of_boomerangs [[1; 1]; [1; 2]; [1; 3]; [1; 4]] = 4);
;;","medium","medium_163","medium"
"(**You are given a 0-indexed integer array nums. Rearrange the values of nums according to the follo...
 * >>> sort_even_odd [1]
 * [1]
 * >>> sort_even_odd [100; 99; 98; 97; 96; 95]
 * [96; 99; 98; 97; 100; 95]
 * >>> sort_even_odd [1; 3; 2; 2; 3; 1]
 * [1; 3; 2; 2; 3; 1]
*)
let sort_even_odd (nums : int list) : int list =","  []","let () =
  assert (sort_even_odd [1] = [1]);
  assert (sort_even_odd [100; 99; 98; 97; 96; 95] = [96; 99; 98; 97; 100; 95]);
  assert (sort_even_odd [1; 3; 2; 2; 3; 1] = [1; 3; 2; 2; 3; 1]);
  assert (sort_even_odd [1; 9; 3; 7; 5; 6; 2; 8; 4] = [1; 9; 2; 8; 3; 7; 4; 6; 5]);
  assert (sort_even_odd [5; 3; 2; 4; 1; 6] = [1; 6; 2; 4; 5; 3]);
  assert (sort_even_odd [10; 20; 30; 40; 50; 60; 70] = [10; 60; 30; 40; 50; 20; 70]);
  assert (sort_even_odd [1; 9; 2; 8; 3; 7; 4; 6; 5] = [1; 9; 2; 8; 3; 7; 4; 6; 5]);
;;","easy","easy_134","easy"
"(**Given an integer n, your task is to count how many strings of length n can be formed under the fo...
 * >>> count_vowel_permutation 1000
 * 89945857
 * >>> count_vowel_permutation 100
 * 173981881
 * >>> count_vowel_permutation 20000
 * 759959057
*)
let count_vowel_permutation (n : int) : int =","  0","let () =
  assert (count_vowel_permutation 1000 = 89945857);
  assert (count_vowel_permutation 100 = 173981881);
  assert (count_vowel_permutation 20000 = 759959057);
  assert (count_vowel_permutation 200 = 670333618);
  assert (count_vowel_permutation 10000 = 76428576);
  assert (count_vowel_permutation 5000 = 598627501);
  assert (count_vowel_permutation 2000 = 793084836);
;;","hard","hard_033","hard"
"(**You are given a string s and an integer k. Encrypt the string using the following algorithm:
 * >>> get_encrypted_string ""hello"" 10
 * hello
 * >>> get_encrypted_string ""abc"" 2
 * cab
 * >>> get_encrypted_string ""hello"" 7
 * llohe
*)
let get_encrypted_string (s : string) (k : int) : string =","  """"","let () =
  assert (get_encrypted_string ""hello"" 10 = hello);
  assert (get_encrypted_string ""abc"" 2 = cab);
  assert (get_encrypted_string ""hello"" 7 = llohe);
  assert (get_encrypted_string ""abcdef"" 2 = cdefab);
  assert (get_encrypted_string ""world"" 5 = world);
  assert (get_encrypted_string ""dart"" 3 = tdar);
  assert (get_encrypted_string ""aaa"" 1 = aaa);
;;","easy","easy_094","easy"
"(**A perfectly straight street is represented by a number line. The street has street lamp(s) on it ...
 * >>> brightest_position [[-1; 1]; [-2; 2]; [-3; 3]]
 * -2
 * >>> brightest_position [[-5; 4]; [-2; 3]; [0; 2]; [2; 1]]
 * -2
 * >>> brightest_position [[100000000; 50000000]; [50000000; 25000000]; [-50000000; 30000000]]
 * 50000000
*)
let brightest_position (lights : int list list) : int =","  0","let () =
  assert (brightest_position [[-1; 1]; [-2; 2]; [-3; 3]] = -2);
  assert (brightest_position [[-5; 4]; [-2; 3]; [0; 2]; [2; 1]] = -2);
  assert (brightest_position [[100000000; 50000000]; [50000000; 25000000]; [-50000000; 30000000]] = 50000000);
  assert (brightest_position [[5; 3]; [10; 2]; [15; 1]] = 8);
  assert (brightest_position [[-5; 3]; [5; 3]; [0; 1]; [2; 2]] = 0);
  assert (brightest_position [[-5; 10]; [5; 10]; [15; 10]] = 5);
  assert (brightest_position [[0; 10]; [1; 9]; [2; 8]; [3; 7]; [4; 6]; [5; 5]; [6; 4]; [7; 3]; [8; 2]; [9; 1]] = 8);
;;","medium","medium_037","medium"
"(**An array is monotonic if it is either monotone increasing or monotone decreasing.
 * >>> is_monotonic [1; 2; 2; 3]
 * true
 * >>> is_monotonic [1; 2; 4; 5]
 * true
 * >>> is_monotonic [-1; -2; -2; -3]
 * true
*)
let is_monotonic (nums : int list) : bool =","  false","let () =
  assert (is_monotonic [1; 2; 2; 3] = true);
  assert (is_monotonic [1; 2; 4; 5] = true);
  assert (is_monotonic [-1; -2; -2; -3] = true);
  assert (is_monotonic [1; 1; 1; 1] = true);
  assert (is_monotonic [1; 1; 1] = true);
  assert (is_monotonic [10; -10; -20; -30] = true);
  assert (is_monotonic [-100; 0; 100] = true);
;;","easy","easy_070","easy"
"(**You are given two positive integers startPos and endPos. Initially, you are standing at position ...
 * >>> number_of_ways 1 2 3
 * 3
 * >>> number_of_ways 5 5 0
 * 1
 * >>> number_of_ways 0 0 2
 * 2
*)
let number_of_ways (startPos : int) (endPos : int) (k : int) : int =","  0","let () =
  assert (number_of_ways 1 2 3 = 3);
  assert (number_of_ways 5 5 0 = 1);
  assert (number_of_ways 0 0 2 = 2);
  assert (number_of_ways 10 1 15 = 455);
  assert (number_of_ways 5 5 10 = 252);
  assert (number_of_ways 10 1 9 = 1);
  assert (number_of_ways 0 0 0 = 1);
;;","medium","medium_020","medium"
"(**You are given an m x n matrix of characters boxGrid representing a side-view of a box. Each cell ...
 * >>> rotate_the_box [[""#""; "".""; ""*""; "".""]; [""#""; ""#""; ""*""; "".""]]
 * [['#'; '.']; ['#'; '#']; ['*'; '*']; ['.'; '.']]
 * >>> rotate_the_box [[""#""; "".""; ""#""]]
 * [['.']; ['#']; ['#']]
 * >>> rotate_the_box [[""#""; ""#""; ""*""; "".""; ""*""; "".""]; [""#""; ""#""; ""#""; ""*""; "".""; "".""]; [""#""; ""#""; ""#""; "".""; ""#""; "".""]]
 * [['.'; '#'; '#']; ['.'; '#'; '#']; ['#'; '#'; '*']; ['#'; '*'; '.']; ['#'; '.'; '*']; ['#'; '.'; '.']]
*)
let rotate_the_box (boxGrid : string list list) : string list list =","  [[]]","let () =
  assert (rotate_the_box [[""#""; "".""; ""*""; "".""]; [""#""; ""#""; ""*""; "".""]] = [['#'; '.']; ['#'; '#']; ['*'; '*']; ['.'; '.']]);
  assert (rotate_the_box [[""#""; "".""; ""#""]] = [['.']; ['#']; ['#']]);
  assert (rotate_the_box [[""#""; ""#""; ""*""; "".""; ""*""; "".""]; [""#""; ""#""; ""#""; ""*""; "".""; "".""]; [""#""; ""#""; ""#""; "".""; ""#""; "".""]] = [['.'; '#'; '#']; ['.'; '#'; '#']; ['#'; '#'; '*']; ['#'; '*'; '.']; ['#'; '.'; '*']; ['#'; '.'; '.']]);
  assert (rotate_the_box [[""*""; "".""; "".""; "".""; ""#""; "".""; ""*""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; [""#""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]] = [['.'; '.'; '.'; '.'; '*']; ['.'; '.'; '.'; '.'; '.']; ['.'; '.'; '.'; '.'; '.']; ['.'; '.'; '.'; '.'; '.']; ['.'; '.'; '.'; '.'; '.']; ['.'; '.'; '.'; '.'; '#']; ['.'; '.'; '.'; '.'; '*']; ['#'; '.'; '.'; '.'; '.']]);
  assert (rotate_the_box [["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; ""#""; "".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; ""#""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; ""*""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; ""#""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]] = [['.'; '.'; '.'; '.'; '.'; '.'; '.']; ['.'; '.'; '.'; '.'; '.'; '.'; '.']; ['.'; '.'; '.'; '.'; '.'; '.'; '.']; ['.'; '.'; '.'; '.'; '.'; '.'; '.']; ['.'; '.'; '.'; '*'; '.'; '.'; '.']; ['.'; '.'; '.'; '.'; '.'; '.'; '.']; ['.'; '.'; '.'; '.'; '.'; '.'; '.']; ['.'; '.'; '.'; '.'; '.'; '.'; '.']; ['.'; '.'; '.'; '.'; '.'; '.'; '.']; ['.'; '.'; '#'; '.'; '#'; '#'; '.']]);
  assert (rotate_the_box [[""#""; "".""; "".""; ""#""; ""*""; "".""]; ["".""; ""#""; "".""; "".""; ""#""; "".""]; ["".""; "".""; ""#""; "".""; "".""; "".""]] = [['.'; '.'; '.']; ['.'; '.'; '.']; ['.'; '.'; '#']; ['.'; '.'; '#']; ['.'; '#'; '*']; ['#'; '#'; '.']]);
  assert (rotate_the_box [[""#""; "".""; "".""; "".""; ""#""; "".""]; [""*""; "".""; ""#""; "".""; "".""; ""#""]; [""#""; "".""; ""*""; "".""; ""#""; "".""]; ["".""; ""#""; ""#""; ""*""; "".""; "".""]] = [['.'; '.'; '*'; '.']; ['#'; '#'; '.'; '.']; ['#'; '*'; '.'; '.']; ['*'; '.'; '.'; '.']; ['.'; '.'; '#'; '#']; ['.'; '#'; '#'; '#']]);
;;","medium","medium_130","medium"
"(**Given an integer array nums, return true if any value appears at least twice in the array, and re...
 * >>> contains_duplicate [1]
 * false
 * >>> contains_duplicate [1; 2; 3; 1]
 * true
 * >>> contains_duplicate [1; 1; 1; 3; 3; 4; 3; 2; 4; 2]
 * true
*)
let contains_duplicate (nums : int list) : bool =","  false","let () =
  assert (contains_duplicate [1] = false);
  assert (contains_duplicate [1; 2; 3; 1] = true);
  assert (contains_duplicate [1; 1; 1; 3; 3; 4; 3; 2; 4; 2] = true);
  assert (contains_duplicate [0; 0; 0; 0; 0; 0; 0; 0; 0; 0] = true);
  assert (contains_duplicate [1; 2; 3; 4] = false);
  assert (contains_duplicate [1; 2] = false);
  assert (contains_duplicate [5; 7; 8; 9; 5] = true);
;;","easy","easy_043","easy"
"(**Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according ...
 * >>> is_valid_sudoku [[""8""; ""3""; "".""; "".""; ""7""; "".""; "".""; "".""; "".""]; [""6""; "".""; "".""; ""1""; ""9""; ""5""; "".""; "".""; "".""]; ["".""; ""9""; ""8""; "".""; "".""; "".""; "".""; ""6""; "".""]; [""8""; "".""; "".""; "".""; ""6""; "".""; "".""; "".""; ""3""]; [""4""; "".""; "".""; ""8""; "".""; ""3""; "".""; "".""; ""1""]; [""7""; "".""; "".""; "".""; ""2""; "".""; "".""; "".""; ""6""]; ["".""; ""6""; "".""; "".""; "".""; "".""; ""2""; ""8""; "".""]; ["".""; "".""; "".""; ""4""; ""1""; ""9""; "".""; "".""; ""5""]; ["".""; "".""; "".""; "".""; ""8""; "".""; "".""; ""7""; ""9""]]
 * false
 * >>> is_valid_sudoku [[""5""; ""3""; "".""; "".""; ""7""; "".""; "".""; "".""; "".""]; [""6""; "".""; "".""; ""1""; ""9""; ""5""; "".""; "".""; "".""]; ["".""; ""9""; ""8""; "".""; "".""; "".""; "".""; ""6""; "".""]; [""8""; "".""; "".""; "".""; ""6""; "".""; "".""; "".""; ""3""]; [""4""; "".""; "".""; ""8""; "".""; ""3""; "".""; "".""; ""1""]; [""7""; "".""; "".""; "".""; ""2""; "".""; "".""; "".""; ""6""]; ["".""; ""6""; "".""; "".""; "".""; "".""; ""2""; ""8""; "".""]; ["".""; "".""; "".""; ""4""; ""1""; ""9""; "".""; "".""; ""5""]; ["".""; "".""; "".""; "".""; ""8""; "".""; "".""; ""7""; ""9""]]
 * true
 * >>> is_valid_sudoku [["".""; "".""; "".""; "".""; "".""; "".""; ""5""; ""1""; ""9""]; ["".""; ""9""; "".""; "".""; ""5""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; ""2""; "".""; ""4""; "".""; "".""; "".""]; [""4""; "".""; "".""; "".""; "".""; "".""; ""1""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; ""7""; "".""; ""3""]; ["".""; "".""; ""2""; "".""; "".""; "".""; "".""; "".""; ""6""]; ["".""; ""6""; "".""; "".""; "".""; "".""; "".""; ""8""; "".""]; ["".""; "".""; "".""; ""4""; ""1""; ""9""; "".""; "".""; ""5""]; ["".""; "".""; "".""; "".""; ""8""; "".""; "".""; ""7""; ""9""]]
 * false
*)
let is_valid_sudoku (board : string list list) : bool =","  false","let () =
  assert (is_valid_sudoku [[""8""; ""3""; "".""; "".""; ""7""; "".""; "".""; "".""; "".""]; [""6""; "".""; "".""; ""1""; ""9""; ""5""; "".""; "".""; "".""]; ["".""; ""9""; ""8""; "".""; "".""; "".""; "".""; ""6""; "".""]; [""8""; "".""; "".""; "".""; ""6""; "".""; "".""; "".""; ""3""]; [""4""; "".""; "".""; ""8""; "".""; ""3""; "".""; "".""; ""1""]; [""7""; "".""; "".""; "".""; ""2""; "".""; "".""; "".""; ""6""]; ["".""; ""6""; "".""; "".""; "".""; "".""; ""2""; ""8""; "".""]; ["".""; "".""; "".""; ""4""; ""1""; ""9""; "".""; "".""; ""5""]; ["".""; "".""; "".""; "".""; ""8""; "".""; "".""; ""7""; ""9""]] = false);
  assert (is_valid_sudoku [[""5""; ""3""; "".""; "".""; ""7""; "".""; "".""; "".""; "".""]; [""6""; "".""; "".""; ""1""; ""9""; ""5""; "".""; "".""; "".""]; ["".""; ""9""; ""8""; "".""; "".""; "".""; "".""; ""6""; "".""]; [""8""; "".""; "".""; "".""; ""6""; "".""; "".""; "".""; ""3""]; [""4""; "".""; "".""; ""8""; "".""; ""3""; "".""; "".""; ""1""]; [""7""; "".""; "".""; "".""; ""2""; "".""; "".""; "".""; ""6""]; ["".""; ""6""; "".""; "".""; "".""; "".""; ""2""; ""8""; "".""]; ["".""; "".""; "".""; ""4""; ""1""; ""9""; "".""; "".""; ""5""]; ["".""; "".""; "".""; "".""; ""8""; "".""; "".""; ""7""; ""9""]] = true);
  assert (is_valid_sudoku [["".""; "".""; "".""; "".""; "".""; "".""; ""5""; ""1""; ""9""]; ["".""; ""9""; "".""; "".""; ""5""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; ""2""; "".""; ""4""; "".""; "".""; "".""]; [""4""; "".""; "".""; "".""; "".""; "".""; ""1""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; "".""; ""7""; "".""; ""3""]; ["".""; "".""; ""2""; "".""; "".""; "".""; "".""; "".""; ""6""]; ["".""; ""6""; "".""; "".""; "".""; "".""; "".""; ""8""; "".""]; ["".""; "".""; "".""; ""4""; ""1""; ""9""; "".""; "".""; ""5""]; ["".""; "".""; "".""; "".""; ""8""; "".""; "".""; ""7""; ""9""]] = false);
  assert (is_valid_sudoku [[""5""; ""3""; "".""; "".""; ""7""; "".""; "".""; "".""; "".""]; [""6""; "".""; "".""; ""1""; ""9""; ""5""; "".""; "".""; "".""]; ["".""; ""9""; ""8""; "".""; "".""; "".""; "".""; ""6""; "".""]; [""8""; "".""; "".""; "".""; ""6""; "".""; "".""; "".""; ""3""]; [""4""; "".""; "".""; ""8""; "".""; ""3""; "".""; "".""; ""1""]; [""7""; "".""; "".""; "".""; ""2""; "".""; "".""; "".""; ""6""]; ["".""; ""6""; "".""; ""5""; "".""; "".""; ""2""; ""8""; "".""]; ["".""; "".""; "".""; ""4""; ""1""; ""9""; "".""; "".""; ""5""]; ["".""; "".""; "".""; "".""; ""8""; "".""; "".""; ""7""; ""9""]] = true);
  assert (is_valid_sudoku [[""1""; "".""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; ""2""; "".""; "".""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; ""3""; "".""; "".""; "".""; "".""; "".""; "".""]; [""4""; "".""; "".""; ""5""; "".""; "".""; "".""; "".""; "".""]; ["".""; ""5""; "".""; "".""; ""6""; "".""; "".""; "".""; "".""]; ["".""; "".""; ""6""; "".""; "".""; ""7""; "".""; "".""; "".""]; [""7""; "".""; "".""; "".""; "".""; "".""; ""8""; "".""; "".""]; ["".""; ""8""; "".""; "".""; "".""; "".""; "".""; ""9""; "".""]; ["".""; "".""; ""9""; "".""; "".""; "".""; "".""; "".""; ""1""]] = true);
  assert (is_valid_sudoku [["".""; "".""; "".""; "".""; ""5""; "".""; "".""; ""1""; "".""]; ["".""; ""4""; "".""; ""3""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; "".""; "".""; "".""; ""3""; "".""; "".""; ""1""]; [""8""; "".""; "".""; "".""; "".""; "".""; "".""; ""2""; "".""]; ["".""; "".""; ""2""; "".""; ""7""; "".""; ""4""; "".""; "".""]; ["".""; ""1""; "".""; "".""; "".""; "".""; "".""; "".""; ""8""]; [""9""; "".""; "".""; ""1""; "".""; "".""; "".""; "".""; "".""]; ["".""; "".""; ""8""; "".""; "".""; ""8""; "".""; ""7""; "".""]; ["".""; ""5""; "".""; "".""; ""9""; "".""; "".""; "".""; "".""]] = false);
  assert (is_valid_sudoku [[""1""; ""2""; ""3""; ""4""; ""5""; ""6""; ""7""; ""8""; ""9""]; [""4""; ""5""; ""6""; ""7""; ""8""; ""9""; ""1""; ""2""; ""3""]; [""7""; ""8""; ""9""; ""1""; ""2""; ""3""; ""4""; ""5""; ""6""]; [""2""; ""3""; ""4""; ""5""; ""6""; ""7""; ""8""; ""9""; ""1""]; [""5""; ""6""; ""7""; ""8""; ""9""; ""1""; ""2""; ""3""; ""4""]; [""8""; ""9""; ""1""; ""2""; ""3""; ""4""; ""5""; ""6""; ""7""]; [""3""; ""4""; ""5""; ""6""; ""7""; ""8""; ""9""; ""1""; ""2""]; [""6""; ""7""; ""8""; ""9""; ""1""; ""2""; ""3""; ""4""; ""5""]; [""9""; ""1""; ""2""; ""3""; ""4""; ""5""; ""6""; ""7""; ""8""]] = true);
;;","medium","medium_137","medium"
"(**Given two integers n and k, return an array of all the integers of length n where the difference ...
 * >>> nums_same_consec_diff 3 0
 * [111; 222; 333; 444; 555; 666; 777; 888; 999]
 * >>> nums_same_consec_diff 9 5
 * [161616161; 272727272; 383838383; 494949494; 505050505; 616161616; 727272727; 838383838; 949494949]
 * >>> nums_same_consec_diff 2 1
 * [12; 10; 23; 21; 34; 32; 45; 43; 56; 54; 67; 65; 78; 76; 89; 87; 98]
*)
let nums_same_consec_diff (n : int) (k : int) : int list =","  []","let () =
  assert (nums_same_consec_diff 3 0 = [111; 222; 333; 444; 555; 666; 777; 888; 999]);
  assert (nums_same_consec_diff 9 5 = [161616161; 272727272; 383838383; 494949494; 505050505; 616161616; 727272727; 838383838; 949494949]);
  assert (nums_same_consec_diff 2 1 = [12; 10; 23; 21; 34; 32; 45; 43; 56; 54; 67; 65; 78; 76; 89; 87; 98]);
  assert (nums_same_consec_diff 9 9 = [909090909]);
  assert (nums_same_consec_diff 2 9 = [90]);
  assert (nums_same_consec_diff 5 5 = [16161; 27272; 38383; 49494; 50505; 61616; 72727; 83838; 94949]);
  assert (nums_same_consec_diff 3 2 = [135; 131; 246; 242; 202; 357; 353; 313; 468; 464; 424; 420; 579; 575; 535; 531; 686; 646; 642; 797; 757; 753; 868; 864; 979; 975]);
;;","medium","medium_089","medium"
"(**You are given two images, img1 and img2, represented as binary, square matrices of size n x n. A ...
 * >>> largest_overlap [[1; 1; 0]; [0; 1; 0]; [0; 1; 0]] [[0; 0; 0]; [0; 1; 1]; [0; 0; 1]]
 * 3
 * >>> largest_overlap [[1; 0]; [0; 1]] [[1; 1]; [1; 1]]
 * 2
 * >>> largest_overlap [[1; 1; 1]; [1; 1; 1]; [1; 1; 1]] [[0; 1; 0]; [1; 1; 1]; [0; 1; 0]]
 * 5
*)
let largest_overlap (img1 : int list list) (img2 : int list list) : int =","  0","let () =
  assert (largest_overlap [[1; 1; 0]; [0; 1; 0]; [0; 1; 0]] [[0; 0; 0]; [0; 1; 1]; [0; 0; 1]] = 3);
  assert (largest_overlap [[1; 0]; [0; 1]] [[1; 1]; [1; 1]] = 2);
  assert (largest_overlap [[1; 1; 1]; [1; 1; 1]; [1; 1; 1]] [[0; 1; 0]; [1; 1; 1]; [0; 1; 0]] = 5);
  assert (largest_overlap [[1; 1; 1]; [1; 1; 1]; [1; 1; 1]] [[0; 0; 0]; [0; 0; 0]; [0; 0; 0]] = 0);
  assert (largest_overlap [[1]] [[1]] = 1);
  assert (largest_overlap [[1; 1; 1]; [1; 1; 1]; [1; 1; 1]] [[1; 1; 1]; [1; 1; 1]; [1; 1; 1]] = 9);
  assert (largest_overlap [[1; 1]; [1; 1]] [[0; 0]; [0; 0]] = 0);
;;","medium","medium_104","medium"
"(**Given a string s, return the lexicographically smallest subsequence of s that contains all the di...
 * >>> smallest_subsequence ""rakuqjeiaxeidqqeaeiaxqeaeiaxjeidqq""
 * rakudeiqxj
 * >>> smallest_subsequence ""a""
 * a
 * >>> smallest_subsequence ""cccaae""
 * cae
*)
let smallest_subsequence (s : string) : string =","  """"","let () =
  assert (smallest_subsequence ""rakuqjeiaxeidqqeaeiaxqeaeiaxjeidqq"" = rakudeiqxj);
  assert (smallest_subsequence ""a"" = a);
  assert (smallest_subsequence ""cccaae"" = cae);
  assert (smallest_subsequence ""cbacdcbc"" = acdb);
  assert (smallest_subsequence ""abacabadabc"" = abcd);
  assert (smallest_subsequence ""thesqskillqy"" = theqskily);
  assert (smallest_subsequence ""leetcode"" = letcod);
;;","medium","medium_002","medium"
"(**You are given a license key represented as a string s that consists of only alphanumeric characte...
 * >>> license_key_formatting ""AB-CD-EF-GH-IJ"" 2
 * AB-CD-EF-GH-IJ
 * >>> license_key_formatting ""abcdefg-hijkl-mnopqr-stuv-wxyz"" 5
 * A-BCDEF-GHIJK-LMNOP-QRSTU-VWXYZ
 * >>> license_key_formatting """" 1
 * 
*)
let license_key_formatting (s : string) (k : int) : string =","  """"","let () =
  assert (license_key_formatting ""AB-CD-EF-GH-IJ"" 2 = AB-CD-EF-GH-IJ);
  assert (license_key_formatting ""abcdefg-hijkl-mnopqr-stuv-wxyz"" 5 = A-BCDEF-GHIJK-LMNOP-QRSTU-VWXYZ);
  assert (license_key_formatting ""1234567890"" 3 = 1-234-567-890);
  assert (license_key_formatting ""2-4A0r7-4k"" 3 = 24-A0R-74K);
  assert (license_key_formatting ""2-5g-3-J"" 2 = 2-5G-3J);
;;","easy","easy_014","easy"
"(**Given two integer arrays nums1 and nums2 of length n, count the pairs of indices (i, j) such that...
 * >>> count_pairs [100000; 100000; 100000] [1; 1; 1]
 * 3
 * >>> count_pairs [100000; 1; 1; 1] [1; 100000; 100000; 100000]
 * 0
 * >>> count_pairs [5; 5; 5; 5] [1; 1; 1; 1]
 * 6
*)
let count_pairs (nums1 : int list) (nums2 : int list) : int =","  0","let () =
  assert (count_pairs [100000; 100000; 100000] [1; 1; 1] = 3);
  assert (count_pairs [100000; 1; 1; 1] [1; 100000; 100000; 100000] = 0);
  assert (count_pairs [5; 5; 5; 5] [1; 1; 1; 1] = 6);
  assert (count_pairs [100000; 100000; 100000] [1; 1; 1] = 3);
  assert (count_pairs [1; 10; 6; 2] [1; 4; 1; 5] = 5);
  assert (count_pairs [1; 2; 3; 4; 5] [5; 4; 3; 2; 1] = 4);
  assert (count_pairs [2; 1; 2; 1] [1; 2; 1; 2] = 1);
;;","medium","medium_074","medium"
"(**You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening...
 * >>> min_swaps ""[]][[]""
 * 1
 * >>> min_swaps ""[[[[]]]]""
 * 0
 * >>> min_swaps ""]][[[]]]""
 * 0
*)
let min_swaps (s : string) : int =","  0","let () =
  assert (min_swaps ""[]][[]"" = 1);
  assert (min_swaps ""[[[[]]]]"" = 0);
  assert (min_swaps ""]][[[]]]"" = 0);
  assert (min_swaps ""][]["" = 1);
  assert (min_swaps ""]]][[][["" = 2);
  assert (min_swaps ""]]]][[[["" = 2);
  assert (min_swaps ""][[]]["" = 1);
;;","medium","medium_119","medium"
"(**An experiment is being conducted in a lab. To ensure accuracy, there are two sensors collecting d...
 * >>> bad_sensor [1; 2; 3; 4; 5] [1; 2; 4; 5; 6]
 * 2
 * >>> bad_sensor [3; 4; 5; 6] [4; 5; 6; 3]
 * 2
 * >>> bad_sensor [1; 2; 3; 4; 5] [1; 2; 3; 4; 5]
 * -1
*)
let bad_sensor (sensor1 : int list) (sensor2 : int list) : int =","  0","let () =
  assert (bad_sensor [1; 2; 3; 4; 5] [1; 2; 4; 5; 6] = 2);
  assert (bad_sensor [3; 4; 5; 6] [4; 5; 6; 3] = 2);
  assert (bad_sensor [1; 2; 3; 4; 5] [1; 2; 3; 4; 5] = -1);
  assert (bad_sensor [10; 20; 30; 40] [10; 20; 35; 40] = 1);
  assert (bad_sensor [5; 4; 3; 2; 1] [5; 4; 2; 1; 1] = 2);
  assert (bad_sensor [1; 1; 1; 1; 1] [1; 1; 1; 1; 1] = -1);
  assert (bad_sensor [10; 20; 30; 40; 50] [10; 20; 30; 50; 45] = 2);
;;","easy","easy_066","easy"
"(**A digit string is good if the digits (0-indexed) at even indices are even and the digits at odd i...
 * >>> count_good_numbers 1
 * 5
 * >>> count_good_numbers 4
 * 400
 * >>> count_good_numbers 50
 * 564908303
*)
let count_good_numbers (n : int) : int =","  0","let () =
  assert (count_good_numbers 1 = 5);
  assert (count_good_numbers 4 = 400);
  assert (count_good_numbers 50 = 564908303);
  assert (count_good_numbers 500 = 315782032);
  assert (count_good_numbers 15 = 399999958);
  assert (count_good_numbers 200 = 864605215);
  assert (count_good_numbers 9999 = 581472940);
;;","medium","medium_040","medium"
"(**Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i...
 * >>> count_bits 0
 * [0]
 * >>> count_bits 100000
 * Execution timed out
 * >>> count_bits 10000
 * [0; 1; 1; 2; 1; 2; 2; 3; 1; 2; 2; 3; 2; 3; 3; 4; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 8; 9; 9; 10; 9; 10; 10; 11; 9; 10; 10; 11; 10; 11; 11; 12; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 8; 9; 9; 10; 9; 10; 10; 11; 9; 10; 10; 11; 10; 11; 11; 12; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 8; 9; 9; 10; 9; 10; 10; 11; 9; 10; 10; 11; 10; 11; 11; 12; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 8; 9; 9; 10; 9; 10; 10; 11; 9; 10; 10; 11; 10; 11; 11; 12; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 8; 9; 9; 10; 9; 10; 10; 11; 9; 10; 10; 11; 10; 11; 11; 12; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 8; 9; 9; 10; 9; 10; 10; 11; 9; 10; 10; 11; 10; 11; 11; 12; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 8; 9; 9; 10; 9; 10; 10; 11; 9; 10; 10; 11; 10; 11; 11; 12; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 8; 9; 9; 10; 9; 10; 10; 11; 9; 10; 10; 11; 10; 11; 11; 12; 8; 9; 9; 10; 9; 10; 10; 11; 9; 10; 10; 11; 10; 11; 11; 12; 9; 10; 10; 11; 10; 11; 11; 12; 10; 11; 11; 12; 11; 12; 12; 13; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5]
*)
let count_bits (n : int) : int list =","  []","let () =
  assert (count_bits 0 = [0]);
  assert (count_bits 100000 = Execution timed out);
  assert (count_bits 10000 = [0; 1; 1; 2; 1; 2; 2; 3; 1; 2; 2; 3; 2; 3; 3; 4; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 8; 9; 9; 10; 9; 10; 10; 11; 9; 10; 10; 11; 10; 11; 11; 12; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 8; 9; 9; 10; 9; 10; 10; 11; 9; 10; 10; 11; 10; 11; 11; 12; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 8; 9; 9; 10; 9; 10; 10; 11; 9; 10; 10; 11; 10; 11; 11; 12; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 8; 9; 9; 10; 9; 10; 10; 11; 9; 10; 10; 11; 10; 11; 11; 12; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 8; 9; 9; 10; 9; 10; 10; 11; 9; 10; 10; 11; 10; 11; 11; 12; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 8; 9; 9; 10; 9; 10; 10; 11; 9; 10; 10; 11; 10; 11; 11; 12; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 8; 9; 9; 10; 9; 10; 10; 11; 9; 10; 10; 11; 10; 11; 11; 12; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 8; 9; 9; 10; 9; 10; 10; 11; 9; 10; 10; 11; 10; 11; 11; 12; 8; 9; 9; 10; 9; 10; 10; 11; 9; 10; 10; 11; 10; 11; 11; 12; 9; 10; 10; 11; 10; 11; 11; 12; 10; 11; 11; 12; 11; 12; 12; 13; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 6; 7; 7; 8; 7; 8; 8; 9; 7; 8; 8; 9; 8; 9; 9; 10; 7; 8; 8; 9; 8; 9; 9; 10; 8; 9; 9; 10; 9; 10; 10; 11; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5]);
  assert (count_bits 31 = [0; 1; 1; 2; 1; 2; 2; 3; 1; 2; 2; 3; 2; 3; 3; 4; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5]);
  assert (count_bits 2 = [0; 1; 1]);
  assert (count_bits 100 = [0; 1; 1; 2; 1; 2; 2; 3; 1; 2; 2; 3; 2; 3; 3; 4; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 2; 3; 3; 4; 3]);
  assert (count_bits 1000 = [0; 1; 1; 2; 1; 2; 2; 3; 1; 2; 2; 3; 2; 3; 3; 4; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 1; 2; 2; 3; 2; 3; 3; 4; 2; 3; 3; 4; 3; 4; 4; 5; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 2; 3; 3; 4; 3; 4; 4; 5; 3; 4; 4; 5; 4; 5; 5; 6; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 3; 4; 4; 5; 4; 5; 5; 6; 4; 5; 5; 6; 5; 6; 6; 7; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 4; 5; 5; 6; 5; 6; 6; 7; 5; 6; 6; 7; 6; 7; 7; 8; 5; 6; 6; 7; 6; 7; 7; 8; 6; 7; 7; 8; 7; 8; 8; 9; 5; 6; 6; 7; 6; 7; 7; 8; 6]);
;;","easy","easy_085","easy"
"(**You are given a positive integer n, you can do the following operation any number of times:
 * >>> min_operations 3
 * 2
 * >>> min_operations 63
 * 2
 * >>> min_operations 100
 * 3
*)
let min_operations (n : int) : int =","  0","let () =
  assert (min_operations 3 = 2);
  assert (min_operations 63 = 2);
  assert (min_operations 100 = 3);
  assert (min_operations 50000 = 6);
  assert (min_operations 4 = 1);
  assert (min_operations 64 = 1);
  assert (min_operations 16 = 1);
;;","medium","medium_008","medium"
"(**You are given a 0-indexed integer array stones sorted in strictly increasing order representing t...
 * >>> max_jump [0; 10; 15; 20; 25]
 * 15
 * >>> max_jump [0; 1; 2; 3; 4; 5]
 * 2
 * >>> max_jump [0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
 * 2
*)
let max_jump (stones : int list) : int =","  0","let () =
  assert (max_jump [0; 10; 15; 20; 25] = 15);
  assert (max_jump [0; 1; 2; 3; 4; 5] = 2);
  assert (max_jump [0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = 2);
  assert (max_jump [0; 2; 5; 6; 7] = 5);
  assert (max_jump [0; 1; 3; 6; 10; 15] = 9);
  assert (max_jump [0; 5; 10; 15; 20; 25; 30] = 10);
  assert (max_jump [0; 3; 9] = 9);
;;","medium","medium_143","medium"
"(**Given two binary trees original and cloned and given a reference to a node target in the original...
 * >>> get_target_copy [8; null; 6; null; 5; null; 4; null; 3; null; 2; null; 1] [8; null; 6; null; 5; null; 4; null; 3; null; 2; null; 1] 4
 * None
 * >>> get_target_copy [7; 4; 3; null; null; 6; 19] [7; 4; 3; null; null; 6; 19] 3
 * None
 * >>> get_target_copy [7] [7] 7
 * None
*)
let get_target_copy (original : 'a) (cloned : 'a) (target : 'a) : 'a =","  failwith ""Not implemented""","let () =
  assert (get_target_copy [8; null; 6; null; 5; null; 4; null; 3; null; 2; null; 1] [8; null; 6; null; 5; null; 4; null; 3; null; 2; null; 1] 4 = None);
  assert (get_target_copy [7; 4; 3; null; null; 6; 19] [7; 4; 3; null; null; 6; 19] 3 = None);
  assert (get_target_copy [7] [7] 7 = None);
  assert (get_target_copy [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15] [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15] 10 = None);
  assert (get_target_copy [1; null; 2; null; 3; null; 4; null; 5; null; 6; null; 7; null; 8; null; 9; null; 10] [1; null; 2; null; 3; null; 4; null; 5; null; 6; null; 7; null; 8; null; 9; null; 10] 5 = None);
  assert (get_target_copy [5; 3; 6; 2; 4; null; 8; 1; null; null; null; 7; 9] [5; 3; 6; 2; 4; null; 8; 1; null; null; null; 7; 9] 7 = None);
  assert (get_target_copy [1; 2; null; 3; null; 4; null; 5; null; 6; null; 7; null; 8; null; 9; null; 10] [1; 2; null; 3; null; 4; null; 5; null; 6; null; 7; null; 8; null; 9; null; 10] 6 = None);
;;","easy","easy_173","easy"
"(**A permutation of an array of integers is an arrangement of its members into a sequence or linear ...
 * >>> next_permutation [5; 4; 7; 5; 3; 2]
 * None
 * >>> next_permutation [4; 3; 2; 1]
 * None
 * >>> next_permutation [1; 2; 2; 3]
 * None
*)
let next_permutation (nums : int list) : unit =","  failwith ""Not implemented""","let () =
  assert (next_permutation [5; 4; 7; 5; 3; 2] = None);
  assert (next_permutation [4; 3; 2; 1] = None);
  assert (next_permutation [1; 2; 2; 3] = None);
  assert (next_permutation [1; 1; 1] = None);
  assert (next_permutation [2; 3; 1] = None);
  assert (next_permutation [2; 1] = None);
  assert (next_permutation [1] = None);
;;","medium","medium_158","medium"
"(**Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are a...
 * >>> relative_sort_array [28; 6; 22; 8; 44; 17] [22; 28; 8; 6]
 * [22; 28; 8; 6; 17; 44]
 * >>> relative_sort_array [1; 2; 3] [1; 2; 3; 4; 5]
 * [1; 2; 3]
 * >>> relative_sort_array [10; 9; 8; 7; 6] [10; 9; 8; 7; 6]
 * [10; 9; 8; 7; 6]
*)
let relative_sort_array (arr1 : int list) (arr2 : int list) : int list =","  []","let () =
  assert (relative_sort_array [28; 6; 22; 8; 44; 17] [22; 28; 8; 6] = [22; 28; 8; 6; 17; 44]);
  assert (relative_sort_array [1; 2; 3] [1; 2; 3; 4; 5] = [1; 2; 3]);
  assert (relative_sort_array [10; 9; 8; 7; 6] [10; 9; 8; 7; 6] = [10; 9; 8; 7; 6]);
  assert (relative_sort_array [0; 1; 2; 3; 4; 5; 6; 7; 8; 9] [0; 2; 4; 6; 8] = [0; 2; 4; 6; 8; 1; 3; 5; 7; 9]);
  assert (relative_sort_array [1; 2; 3; 4; 5] [5; 4; 3; 2; 1] = [5; 4; 3; 2; 1]);
  assert (relative_sort_array [3; 1; 2] [3; 1] = [3; 1; 2]);
  assert (relative_sort_array [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] [1; 3; 5; 7; 9] = [1; 3; 5; 7; 9; 2; 4; 6; 8; 10]);
;;","easy","easy_015","easy"
"(**You are given an integer n denoting the total number of servers and a 2D 0-indexed integer array ...
 * >>> count_servers 1 [[1; 1]] 1 [2]
 * [0]
 * >>> count_servers 10 [[1; 10]; [2; 20]; [3; 30]; [4; 40]; [5; 50]; [6; 60]; [7; 70]; [8; 80]; [9; 90]; [10; 100]] 10 [20; 50; 80; 110]
 * [8; 8; 8; 9]
 * >>> count_servers 4 [[1; 10]; [2; 15]; [3; 20]; [4; 25]] 10 [15; 20; 25; 30]
 * [2; 1; 1; 2]
*)
let count_servers (n : int) (logs : int list list) (x : int) (queries : int list) : int list =","  []","let () =
  assert (count_servers 1 [[1; 1]] 1 [2] = [0]);
  assert (count_servers 10 [[1; 10]; [2; 20]; [3; 30]; [4; 40]; [5; 50]; [6; 60]; [7; 70]; [8; 80]; [9; 90]; [10; 100]] 10 [20; 50; 80; 110] = [8; 8; 8; 9]);
  assert (count_servers 4 [[1; 10]; [2; 15]; [3; 20]; [4; 25]] 10 [15; 20; 25; 30] = [2; 1; 1; 2]);
  assert (count_servers 3 [[1; 3]; [2; 6]; [1; 5]] 5 [10; 11] = [1; 2]);
  assert (count_servers 3 [[2; 4]; [2; 1]; [1; 2]; [3; 1]] 2 [3; 4] = [0; 1]);
  assert (count_servers 5 [[1; 1]; [2; 2]; [3; 3]; [4; 4]; [5; 5]] 1 [1; 2; 3; 4; 5] = [4; 3; 3; 3; 3]);
  assert (count_servers 4 [[1; 10]; [2; 20]; [3; 30]; [4; 40]] 15 [15; 25; 35; 45] = [3; 2; 2; 2]);
;;","medium","medium_200","medium"
"(**Alice is texting Bob using her phone. The mapping of digits to letters is shown in the figure below.
 * >>> count_texts ""99999999""
 * 108
 * >>> count_texts ""3333""
 * 7
 * >>> count_texts ""33""
 * 2
*)
let count_texts (pressedKeys : string) : int =","  0","let () =
  assert (count_texts ""99999999"" = 108);
  assert (count_texts ""3333"" = 7);
  assert (count_texts ""33"" = 2);
  assert (count_texts ""4444"" = 7);
  assert (count_texts ""555555"" = 24);
  assert (count_texts ""9999999"" = 56);
  assert (count_texts ""888888888"" = 149);
;;","medium","medium_024","medium"
"(**We can represent a sentence as an array of words, for example, the sentence ""I am happy with leet...
 * >>> are_sentences_similar_two [""I""; ""love""; ""leetcode""] [""I""; ""love""; ""onepiece""] [[""manga""; ""hunterXhunter""]; [""platform""; ""anime""]; [""leetcode""; ""platform""]; [""anime""; ""manga""]]
 * false
 * >>> are_sentences_similar_two [""foo""; ""bar""; ""baz""] [""foo""; ""bar""; ""qux""] [[""baz""; ""qux""]]
 * true
 * >>> are_sentences_similar_two [""great""; ""acting""; ""skills""] [""fine""; ""drama""; ""talent""] [[""great""; ""good""]; [""fine""; ""good""]; [""drama""; ""acting""]; [""skills""; ""talent""]]
 * true
*)
let are_sentences_similar_two (sentence1 : string list) (sentence2 : string list) (similarPairs : string list list) : bool =","  false","let () =
  assert (are_sentences_similar_two [""I""; ""love""; ""leetcode""] [""I""; ""love""; ""onepiece""] [[""manga""; ""hunterXhunter""]; [""platform""; ""anime""]; [""leetcode""; ""platform""]; [""anime""; ""manga""]] = false);
  assert (are_sentences_similar_two [""foo""; ""bar""; ""baz""] [""foo""; ""bar""; ""qux""] [[""baz""; ""qux""]] = true);
  assert (are_sentences_similar_two [""great""; ""acting""; ""skills""] [""fine""; ""drama""; ""talent""] [[""great""; ""good""]; [""fine""; ""good""]; [""drama""; ""acting""]; [""skills""; ""talent""]] = true);
  assert (are_sentences_similar_two [""I""; ""love""; ""leetcode""] [""I""; ""love""; ""onepiece""] [[""manga""; ""hunterXhunter""]; [""platform""; ""anime""]; [""leetcode""; ""platform""]; [""anime""; ""manga""]] = false);
  assert (are_sentences_similar_two [""great""; ""acting""; ""skills""] [""fine""; ""drama""; ""talent""] [[""great""; ""good""]; [""fine""; ""good""]; [""drama""; ""acting""]; [""skills""; ""talent""]] = true);
  assert (are_sentences_similar_two [""hello""; ""world""] [""hi""; ""earth""] [[""hello""; ""hi""]; [""world""; ""earth""]] = true);
  assert (are_sentences_similar_two [""a""; ""b""] [""c""; ""d""] [[""a""; ""c""]; [""b""; ""d""]] = true);
;;","medium","medium_191","medium"
"(**You are given a 0-indexed array nums consisting of non-negative powers of 2, and an integer target.
 * >>> min_operations [2; 4; 8; 16] 31
 * -1
 * >>> min_operations [32; 16; 8; 4; 2; 1] 63
 * 0
 * >>> min_operations [1; 1; 1; 1; 1; 1; 1; 1] 4
 * 0
*)
let min_operations (nums : int list) (target : int) : int =","  0","let () =
  assert (min_operations [2; 4; 8; 16] 31 = -1);
  assert (min_operations [32; 16; 8; 4; 2; 1] 63 = 0);
  assert (min_operations [1; 1; 1; 1; 1; 1; 1; 1] 4 = 0);
  assert (min_operations [1; 1; 1; 1; 1; 1; 1; 1; 1; 1] 10 = 0);
  assert (min_operations [1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1] 15 = 0);
  assert (min_operations [128; 64; 32; 16; 8; 4; 2; 1] 255 = 0);
  assert (min_operations [1; 2; 4; 8; 16; 32; 64; 128; 256; 512; 1024; 2048; 4096; 8192; 16384; 32768; 65536; 131072; 262144; 524288; 1048576; 2097152; 4194304; 8388608; 16777216; 33554432; 67108864; 134217728; 268435456; 536870912; 1073741824] 2147483647 = 0);
;;","hard","hard_047","hard"
"(**Given a string queryIP, return ""IPv4"" if IP is a valid IPv4 address, ""IPv6"" if IP is a valid IPv6...
 * >>> valid_ipaddress ""192.168.1.1.1""
 * Neither
 * >>> valid_ipaddress ""2001:DB8:85A3:0:0:8A2E:370:7334""
 * IPv6
 * >>> valid_ipaddress ""2001:0db8:85a3:0000:0000:8A2E:0370:7334""
 * IPv6
*)
let valid_ipaddress (queryIP : string) : string =","  """"","let () =
  assert (valid_ipaddress ""192.168.1.1.1"" = Neither);
  assert (valid_ipaddress ""2001:DB8:85A3:0:0:8A2E:370:7334"" = IPv6);
  assert (valid_ipaddress ""2001:0db8:85a3:0000:0000:8A2E:0370:7334"" = IPv6);
  assert (valid_ipaddress ""2001:0db8:85a3:0:0:8A2E:0370:733"" = IPv6);
  assert (valid_ipaddress ""123.456.789.01"" = Neither);
  assert (valid_ipaddress ""123:456:789:0123:456:789:0123:4567890:abcd"" = Neither);
  assert (valid_ipaddress ""172.16.254.1"" = IPv4);
;;","medium","medium_050","medium"
"(**There are n children standing in a line. Each child is assigned a rating value given in the integ...
 * >>> candy [50; 40; 30; 20; 10]
 * 15
 * >>> candy [1]
 * 1
 * >>> candy [1; 3; 4; 5; 2]
 * 11
*)
let candy (ratings : int list) : int =","  0","let () =
  assert (candy [50; 40; 30; 20; 10] = 15);
  assert (candy [1] = 1);
  assert (candy [1; 3; 4; 5; 2] = 11);
  assert (candy [1; 1; 1; 1] = 4);
  assert (candy [1; 2; 3; 2; 1; 2; 3; 4; 3; 2; 1] = 24);
  assert (candy [5; 4; 3; 2; 1] = 15);
  assert (candy [10; 20; 30; 40; 50; 45; 35; 25; 15; 5] = 31);
;;","hard","hard_039","hard"
"(**There are three stones in different positions on the X-axis. You are given three integers a, b, a...
 * >>> num_moves_stones 7 8 10
 * [1; 1]
 * >>> num_moves_stones 1 100 50
 * [2; 97]
 * >>> num_moves_stones 1 3 100
 * [1; 97]
*)
let num_moves_stones (a : int) (b : int) (c : int) : int list =","  []","let () =
  assert (num_moves_stones 7 8 10 = [1; 1]);
  assert (num_moves_stones 1 100 50 = [2; 97]);
  assert (num_moves_stones 1 3 100 = [1; 97]);
  assert (num_moves_stones 10 12 14 = [1; 2]);
  assert (num_moves_stones 50 51 53 = [1; 1]);
  assert (num_moves_stones 25 27 30 = [1; 3]);
  assert (num_moves_stones 5 6 8 = [1; 1]);
;;","medium","medium_109","medium"
"(**Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string ...
 * >>> number_of_beams [""00000""; ""00000""; ""00000""; ""00000""]
 * 0
 * >>> number_of_beams [""001""; ""000""; ""101""; ""000""; ""110""]
 * 6
 * >>> number_of_beams [""111""; ""000""; ""111""]
 * 9
*)
let number_of_beams (bank : string list) : int =","  0","let () =
  assert (number_of_beams [""00000""; ""00000""; ""00000""; ""00000""] = 0);
  assert (number_of_beams [""001""; ""000""; ""101""; ""000""; ""110""] = 6);
  assert (number_of_beams [""111""; ""000""; ""111""] = 9);
  assert (number_of_beams [""0000""; ""0000""; ""0000""; ""0000""] = 0);
  assert (number_of_beams [""11111""; ""11111""; ""11111""] = 50);
  assert (number_of_beams [""000""; ""000""; ""000""] = 0);
  assert (number_of_beams [""101""; ""010""; ""101""; ""010""] = 6);
;;","medium","medium_080","medium"
"(**You are given two arrays of integers nums1 and nums2, possibly of different lengths. The values i...
 * >>> min_operations [6; 5; 4; 3; 2; 1] [1; 2; 3; 4; 5; 6]
 * 0
 * >>> min_operations [3; 3; 3; 3] [2; 2; 2; 2]
 * 1
 * >>> min_operations [1; 1] [6; 6]
 * 2
*)
let min_operations (nums1 : int list) (nums2 : int list) : int =","  0","let () =
  assert (min_operations [6; 5; 4; 3; 2; 1] [1; 2; 3; 4; 5; 6] = 0);
  assert (min_operations [3; 3; 3; 3] [2; 2; 2; 2] = 1);
  assert (min_operations [1; 1] [6; 6] = 2);
  assert (min_operations [6; 6; 6] [1; 1] = 4);
  assert (min_operations [1; 1; 2] [6; 6; 6] = 3);
  assert (min_operations [1; 1] [6; 6; 6] = 4);
  assert (min_operations [5; 5; 5; 5] [1; 1; 1; 1; 1; 1; 1] = 3);
;;","medium","medium_076","medium"
"(**Perform the following shift operations on a string:
 * >>> group_strings [""aaa""; ""bbb""; ""ccc""; ""zzz""; ""aaa""; ""zzz""]
 * [['aaa'; 'bbb'; 'ccc'; 'zzz'; 'aaa'; 'zzz']]
 * >>> group_strings [""abcdefghijklmnopqrstuvwxyz""; ""bcdefghijklmnopqrstuvwxyza""; ""zabcdefghijklmnopqrstuvwxy""]
 * [['abcdefghijklmnopqrstuvwxyz'; 'bcdefghijklmnopqrstuvwxyza'; 'zabcdefghijklmnopqrstuvwxy']]
 * >>> group_strings [""aaa""; ""bbb""; ""ccc""; ""xyz""; ""zyz""; ""aba""; ""bab""; ""aab""; ""abb""; ""abc""; ""bca""; ""cab""]
 * [['aaa'; 'bbb'; 'ccc']; ['xyz'; 'abc']; ['zyz'; 'bab']; ['aba']; ['aab']; ['abb']; ['bca']; ['cab']]
*)
let group_strings (strings : string list) : string list list =","  [[]]","let () =
  assert (group_strings [""aaa""; ""bbb""; ""ccc""; ""zzz""; ""aaa""; ""zzz""] = [['aaa'; 'bbb'; 'ccc'; 'zzz'; 'aaa'; 'zzz']]);
  assert (group_strings [""abcdefghijklmnopqrstuvwxyz""; ""bcdefghijklmnopqrstuvwxyza""; ""zabcdefghijklmnopqrstuvwxy""] = [['abcdefghijklmnopqrstuvwxyz'; 'bcdefghijklmnopqrstuvwxyza'; 'zabcdefghijklmnopqrstuvwxy']]);
  assert (group_strings [""aaa""; ""bbb""; ""ccc""; ""xyz""; ""zyz""; ""aba""; ""bab""; ""aab""; ""abb""; ""abc""; ""bca""; ""cab""] = [['aaa'; 'bbb'; 'ccc']; ['xyz'; 'abc']; ['zyz'; 'bab']; ['aba']; ['aab']; ['abb']; ['bca']; ['cab']]);
  assert (group_strings [""az""; ""za""; ""ba""; ""ab""; ""yx""; ""xy""] = [['az'; 'ba'; 'yx']; ['za'; 'ab'; 'xy']]);
  assert (group_strings [""az""; ""za""; ""abc""; ""bca""; ""cab""; ""xyz""; ""zyx""] = [['az']; ['za']; ['abc'; 'xyz']; ['bca']; ['cab']; ['zyx']]);
  assert (group_strings [""abc""; ""bcd""; ""cde""; ""def""; ""ghi""; ""jkl""; ""mno""; ""pqr""; ""stu""; ""vwx""; ""yz""; ""zab""; ""abc""] = [['abc'; 'bcd'; 'cde'; 'def'; 'ghi'; 'jkl'; 'mno'; 'pqr'; 'stu'; 'vwx'; 'zab'; 'abc']; ['yz']]);
  assert (group_strings [""a""] = [['a']]);
;;","medium","medium_015","medium"
"(**We have n cities and m bi-directional roads where roads[i] = [ai, bi] connects city ai with city ...
 * >>> most_similar 6 [[0; 1]; [1; 2]; [2; 3]; [3; 4]; [4; 5]] [""ATL""; ""PEK""; ""LAX""; ""ATL""; ""DXB""; ""HND""] [""ATL""; ""DXB""; ""HND""; ""DXB""; ""ATL""; ""LAX""; ""PEK""]
 * [3; 4; 5; 4; 3; 2; 1]
 * >>> most_similar 5 [[0; 2]; [0; 3]; [1; 2]; [1; 3]; [1; 4]; [2; 4]] [""ATL""; ""PEK""; ""LAX""; ""DXB""; ""HND""] [""ATL""; ""DXB""; ""HND""; ""LAX""]
 * [0; 3; 0; 2]
 * >>> most_similar 4 [[1; 0]; [2; 0]; [3; 0]; [2; 1]; [3; 1]; [3; 2]] [""ATL""; ""PEK""; ""LAX""; ""DXB""] [""ABC""; ""DEF""; ""GHI""; ""JKL""; ""MNO""; ""PQR""; ""STU""; ""VWX""]
 * [1; 0; 1; 0; 1; 0; 1; 0]
*)
let most_similar (n : int) (roads : int list list) (names : string list) (targetPath : string list) : int list =","  []","let () =
  assert (most_similar 6 [[0; 1]; [1; 2]; [2; 3]; [3; 4]; [4; 5]] [""ATL""; ""PEK""; ""LAX""; ""ATL""; ""DXB""; ""HND""] [""ATL""; ""DXB""; ""HND""; ""DXB""; ""ATL""; ""LAX""; ""PEK""] = [3; 4; 5; 4; 3; 2; 1]);
  assert (most_similar 5 [[0; 2]; [0; 3]; [1; 2]; [1; 3]; [1; 4]; [2; 4]] [""ATL""; ""PEK""; ""LAX""; ""DXB""; ""HND""] [""ATL""; ""DXB""; ""HND""; ""LAX""] = [0; 3; 0; 2]);
  assert (most_similar 4 [[1; 0]; [2; 0]; [3; 0]; [2; 1]; [3; 1]; [3; 2]] [""ATL""; ""PEK""; ""LAX""; ""DXB""] [""ABC""; ""DEF""; ""GHI""; ""JKL""; ""MNO""; ""PQR""; ""STU""; ""VWX""] = [1; 0; 1; 0; 1; 0; 1; 0]);
  assert (most_similar 20 [[0; 1]; [0; 2]; [1; 3]; [1; 4]; [2; 5]; [2; 6]; [3; 7]; [4; 8]; [5; 9]; [6; 10]; [7; 11]; [8; 12]; [9; 13]; [10; 14]; [11; 15]; [12; 16]; [13; 17]; [14; 18]; [15; 19]; [16; 19]; [17; 19]; [18; 19]] [""LAX""; ""HOU""; ""ATL""; ""DFW""; ""DEN""; ""PHX""; ""SEA""; ""ORD""; ""SLC""; ""JFK""; ""PDX""; ""EWR""; ""BOS""; ""MIA""; ""SFO""; ""IAD""; ""PHL""; ""MDW""; ""DFW""; ""LAX""] [""LAX""; ""HOU""; ""ATL""; ""DFW""; ""DEN""; ""PHX""; ""SEA""; ""ORD""; ""SLC""; ""JFK""; ""PDX""; ""EWR""; ""BOS""; ""MIA""; ""SFO""; ""IAD""; ""PHL""; ""MDW""; ""DFW""; ""LAX""; ""HOU""; ""ATL""; ""DFW""; ""DEN""; ""PHX""; ""SEA""; ""ORD""; ""SLC""; ""JFK""; ""PDX""; ""EWR""] = [0; 1; 0; 1; 4; 1; 3; 7; 3; 1; 4; 8; 12; 16; 19; 15; 11; 7; 3; 1; 0; 2; 0; 2; 5; 2; 0; 2; 6; 10; 6]);
  assert (most_similar 15 [[0; 1]; [0; 2]; [1; 3]; [1; 4]; [2; 5]; [2; 6]; [3; 7]; [4; 8]; [5; 9]; [6; 10]; [7; 11]; [8; 12]; [9; 13]; [10; 14]; [11; 12]; [11; 13]; [12; 14]; [13; 14]] [""LAX""; ""HOU""; ""ATL""; ""DFW""; ""DEN""; ""PHX""; ""SEA""; ""ORD""; ""SLC""; ""JFK""; ""PDX""; ""EWR""; ""BOS""; ""MIA""; ""SFO""] [""LAX""; ""HOU""; ""ATL""; ""DFW""; ""DEN""; ""PHX""; ""SEA""; ""ORD""; ""SLC""; ""JFK""; ""PDX""; ""EWR""; ""BOS""; ""MIA""; ""SFO""; ""LAX""; ""HOU""; ""ATL""; ""DFW""; ""DEN""] = [0; 1; 0; 1; 4; 1; 0; 2; 5; 9; 13; 11; 7; 3; 1; 0; 1; 0; 1; 4]);
  assert (most_similar 10 [[0; 1]; [1; 2]; [2; 3]; [3; 4]; [4; 5]; [5; 6]; [6; 7]; [7; 8]; [8; 9]; [0; 5]; [1; 6]; [2; 7]; [3; 8]; [4; 9]] [""XYZ""; ""XYZ""; ""XYZ""; ""XYZ""; ""XYZ""; ""XYZ""; ""XYZ""; ""XYZ""; ""XYZ""; ""XYZ""] [""XYZ""; ""XYZ""; ""XYZ""; ""XYZ""; ""XYZ""; ""XYZ""; ""XYZ""; ""XYZ""; ""XYZ""; ""XYZ""; ""XYZ""; ""XYZ""] = [1; 0; 1; 0; 1; 0; 1; 0; 1; 0; 1; 0]);
  assert (most_similar 7 [[0; 1]; [0; 2]; [0; 3]; [1; 4]; [1; 5]; [2; 6]; [3; 6]; [4; 6]; [5; 6]] [""LAX""; ""ATL""; ""DFW""; ""DEN""; ""PHX""; ""ORD""; ""JFK""] [""LAX""; ""ATL""; ""DFW""; ""DEN""; ""PHX""; ""ORD""; ""JFK""; ""LAX""; ""ATL""; ""DFW""] = [0; 1; 0; 3; 6; 5; 1; 0; 1; 0]);
;;","hard","hard_055","hard"
"(**Given a sorted array of distinct integers and a target value, return the index if the target is f...
 * >>> search_insert [-10; 0; 5; 10] 0
 * 1
 * >>> search_insert [1; 2; 4; 6; 7; 9] 3
 * 2
 * >>> search_insert [1; 3; 5] 4
 * 2
*)
let search_insert (nums : int list) (target : int) : int =","  0","let () =
  assert (search_insert [-10; 0; 5; 10] 0 = 1);
  assert (search_insert [1; 2; 4; 6; 7; 9] 3 = 2);
  assert (search_insert [1; 3; 5] 4 = 2);
  assert (search_insert [1; 3; 5; 6] 2 = 1);
  assert (search_insert [-10; -5; -3; 2; 3; 4; 5] -4 = 2);
  assert (search_insert [-10; 0; 10; 20; 30; 40; 50] -5 = 1);
  assert (search_insert [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 0 = 0);
;;","easy","easy_153","easy"
"(**Given a binary string s, return the number of non-empty substrings that have the same number of 0...
 * >>> count_binary_substrings ""000111000111""
 * 9
 * >>> count_binary_substrings ""01""
 * 1
 * >>> count_binary_substrings ""110011""
 * 4
*)
let count_binary_substrings (s : string) : int =","  0","let () =
  assert (count_binary_substrings ""000111000111"" = 9);
  assert (count_binary_substrings ""01"" = 1);
  assert (count_binary_substrings ""110011"" = 4);
  assert (count_binary_substrings ""00110011"" = 6);
  assert (count_binary_substrings ""11110000"" = 4);
  assert (count_binary_substrings ""10101"" = 4);
  assert (count_binary_substrings ""1100"" = 2);
;;","easy","easy_181","easy"
"(**A decimal number can be converted to its Hexspeak representation by first converting it to an upp...
 * >>> to_hexspeak ""2718281828459045""
 * ERROR
 * >>> to_hexspeak ""1234567890""
 * ERROR
 * >>> to_hexspeak ""1234567890123456789""
 * ERROR
*)
let to_hexspeak (num : string) : string =","  """"","let () =
  assert (to_hexspeak ""2718281828459045"" = ERROR);
  assert (to_hexspeak ""1234567890"" = ERROR);
  assert (to_hexspeak ""1234567890123456789"" = ERROR);
  assert (to_hexspeak ""257"" = IOI);
  assert (to_hexspeak ""3"" = ERROR);
  assert (to_hexspeak ""123456789"" = ERROR);
  assert (to_hexspeak ""1"" = I);
;;","easy","easy_004","easy"
"(**You are given a 0-indexed array nums of size n consisting of positive integers.
 * >>> unmarked_sum_array [10; 20; 30; 40; 50] [[4; 1]; [0; 2]; [2; 2]]
 * [90; 40; 0]
 * >>> unmarked_sum_array [10; 20; 30; 40; 50] [[0; 2]; [1; 1]]
 * [90; 50]
 * >>> unmarked_sum_array [5; 3; 8; 1; 4] [[2; 1]; [4; 2]; [0; 2]]
 * [12; 0; 0]
*)
let unmarked_sum_array (nums : int list) (queries : int list list) : int list =","  []","let () =
  assert (unmarked_sum_array [10; 20; 30; 40; 50] [[4; 1]; [0; 2]; [2; 2]] = [90; 40; 0]);
  assert (unmarked_sum_array [10; 20; 30; 40; 50] [[0; 2]; [1; 1]] = [90; 50]);
  assert (unmarked_sum_array [5; 3; 8; 1; 4] [[2; 1]; [4; 2]; [0; 2]] = [12; 0; 0]);
  assert (unmarked_sum_array [1; 1; 1; 1; 1; 1; 1; 1; 1; 1] [[0; 5]; [3; 3]; [1; 1]] = [4; 1; 0]);
  assert (unmarked_sum_array [1; 4; 2; 3] [[0; 1]] = [7]);
  assert (unmarked_sum_array [1; 2; 2; 1; 2; 3; 1] [[1; 2]; [3; 3]; [4; 2]] = [8; 3; 0]);
  assert (unmarked_sum_array [7; 7; 7; 7; 7] [[0; 3]; [2; 2]] = [7; 0]);
;;","medium","medium_045","medium"
"(**You are given an array rectangles where rectangles[i] = [li, wi] represents the ith rectangle of ...
 * >>> count_good_rectangles [[1; 2]; [2; 1]; [3; 4]; [4; 3]]
 * 2
 * >>> count_good_rectangles [[2; 3]; [3; 7]; [4; 3]; [3; 7]]
 * 3
 * >>> count_good_rectangles [[1000000000; 1000000000]; [999999999; 999999999]; [1; 1]]
 * 1
*)
let count_good_rectangles (rectangles : int list list) : int =","  0","let () =
  assert (count_good_rectangles [[1; 2]; [2; 1]; [3; 4]; [4; 3]] = 2);
  assert (count_good_rectangles [[2; 3]; [3; 7]; [4; 3]; [3; 7]] = 3);
  assert (count_good_rectangles [[1000000000; 1000000000]; [999999999; 999999999]; [1; 1]] = 1);
  assert (count_good_rectangles [[5; 8]; [3; 9]; [5; 12]; [16; 5]] = 3);
  assert (count_good_rectangles [[10; 20]; [20; 10]; [5; 5]; [15; 15]] = 1);
  assert (count_good_rectangles [[100; 200]; [200; 100]; [150; 150]; [250; 250]; [50; 50]; [250; 300]; [300; 250]; [300; 300]; [350; 350]] = 1);
  assert (count_good_rectangles [[7; 7]; [8; 8]; [9; 9]; [10; 10]; [11; 11]; [12; 12]; [13; 13]; [14; 14]; [15; 15]] = 1);
;;","easy","easy_195","easy"
"(**Given a string s, return the number of different non-empty palindromic subsequences in s. Since t...
 * >>> count_palindromic_subsequences ""abba""
 * 6
 * >>> count_palindromic_subsequences ""abccba""
 * 14
 * >>> count_palindromic_subsequences ""abcba""
 * 10
*)
let count_palindromic_subsequences (s : string) : int =","  0","let () =
  assert (count_palindromic_subsequences ""abba"" = 6);
  assert (count_palindromic_subsequences ""abccba"" = 14);
  assert (count_palindromic_subsequences ""abcba"" = 10);
  assert (count_palindromic_subsequences ""abac"" = 5);
  assert (count_palindromic_subsequences ""a"" = 1);
  assert (count_palindromic_subsequences ""abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba"" = 104860361);
  assert (count_palindromic_subsequences ""aabbaa"" = 10);
;;","hard","hard_057","hard"
"(**Given a 0-indexed integer array nums of length n and an integer k, return the number of pairs (i,...
 * >>> count_pairs [5; 5; 5; 5; 5] 5
 * 4
 * >>> count_pairs [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 10
 * 0
 * >>> count_pairs [6; 6; 6; 6] 2
 * 5
*)
let count_pairs (nums : int list) (k : int) : int =","  0","let () =
  assert (count_pairs [5; 5; 5; 5; 5] 5 = 4);
  assert (count_pairs [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 10 = 0);
  assert (count_pairs [6; 6; 6; 6] 2 = 5);
  assert (count_pairs [3; 1; 2; 2; 2; 1; 3] 2 = 4);
  assert (count_pairs [9; 9; 9] 9 = 2);
  assert (count_pairs [10; 20; 10; 20; 10] 10 = 2);
  assert (count_pairs [5; 5; 5; 5; 5; 5; 5; 5; 5; 5] 3 = 30);
;;","easy","easy_011","easy"
"(**You are given an integer array nums of length n and an integer numSlots such that 2 * numSlots >=...
 * >>> maximum_andsum [1; 1; 1] 2
 * 2
 * >>> maximum_andsum [1; 2; 3] 2
 * 5
 * >>> maximum_andsum [15; 15; 15; 15; 15; 15; 15; 15] 8
 * 52
*)
let maximum_andsum (nums : int list) (numSlots : int) : int =","  0","let () =
  assert (maximum_andsum [1; 1; 1] 2 = 2);
  assert (maximum_andsum [1; 2; 3] 2 = 5);
  assert (maximum_andsum [15; 15; 15; 15; 15; 15; 15; 15] 8 = 52);
  assert (maximum_andsum [15; 15; 15] 2 = 5);
  assert (maximum_andsum [1; 2; 3; 4; 5; 6] 3 = 9);
  assert (maximum_andsum [7; 11; 4; 1; 3; 10; 4; 9] 5 = 23);
  assert (maximum_andsum [1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1] 8 = 8);
;;","hard","hard_064","hard"
"(**Given an array of integers nums and an integer k, return the number of contiguous subarrays where...
 * >>> num_subarray_product_less_than_k [10; 2; 5; 6; 1] 100
 * 12
 * >>> num_subarray_product_less_than_k [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 50
 * 19
 * >>> num_subarray_product_less_than_k [1; 2; 3; 4; 5; 6; 7; 8; 9] 100
 * 21
*)
let num_subarray_product_less_than_k (nums : int list) (k : int) : int =","  0","let () =
  assert (num_subarray_product_less_than_k [10; 2; 5; 6; 1] 100 = 12);
  assert (num_subarray_product_less_than_k [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 50 = 19);
  assert (num_subarray_product_less_than_k [1; 2; 3; 4; 5; 6; 7; 8; 9] 100 = 21);
  assert (num_subarray_product_less_than_k [6; 5; 1; 2; 3] 100 = 14);
  assert (num_subarray_product_less_than_k [5; 5; 5; 5; 5] 20 = 5);
  assert (num_subarray_product_less_than_k [5; 5; 5; 5] 30 = 7);
  assert (num_subarray_product_less_than_k [7; 3; 4; 9; 1; 3; 6] 100 = 17);
;;","medium","medium_100","medium"
"(**There is a special keyboard with all keys in a single row.
 * >>> calculate_time ""abcdefghijklmnopqrstuvwxyz"" ""a""
 * 0
 * >>> calculate_time ""abcdefghijklmnopqrstuvwxyz"" ""pqrstuvwxyzabcdefghijklmno""
 * 64
 * >>> calculate_time ""zyxwvutsrqponmlkjihgfedcba"" ""zyxwvutsrqponmlkjihgfedcba""
 * 25
*)
let calculate_time (keyboard : string) (word : string) : int =","  0","let () =
  assert (calculate_time ""abcdefghijklmnopqrstuvwxyz"" ""a"" = 0);
  assert (calculate_time ""abcdefghijklmnopqrstuvwxyz"" ""pqrstuvwxyzabcdefghijklmno"" = 64);
  assert (calculate_time ""zyxwvutsrqponmlkjihgfedcba"" ""zyxwvutsrqponmlkjihgfedcba"" = 25);
  assert (calculate_time ""qwertyuiopasdfghjklzxcvbnm"" ""internationalization"" = 188);
  assert (calculate_time ""abcdefghijklmnopqrstuvwxyz"" ""cba"" = 4);
  assert (calculate_time ""abcdefghijklmnopqrstuvwxyz"" ""thequickbrownfoxjumpsoverthelazydog"" = 328);
  assert (calculate_time ""pqrstuvwxyzabcdefghijklmno"" ""leetcode"" = 73);
;;","easy","easy_200","easy"
"(**A conveyor belt has packages that must be shipped from one port to another within days days.
 * >>> ship_within_days [10; 50; 100; 100; 50; 10] 2
 * 160
 * >>> ship_within_days [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 5
 * 15
 * >>> ship_within_days [10; 50; 100; 100; 50; 10] 3
 * 160
*)
let ship_within_days (weights : int list) (days : int) : int =","  0","let () =
  assert (ship_within_days [10; 50; 100; 100; 50; 10] 2 = 160);
  assert (ship_within_days [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 5 = 15);
  assert (ship_within_days [10; 50; 100; 100; 50; 10] 3 = 160);
  assert (ship_within_days [3; 2; 2; 4; 1; 4] 3 = 6);
  assert (ship_within_days [1; 2; 3; 1; 1] 4 = 3);
  assert (ship_within_days [1; 1; 1; 1; 1; 1; 1; 1; 1; 1] 5 = 2);
  assert (ship_within_days [5; 5; 5; 5; 5] 2 = 15);
;;","medium","medium_016","medium"
"(**Given a string s, reverse the order of characters in each word within a sentence while still pres...
 * >>> reverse_words ""Reverse each word""
 * esreveR hcae drow
 * >>> reverse_words ""Python Programming""
 * nohtyP gnimmargorP
 * >>> reverse_words ""Python is fun""
 * nohtyP si nuf
*)
let reverse_words (s : string) : string =","  """"","let () =
  assert (reverse_words ""Reverse each word"" = esreveR hcae drow);
  assert (reverse_words ""Python Programming"" = nohtyP gnimmargorP);
  assert (reverse_words ""Python is fun"" = nohtyP si nuf);
  assert (reverse_words ""reverse each word"" = esrever hcae drow);
  assert (reverse_words ""Mr Ding"" = rM gniD);
  assert (reverse_words ""Hello World"" = olleH dlroW);
  assert (reverse_words ""Let's take LeetCode contest"" = s'teL ekat edoCteeL tsetnoc);
;;","easy","easy_106","easy"
"(**You are given a string s. The score of a string is defined as the sum of the absolute difference ...
 * >>> score_of_string ""abcdefghijklmnopqrstuvwxyz""
 * 25
 * >>> score_of_string ""a""
 * 0
 * >>> score_of_string ""abracadabra""
 * 78
*)
let score_of_string (s : string) : int =","  0","let () =
  assert (score_of_string ""abcdefghijklmnopqrstuvwxyz"" = 25);
  assert (score_of_string ""a"" = 0);
  assert (score_of_string ""abracadabra"" = 78);
  assert (score_of_string ""zzzz"" = 0);
  assert (score_of_string ""zyx"" = 2);
  assert (score_of_string ""mnopqr"" = 5);
  assert (score_of_string ""python"" = 34);
;;","easy","easy_032","easy"
"(**There is a 2D grid of size n x n where each cell of this grid has a lamp that is initially turned...
 * >>> grid_illumination 5 [[0; 0]; [4; 4]] [[1; 1]; [1; 1]]
 * [1; 1]
 * >>> grid_illumination 5 [[0; 0]; [0; 4]] [[0; 4]; [0; 1]; [1; 4]]
 * [1; 1; 0]
 * >>> grid_illumination 5 [[0; 0]; [4; 4]] [[1; 1]; [1; 0]]
 * [1; 0]
*)
let grid_illumination (n : int) (lamps : int list list) (queries : int list list) : int list =","  []","let () =
  assert (grid_illumination 5 [[0; 0]; [4; 4]] [[1; 1]; [1; 1]] = [1; 1]);
  assert (grid_illumination 5 [[0; 0]; [0; 4]] [[0; 4]; [0; 1]; [1; 4]] = [1; 1; 0]);
  assert (grid_illumination 5 [[0; 0]; [4; 4]] [[1; 1]; [1; 0]] = [1; 0]);
  assert (grid_illumination 10 [[0; 0]; [9; 9]; [5; 5]; [2; 7]; [7; 2]] [[1; 1]; [8; 8]; [4; 4]; [3; 6]; [6; 3]] = [1; 1; 1; 1; 1]);
  assert (grid_illumination 10 [[5; 5]] [[4; 4]; [4; 5]; [4; 6]; [5; 4]; [5; 5]; [5; 6]; [6; 4]; [6; 5]; [6; 6]] = [1; 0; 0; 0; 0; 0; 0; 0; 0]);
  assert (grid_illumination 500 [[100; 100]; [200; 200]; [300; 300]; [400; 400]; [499; 499]] [[100; 100]; [200; 200]; [400; 400]] = [1; 1; 1]);
  assert (grid_illumination 15 [[3; 3]; [6; 6]; [9; 9]; [12; 12]] [[3; 3]; [6; 6]; [9; 9]; [12; 12]; [7; 7]; [8; 8]; [10; 10]; [11; 11]] = [1; 1; 1; 1; 0; 0; 0; 0]);
;;","hard","hard_089","hard"
"(**You are given an array of events where events[i] = [startDayi, endDayi, valuei]. The ith event st...
 * >>> max_value [[1; 5; 4]; [11; 15; 1]; [8; 10; 2]; [2; 11; 6]] 3
 * 7
 * >>> max_value [[2; 8; 6]; [4; 9; 10]; [6; 8; 3]] 2
 * 10
 * >>> max_value [[1; 5; 3]; [1; 5; 6]; [6; 10; 5]; [2; 9; 4]] 2
 * 11
*)
let max_value (events : int list list) (k : int) : int =","  0","let () =
  assert (max_value [[1; 5; 4]; [11; 15; 1]; [8; 10; 2]; [2; 11; 6]] 3 = 7);
  assert (max_value [[2; 8; 6]; [4; 9; 10]; [6; 8; 3]] 2 = 10);
  assert (max_value [[1; 5; 3]; [1; 5; 6]; [6; 10; 5]; [2; 9; 4]] 2 = 11);
  assert (max_value [[1; 2; 100]; [2; 3; 200]; [3; 4; 300]; [4; 5; 400]; [5; 6; 500]] 3 = 900);
  assert (max_value [[1; 2; 7]; [2; 3; 10]; [3; 4; 3]; [1; 5; 5]; [6; 7; 1]] 4 = 11);
  assert (max_value [[1; 2; 4]; [3; 5; 1]; [5; 6; 2]; [6; 7; 3]] 3 = 8);
  assert (max_value [[1; 5; 3]; [1; 5; 6]; [6; 10; 5]; [2; 9; 8]] 2 = 11);
;;","hard","hard_099","hard"
"(**Given the head of a linked list, find all the values that appear more than once in the list and d...
 * >>> delete_duplicates_unsorted [2; 1; 1; 2]
 * None
 * >>> delete_duplicates_unsorted [5; 6; 7; 8; 9]
 * [5; 6; 7; 8; 9]
 * >>> delete_duplicates_unsorted [1; 2; 3; 4; 5]
 * [1; 2; 3; 4; 5]
*)
let delete_duplicates_unsorted (head : 'a option) : 'a option =","  None","let () =
  assert (delete_duplicates_unsorted [2; 1; 1; 2] = None);
  assert (delete_duplicates_unsorted [5; 6; 7; 8; 9] = [5; 6; 7; 8; 9]);
  assert (delete_duplicates_unsorted [1; 2; 3; 4; 5] = [1; 2; 3; 4; 5]);
  assert (delete_duplicates_unsorted [5; 4; 3; 2; 1; 1; 2; 3; 4; 5] = None);
  assert (delete_duplicates_unsorted [3; 2; 2; 1; 3; 2; 4] = [1; 4]);
  assert (delete_duplicates_unsorted [1; 1; 1; 1; 1] = None);
  assert (delete_duplicates_unsorted [1; 2; 3; 2] = [1; 3]);
;;","medium","medium_078","medium"
"(**You are given an integer array nums and an integer k. You want to find a subsequence of nums of l...
 * >>> max_subsequence [5; 3; 1; 2; 4] 5
 * [5; 3; 1; 2; 4]
 * >>> max_subsequence [10; 10; 10; 10; 10] 3
 * [10; 10; 10]
 * >>> max_subsequence [0; 0; 0; 0] 2
 * [0; 0]
*)
let max_subsequence (nums : int list) (k : int) : int list =","  []","let () =
  assert (max_subsequence [5; 3; 1; 2; 4] 5 = [5; 3; 1; 2; 4]);
  assert (max_subsequence [10; 10; 10; 10; 10] 3 = [10; 10; 10]);
  assert (max_subsequence [0; 0; 0; 0] 2 = [0; 0]);
  assert (max_subsequence [-1; -2; 3; 4] 3 = [-1; 3; 4]);
  assert (max_subsequence [1; 2; 3; 4; 5] 3 = [3; 4; 5]);
  assert (max_subsequence [5; 1; 2; 3; 4] 3 = [5; 3; 4]);
  assert (max_subsequence [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 5 = [6; 7; 8; 9; 10]);
;;","easy","easy_170","easy"
"(**Given a binary string s and a positive integer n, return true if the binary representation of all...
 * >>> query_string ""0110"" 3
 * true
 * >>> query_string ""1111111111"" 10
 * false
 * >>> query_string ""0000000000"" 1
 * false
*)
let query_string (s : string) (n : int) : bool =","  false","let () =
  assert (query_string ""0110"" 3 = true);
  assert (query_string ""1111111111"" 10 = false);
  assert (query_string ""0000000000"" 1 = false);
  assert (query_string ""0110"" 4 = false);
  assert (query_string ""000000"" 1 = false);
  assert (query_string ""101010"" 5 = false);
  assert (query_string ""0000000000"" 2 = false);
;;","medium","medium_009","medium"
"(**Given a (0-indexed) integer array nums and two integers low and high, return the number of nice p...
 * >>> count_pairs [1; 3; 5; 7; 9] 1 10
 * 8
 * >>> count_pairs [2; 3; 4; 5; 6; 7; 8; 9] 3 7
 * 10
 * >>> count_pairs [10; 20; 30; 40; 50] 15 25
 * 1
*)
let count_pairs (nums : int list) (low : int) (high : int) : int =","  0","let () =
  assert (count_pairs [1; 3; 5; 7; 9] 1 10 = 8);
  assert (count_pairs [2; 3; 4; 5; 6; 7; 8; 9] 3 7 = 10);
  assert (count_pairs [10; 20; 30; 40; 50] 15 25 = 1);
  assert (count_pairs [9; 8; 4; 2; 1] 5 14 = 8);
  assert (count_pairs [1; 4; 2; 7] 2 6 = 6);
  assert (count_pairs [5000; 10000; 15000; 20000; 25000; 30000; 35000; 40000] 5000 15000 = 6);
  assert (count_pairs [123; 456; 789; 101112; 131415; 161718; 192021; 222324] 1000 20000 = 1);
;;","hard","hard_060","hard"
"(**Given a string s and a character c that occurs in s, return an array of integers answer where ans...
 * >>> shortest_to_char ""abba"" ""a""
 * [0; 1; 1; 0]
 * >>> shortest_to_char ""loveleetcode"" ""e""
 * [3; 2; 1; 0; 1; 0; 0; 1; 2; 2; 1; 0]
 * >>> shortest_to_char ""abcde"" ""e""
 * [4; 3; 2; 1; 0]
*)
let shortest_to_char (s : string) (c : string) : int list =","  []","let () =
  assert (shortest_to_char ""abba"" ""a"" = [0; 1; 1; 0]);
  assert (shortest_to_char ""loveleetcode"" ""e"" = [3; 2; 1; 0; 1; 0; 0; 1; 2; 2; 1; 0]);
  assert (shortest_to_char ""abcde"" ""e"" = [4; 3; 2; 1; 0]);
  assert (shortest_to_char ""abcabcabc"" ""b"" = [1; 0; 1; 1; 0; 1; 1; 0; 1]);
  assert (shortest_to_char ""abcdabcabcde"" ""c"" = [2; 1; 0; 1; 2; 1; 0; 1; 1; 0; 1; 2]);
  assert (shortest_to_char ""eccdccccdcccdcced"" ""e"" = [0; 1; 2; 3; 4; 5; 6; 7; 7; 6; 5; 4; 3; 2; 1; 0; 1]);
  assert (shortest_to_char ""abcdabc"" ""a"" = [0; 1; 2; 1; 0; 1; 2]);
;;","easy","easy_033","easy"
"(**You are given a 2D binary array grid. You need to find 3 non-overlapping rectangles having non-ze...
 * >>> minimum_sum [[1; 0; 1; 0]; [0; 1; 0; 1]]
 * 5
 * >>> minimum_sum [[1; 1; 0; 0; 1]; [1; 1; 0; 0; 1]; [0; 0; 1; 1; 0]; [0; 0; 1; 1; 0]]
 * 10
 * >>> minimum_sum [[1; 0; 0; 0; 1]; [0; 1; 1; 0; 0]; [0; 1; 1; 0; 0]; [1; 0; 0; 1; 0]]
 * 13
*)
let minimum_sum (grid : int list list) : int =","  0","let () =
  assert (minimum_sum [[1; 0; 1; 0]; [0; 1; 0; 1]] = 5);
  assert (minimum_sum [[1; 1; 0; 0; 1]; [1; 1; 0; 0; 1]; [0; 0; 1; 1; 0]; [0; 0; 1; 1; 0]] = 10);
  assert (minimum_sum [[1; 0; 0; 0; 1]; [0; 1; 1; 0; 0]; [0; 1; 1; 0; 0]; [1; 0; 0; 1; 0]] = 13);
  assert (minimum_sum [[1; 0; 0; 1]; [0; 1; 1; 0]; [0; 1; 1; 0]; [1; 0; 0; 1]] = 12);
  assert (minimum_sum [[1; 0; 1]; [1; 1; 1]] = 5);
  assert (minimum_sum [[1; 1; 1; 0; 0]; [1; 1; 1; 0; 0]; [0; 0; 0; 1; 1]; [0; 0; 0; 1; 1]; [0; 0; 0; 1; 1]] = 12);
  assert (minimum_sum [[1; 0; 0; 1; 0; 0; 1]; [0; 1; 1; 0; 0; 1; 0]; [0; 1; 1; 0; 0; 1; 0]; [1; 0; 0; 1; 0; 0; 1]; [0; 0; 0; 0; 1; 0; 0]] = 25);
;;","hard","hard_095","hard"
"(**You are given an integer array nums, an integer array queries, and an integer x.
 * >>> occurrences_of_element [1; 1; 1; 1; 1; 1; 1; 1; 1; 1] [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11] 1
 * [0; 1; 2; 3; 4; 5; 6; 7; 8; 9; -1]
 * >>> occurrences_of_element [3; 2; 1] [1; 1; 1] 3
 * [0; 0; 0]
 * >>> occurrences_of_element [1; 2; 3; 4; 5] [1; 1; 1; 1; 1] 3
 * [2; 2; 2; 2; 2]
*)
let occurrences_of_element (nums : int list) (queries : int list) (x : int) : int list =","  []","let () =
  assert (occurrences_of_element [1; 1; 1; 1; 1; 1; 1; 1; 1; 1] [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11] 1 = [0; 1; 2; 3; 4; 5; 6; 7; 8; 9; -1]);
  assert (occurrences_of_element [3; 2; 1] [1; 1; 1] 3 = [0; 0; 0]);
  assert (occurrences_of_element [1; 2; 3; 4; 5] [1; 1; 1; 1; 1] 3 = [2; 2; 2; 2; 2]);
  assert (occurrences_of_element [1; 1; 2; 2; 3; 3; 4; 4; 5; 5] [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 1 = [0; 1; -1; -1; -1; -1; -1; -1; -1; -1]);
  assert (occurrences_of_element [5; 3; 5; 3; 5] [1; 2; 3; 4; 5; 6] 5 = [0; 2; 4; -1; -1; -1]);
  assert (occurrences_of_element [10; 20; 30; 40; 50] [1; 2; 3; 4; 5] 10 = [0; -1; -1; -1; -1]);
  assert (occurrences_of_element [1; 2; 3; 4; 5] [1; 1; 1; 1; 1] 6 = [-1; -1; -1; -1; -1]);
;;","medium","medium_162","medium"
"(**An ugly number is a positive integer which does not have a prime factor other than 2, 3, and 5.
 * >>> is_ugly 0
 * false
 * >>> is_ugly 8
 * true
 * >>> is_ugly -2147483648
 * false
*)
let is_ugly (n : int) : bool =","  false","let () =
  assert (is_ugly 0 = false);
  assert (is_ugly 8 = true);
  assert (is_ugly -2147483648 = false);
  assert (is_ugly 100000 = true);
  assert (is_ugly 100 = true);
  assert (is_ugly 30 = true);
  assert (is_ugly -1 = false);
;;","easy","easy_079","easy"
"(**You are given a string road, consisting only of characters ""x"" and ""."", where each ""x"" denotes a ...
 * >>> max_potholes ""xxxx"" 6
 * 4
 * >>> max_potholes "".."" 5
 * 0
 * >>> max_potholes ""x.x.xxx...x"" 14
 * 6
*)
let max_potholes (road : string) (budget : int) : int =","  0","let () =
  assert (max_potholes ""xxxx"" 6 = 4);
  assert (max_potholes "".."" 5 = 0);
  assert (max_potholes ""x.x.xxx...x"" 14 = 6);
  assert (max_potholes ""xxxx.xxxx"" 12 = 8);
  assert (max_potholes ""xx.xx.xx.xx"" 15 = 8);
  assert (max_potholes ""x"" 2 = 1);
  assert (max_potholes ""x.x.x.x"" 6 = 3);
;;","medium","medium_156","medium"
"(**Run-length encoding is a string compression method that works by replacing consecutive identical ...
 * >>> get_length_of_optimal_compression ""abcabcabc"" 5
 * 3
 * >>> get_length_of_optimal_compression ""aaabcccd"" 2
 * 4
 * >>> get_length_of_optimal_compression ""aabcc"" 1
 * 4
*)
let get_length_of_optimal_compression (s : string) (k : int) : int =","  0","let () =
  assert (get_length_of_optimal_compression ""abcabcabc"" 5 = 3);
  assert (get_length_of_optimal_compression ""aaabcccd"" 2 = 4);
  assert (get_length_of_optimal_compression ""aabcc"" 1 = 4);
  assert (get_length_of_optimal_compression ""aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz"" 20 = 32);
  assert (get_length_of_optimal_compression ""aabccabcc"" 2 = 5);
  assert (get_length_of_optimal_compression ""nnnhoorq"" 2 = 5);
  assert (get_length_of_optimal_compression ""aaaaaaaaaaa"" 0 = 3);
;;","hard","hard_053","hard"
"(**You are given an integer n representing the number of players in a game and a 2D array pick where...
 * >>> winning_player_count 10 [[0; 0]; [1; 1]; [1; 1]; [2; 2]; [2; 2]; [2; 2]; [3; 3]; [3; 3]; [3; 3]; [3; 3]]
 * 4
 * >>> winning_player_count 10 [[0; 1]; [1; 2]; [2; 3]; [3; 4]; [4; 5]; [5; 6]; [6; 7]; [7; 8]; [8; 9]; [9; 10]]
 * 1
 * >>> winning_player_count 3 [[0; 0]; [1; 0]; [1; 0]; [1; 0]]
 * 2
*)
let winning_player_count (n : int) (pick : int list list) : int =","  0","let () =
  assert (winning_player_count 10 [[0; 0]; [1; 1]; [1; 1]; [2; 2]; [2; 2]; [2; 2]; [3; 3]; [3; 3]; [3; 3]; [3; 3]] = 4);
  assert (winning_player_count 10 [[0; 1]; [1; 2]; [2; 3]; [3; 4]; [4; 5]; [5; 6]; [6; 7]; [7; 8]; [8; 9]; [9; 10]] = 1);
  assert (winning_player_count 3 [[0; 0]; [1; 0]; [1; 0]; [1; 0]] = 2);
  assert (winning_player_count 5 [[1; 1]; [2; 4]; [2; 4]; [2; 4]] = 1);
  assert (winning_player_count 2 [[0; 0]; [1; 1]; [1; 1]] = 2);
  assert (winning_player_count 5 [[1; 1]; [1; 2]; [1; 3]; [1; 4]] = 0);
  assert (winning_player_count 2 [[0; 0]; [1; 0]; [1; 0]; [1; 0]] = 2);
;;","easy","easy_119","easy"
"(**You are given an m x n integer grid accounts where accounts[i][j] is the amount of money the i​​​...
 * >>> maximum_wealth [[10; 20; 30]; [1; 2; 3]; [100; 200; 300]]
 * 600
 * >>> maximum_wealth [[10; 10]; [20; 20]; [30; 30]; [40; 40]]
 * 80
 * >>> maximum_wealth [[100; 100]; [50; 50; 50; 50]]
 * 200
*)
let maximum_wealth (accounts : int list list) : int =","  0","let () =
  assert (maximum_wealth [[10; 20; 30]; [1; 2; 3]; [100; 200; 300]] = 600);
  assert (maximum_wealth [[10; 10]; [20; 20]; [30; 30]; [40; 40]] = 80);
  assert (maximum_wealth [[100; 100]; [50; 50; 50; 50]] = 200);
  assert (maximum_wealth [[100]; [100]; [100]] = 100);
  assert (maximum_wealth [[5; 5; 5]; [15]; [10; 10]] = 20);
  assert (maximum_wealth [[10; 20; 30]; [5; 15; 25]; [1; 2; 3]] = 60);
  assert (maximum_wealth [[1; 1; 1]; [1; 1; 1]; [1; 1; 1]] = 3);
;;","easy","easy_078","easy"
"(**You are given a 0-indexed integer array nums and an integer threshold.
 * >>> longest_alternating_subarray [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 10
 * 9
 * >>> longest_alternating_subarray [2; 1; 2; 1; 2; 1; 2; 1; 2; 1] 2
 * 10
 * >>> longest_alternating_subarray [2; 3; 4; 5] 4
 * 3
*)
let longest_alternating_subarray (nums : int list) (threshold : int) : int =","  0","let () =
  assert (longest_alternating_subarray [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 10 = 9);
  assert (longest_alternating_subarray [2; 1; 2; 1; 2; 1; 2; 1; 2; 1] 2 = 10);
  assert (longest_alternating_subarray [2; 3; 4; 5] 4 = 3);
  assert (longest_alternating_subarray [6; 1; 3; 8; 2; 9] 8 = 2);
  assert (longest_alternating_subarray [50; 51; 50; 51; 50] 51 = 5);
  assert (longest_alternating_subarray [1] 1 = 0);
  assert (longest_alternating_subarray [3; 2; 5; 4] 5 = 3);
;;","easy","easy_071","easy"
"(**You are given a string s. Reorder the string using the following algorithm:
 * >>> sort_string ""rqy""
 * qry
 * >>> sort_string ""fuvofn""
 * fnouvf
 * >>> sort_string ""abcdefghijklmnopqrstuvwxyz""
 * abcdefghijklmnopqrstuvwxyz
*)
let sort_string (s : string) : string =","  """"","let () =
  assert (sort_string ""rqy"" = qry);
  assert (sort_string ""fuvofn"" = fnouvf);
  assert (sort_string ""abcdefghijklmnopqrstuvwxyz"" = abcdefghijklmnopqrstuvwxyz);
  assert (sort_string ""vibhu"" = bhiuv);
  assert (sort_string ""xyyzz"" = xyzzy);
  assert (sort_string ""ijkpqxz"" = ijkpqxz);
  assert (sort_string ""hfnmwy"" = fhmnwy);
;;","easy","easy_042","easy"
"(**Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the val...
 * >>> reverse -2147483412
 * -2143847412
 * >>> reverse 2147483647
 * 0
 * >>> reverse 120
 * 21
*)
let reverse (x : int) : int =","  0","let () =
  assert (reverse -2147483412 = -2143847412);
  assert (reverse 2147483647 = 0);
  assert (reverse 120 = 21);
  assert (reverse -123 = -321);
  assert (reverse 1534236469 = 0);
  assert (reverse 0 = 0);
  assert (reverse -2147483648 = 0);
;;","medium","medium_077","medium"
"(**Given a positive integer n, return the smallest positive integer that is a multiple of both 2 and n.
 * >>> smallest_even_multiple 3
 * 6
 * >>> smallest_even_multiple 100
 * 100
 * >>> smallest_even_multiple 33
 * 66
*)
let smallest_even_multiple (n : int) : int =","  0","let () =
  assert (smallest_even_multiple 3 = 6);
  assert (smallest_even_multiple 100 = 100);
  assert (smallest_even_multiple 33 = 66);
  assert (smallest_even_multiple 75 = 150);
  assert (smallest_even_multiple 6 = 6);
  assert (smallest_even_multiple 2 = 2);
  assert (smallest_even_multiple 1 = 2);
;;","easy","easy_164","easy"
"(**There are n cars traveling at different speeds in the same direction along a one-lane road. You a...
 * >>> get_collision_times [[1; 4]; [2; 3]; [3; 2]; [4; 1]]
 * [1.0; 1.0; 1.0; -1]
 * >>> get_collision_times [[1; 5]; [3; 2]; [5; 1]]
 * [0.6666666666666666; 2.0; -1]
 * >>> get_collision_times [[1; 1]; [2; 2]; [3; 3]; [4; 4]; [5; 5]]
 * [-1; -1; -1; -1; -1]
*)
let get_collision_times (cars : int list list) : float list =","  []","let () =
  assert (get_collision_times [[1; 4]; [2; 3]; [3; 2]; [4; 1]] = [1.0; 1.0; 1.0; -1]);
  assert (get_collision_times [[1; 5]; [3; 2]; [5; 1]] = [0.6666666666666666; 2.0; -1]);
  assert (get_collision_times [[1; 1]; [2; 2]; [3; 3]; [4; 4]; [5; 5]] = [-1; -1; -1; -1; -1]);
  assert (get_collision_times [[3; 4]; [5; 4]; [6; 3]; [9; 1]] = [2.0; 1.0; 1.5; -1]);
  assert (get_collision_times [[1; 5]; [2; 6]; [3; 7]; [4; 8]; [5; 9]] = [-1; -1; -1; -1; -1]);
  assert (get_collision_times [[5; 10]; [10; 5]; [15; 2]; [20; 1]] = [1.0; 1.6666666666666667; 5.0; -1]);
  assert (get_collision_times [[1; 10]; [3; 8]; [5; 6]; [7; 4]; [9; 2]] = [1.0; 1.0; 1.0; 1.0; -1]);
;;","hard","hard_080","hard"
"(**Given an integer array nums, return the largest perimeter of a triangle with a non-zero area, for...
 * >>> largest_perimeter [10; 5; 7]
 * 22
 * >>> largest_perimeter [10; 5; 1; 8; 12; 10; 5; 15]
 * 37
 * >>> largest_perimeter [7; 10; 5; 2; 8; 7]
 * 25
*)
let largest_perimeter (nums : int list) : int =","  0","let () =
  assert (largest_perimeter [10; 5; 7] = 22);
  assert (largest_perimeter [10; 5; 1; 8; 12; 10; 5; 15] = 37);
  assert (largest_perimeter [7; 10; 5; 2; 8; 7] = 25);
  assert (largest_perimeter [1; 1; 1; 1] = 3);
  assert (largest_perimeter [1; 1; 1] = 3);
  assert (largest_perimeter [1; 1000000; 1000000] = 2000001);
  assert (largest_perimeter [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = 27);
;;","easy","easy_140","easy"
"(**You are given a string s and a positive integer k.
 * >>> beautiful_substrings ""aeiaaioaaaaeiiiiouuuooououuoiiiuuuuaeiou"" 10
 * 0
 * >>> beautiful_substrings ""aabbcc"" 4
 * 1
 * >>> beautiful_substrings ""zzzzz"" 1
 * 0
*)
let beautiful_substrings (s : string) (k : int) : int =","  0","let () =
  assert (beautiful_substrings ""aeiaaioaaaaeiiiiouuuooououuoiiiuuuuaeiou"" 10 = 0);
  assert (beautiful_substrings ""aabbcc"" 4 = 1);
  assert (beautiful_substrings ""zzzzz"" 1 = 0);
  assert (beautiful_substrings """" 1 = 0);
  assert (beautiful_substrings ""baeyh"" 2 = 2);
  assert (beautiful_substrings ""bbaeaeaaeiou"" 3 = 0);
  assert (beautiful_substrings ""bcdf"" 1 = 0);
;;","hard","hard_076","hard"
"(**You are given a 0-indexed integer array nums. A pair of indices i, j where 0 <= i < j < nums.leng...
 * >>> count_beautiful_pairs [100; 200; 300; 400]
 * 3
 * >>> count_beautiful_pairs [34; 23; 12; 45; 56]
 * 5
 * >>> count_beautiful_pairs [33; 14; 25; 78]
 * 5
*)
let count_beautiful_pairs (nums : int list) : int =","  0","let () =
  assert (count_beautiful_pairs [100; 200; 300; 400] = 3);
  assert (count_beautiful_pairs [34; 23; 12; 45; 56] = 5);
  assert (count_beautiful_pairs [33; 14; 25; 78] = 5);
  assert (count_beautiful_pairs [123; 456; 789; 101; 202] = 9);
  assert (count_beautiful_pairs [13; 31; 17; 71] = 6);
  assert (count_beautiful_pairs [78; 89; 90; 12] = 3);
  assert (count_beautiful_pairs [111; 222; 333; 444] = 5);
;;","easy","easy_147","easy"
"(**Given an m x n matrix mat, return an array of all the elements of the array in a diagonal order.
 * >>> find_diagonal_order [[1; 2]; [3; 4]]
 * [1; 2; 3; 4]
 * >>> find_diagonal_order [[1]]
 * [1]
 * >>> find_diagonal_order [[1; 2; 3; 4]; [5; 6; 7; 8]; [9; 10; 11; 12]]
 * [1; 2; 5; 9; 6; 3; 4; 7; 10; 11; 8; 12]
*)
let find_diagonal_order (mat : int list list) : int list =","  []","let () =
  assert (find_diagonal_order [[1; 2]; [3; 4]] = [1; 2; 3; 4]);
  assert (find_diagonal_order [[1]] = [1]);
  assert (find_diagonal_order [[1; 2; 3; 4]; [5; 6; 7; 8]; [9; 10; 11; 12]] = [1; 2; 5; 9; 6; 3; 4; 7; 10; 11; 8; 12]);
  assert (find_diagonal_order [[1; 2; 3]; [4; 5; 6]; [7; 8; 9]] = [1; 2; 4; 7; 5; 3; 6; 8; 9]);
  assert (find_diagonal_order [[1; 2; 3; 4; 5]; [6; 7; 8; 9; 10]; [11; 12; 13; 14; 15]; [16; 17; 18; 19; 20]] = [1; 2; 6; 11; 7; 3; 4; 8; 12; 16; 17; 13; 9; 5; 10; 14; 18; 19; 15; 20]);
  assert (find_diagonal_order [[1; 3; 5; 7]; [10; 11; 16; 20]; [23; 30; 34; 60]] = [1; 3; 10; 23; 11; 5; 7; 16; 30; 34; 20; 60]);
  assert (find_diagonal_order [[10000; 9999; 9998]; [9997; 9996; 9995]; [9994; 9993; 9992]; [9991; 9990; 9989]] = [10000; 9999; 9997; 9994; 9996; 9998; 9995; 9993; 9991; 9990; 9992; 9989]);
;;","medium","medium_166","medium"
"(**You are given a 0-indexed string s that has lowercase English letters in its even indices and dig...
 * >>> replace_digits ""x1y2z3a4b5c6d7e8f9g0""
 * xyy{z}aebgcidkemfogg
 * >>> replace_digits ""x5y5z5""
 * x}y~z
 * >>> replace_digits ""a9b8c7d6e5f4g3h2i1j0""
 * ajbjcjdjejfjgjhjijjj
*)
let replace_digits (s : string) : string =","  """"","let () =
  assert (replace_digits ""x1y2z3a4b5c6d7e8f9g0"" = xyy{z}aebgcidkemfogg);
  assert (replace_digits ""x5y5z5"" = x}y~z);
  assert (replace_digits ""a9b8c7d6e5f4g3h2i1j0"" = ajbjcjdjejfjgjhjijjj);
  assert (replace_digits ""a9b9c9d9"" = ajbkcldm);
  assert (replace_digits ""z0y0x0w0"" = zzyyxxww);
  assert (replace_digits ""a0b0c0d0"" = aabbccdd);
  assert (replace_digits ""m9l8k7j6"" = mvltkrjp);
;;","easy","easy_040","easy"
"(**You are given a positive integer n.
 * >>> smallest_value 3
 * 3
 * >>> smallest_value 15
 * 5
 * >>> smallest_value 100
 * 5
*)
let smallest_value (n : int) : int =","  0","let () =
  assert (smallest_value 3 = 3);
  assert (smallest_value 15 = 5);
  assert (smallest_value 100 = 5);
  assert (smallest_value 44 = 5);
  assert (smallest_value 28 = 11);
  assert (smallest_value 97 = 97);
  assert (smallest_value 99999 = 31);
;;","medium","medium_026","medium"
"(**Given a m x n binary matrix mat, find the 0-indexed position of the row that contains the maximum...
 * >>> row_and_maximum_ones [[0; 1]; [1; 0]]
 * [0; 1]
 * >>> row_and_maximum_ones [[1; 1; 1]; [0; 1; 1]; [1; 0; 0]]
 * [0; 3]
 * >>> row_and_maximum_ones [[1; 1; 1; 0]; [0; 1; 1; 1]; [1; 1; 1; 1]; [0; 0; 1; 1]]
 * [2; 4]
*)
let row_and_maximum_ones (mat : int list list) : int list =","  []","let () =
  assert (row_and_maximum_ones [[0; 1]; [1; 0]] = [0; 1]);
  assert (row_and_maximum_ones [[1; 1; 1]; [0; 1; 1]; [1; 0; 0]] = [0; 3]);
  assert (row_and_maximum_ones [[1; 1; 1; 0]; [0; 1; 1; 1]; [1; 1; 1; 1]; [0; 0; 1; 1]] = [2; 4]);
  assert (row_and_maximum_ones [[0; 0; 0]; [0; 1; 1]] = [1; 2]);
  assert (row_and_maximum_ones [[0; 0; 0; 0]; [0; 0; 0; 0]; [1; 0; 0; 0]] = [2; 1]);
  assert (row_and_maximum_ones [[0; 0; 0; 0]; [0; 0; 0; 0]; [0; 0; 0; 0]; [0; 0; 0; 0]] = [0; 0]);
  assert (row_and_maximum_ones [[0; 0]; [1; 1]; [0; 0]] = [1; 2]);
;;","easy","easy_141","easy"
"(**You are given a 0-indexed integer array nums. A pair of integers x and y is called a strong pair ...
 * >>> maximum_strong_pair_xor [15; 25; 35; 45; 55]
 * 58
 * >>> maximum_strong_pair_xor [2; 4; 6; 8; 10; 12]
 * 14
 * >>> maximum_strong_pair_xor [1; 1; 1; 1]
 * 0
*)
let maximum_strong_pair_xor (nums : int list) : int =","  0","let () =
  assert (maximum_strong_pair_xor [15; 25; 35; 45; 55] = 58);
  assert (maximum_strong_pair_xor [2; 4; 6; 8; 10; 12] = 14);
  assert (maximum_strong_pair_xor [1; 1; 1; 1] = 0);
  assert (maximum_strong_pair_xor [1; 2; 4; 8; 16] = 24);
  assert (maximum_strong_pair_xor [2; 2; 4; 4; 6; 6] = 6);
  assert (maximum_strong_pair_xor [3; 5; 7; 9; 11] = 14);
  assert (maximum_strong_pair_xor [99; 98; 97; 96; 95] = 63);
;;","easy","easy_123","easy"
"(**You are given an integer n. We say that two integers x and y form a prime number pair if:
 * >>> find_prime_pairs 11
 * []
 * >>> find_prime_pairs 1000000
 * Execution timed out
 * >>> find_prime_pairs 20
 * [[3; 17]; [7; 13]]
*)
let find_prime_pairs (n : int) : int list list =","  [[]]","let () =
  assert (find_prime_pairs 11 = []);
  assert (find_prime_pairs 1000000 = Execution timed out);
  assert (find_prime_pairs 20 = [[3; 17]; [7; 13]]);
  assert (find_prime_pairs 2 = []);
  assert (find_prime_pairs 10 = [[3; 7]; [5; 5]]);
  assert (find_prime_pairs 3 = []);
  assert (find_prime_pairs 29 = []);
;;","medium","medium_121","medium"
"(**Given a binary string s, you can split s into 3 non-empty strings s1, s2, and s3 where s1 + s2 + ...
 * >>> num_ways ""101010101""
 * 0
 * >>> num_ways ""10101010101""
 * 4
 * >>> num_ways ""0000""
 * 3
*)
let num_ways (s : string) : int =","  0","let () =
  assert (num_ways ""101010101"" = 0);
  assert (num_ways ""10101010101"" = 4);
  assert (num_ways ""0000"" = 3);
  assert (num_ways ""0000000"" = 15);
  assert (num_ways ""010101010"" = 0);
  assert (num_ways ""111000"" = 1);
  assert (num_ways ""11111111111"" = 0);
;;","medium","medium_049","medium"
"(**Given an integer array nums, find the subarray with the largest sum, and return its sum.
 * >>> max_sub_array [0; 1; 2; 3; 4; 5]
 * 15
 * >>> max_sub_array [-2; 1; -3; 4; -1; 2; 1; -5; 4; 7]
 * 12
 * >>> max_sub_array [10000; -10000; 10000; -10000; 10000]
 * 10000
*)
let max_sub_array (nums : int list) : int =","  0","let () =
  assert (max_sub_array [0; 1; 2; 3; 4; 5] = 15);
  assert (max_sub_array [-2; 1; -3; 4; -1; 2; 1; -5; 4; 7] = 12);
  assert (max_sub_array [10000; -10000; 10000; -10000; 10000] = 10000);
  assert (max_sub_array [100; -1; 50; -1; 100] = 248);
  assert (max_sub_array [0; -3; 5; -2; 1; 3; -1; 2; -4; 2] = 8);
  assert (max_sub_array [1] = 1);
  assert (max_sub_array [0; -3; 5; -2; 1; 3; -1; 2; -4; 2; 3] = 9);
;;","medium","medium_067","medium"
"(**Given a string s, encode the string such that its encoded length is the shortest.
 * >>> encode ""abcdabcdabcdabcdabcdabcdabcdabc""
 * abc7[dabc]
 * >>> encode ""abcabcabcabcabcabcabc""
 * 7[abc]
 * >>> encode ""xyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxy""
 * 21[xy]
*)
let encode (s : string) : string =","  """"","let () =
  assert (encode ""abcdabcdabcdabcdabcdabcdabcdabc"" = abc7[dabc]);
  assert (encode ""abcabcabcabcabcabcabc"" = 7[abc]);
  assert (encode ""xyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxy"" = 21[xy]);
  assert (encode ""abbbabbbcabbbabbbc"" = 2[2[abbb]c]);
  assert (encode ""aabcaabcd"" = 2[aabc]d);
  assert (encode ""abcdef"" = abcdef);
  assert (encode ""zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz"" = 44[z]);
;;","hard","hard_044","hard"
"(**There are several consecutive houses along a street, each of which has some money inside. There i...
 * >>> min_capability [1; 2; 3; 4; 5] 3
 * 5
 * >>> min_capability [10; 9; 8; 7; 6; 5; 4; 3; 2; 1] 5
 * 9
 * >>> min_capability [10; 1; 1; 10; 1; 1; 10] 3
 * 10
*)
let min_capability (nums : int list) (k : int) : int =","  0","let () =
  assert (min_capability [1; 2; 3; 4; 5] 3 = 5);
  assert (min_capability [10; 9; 8; 7; 6; 5; 4; 3; 2; 1] 5 = 9);
  assert (min_capability [10; 1; 1; 10; 1; 1; 10] 3 = 10);
  assert (min_capability [5; 5; 5; 5; 5; 5; 5; 5; 5; 5] 4 = 5);
  assert (min_capability [10; 20; 30; 40; 50] 1 = 10);
  assert (min_capability [5; 3; 1; 1; 2; 3] 2 = 2);
  assert (min_capability [5; 5; 5; 5; 5; 5; 5; 5; 5; 5] 5 = 5);
;;","medium","medium_193","medium"
"(**Given a string s which consists of lowercase or uppercase letters, return the length of the longe...
 * >>> longest_palindrome ""aabbccc""
 * 7
 * >>> longest_palindrome ""abccccdd""
 * 7
 * >>> longest_palindrome ""zyyzzzzz""
 * 8
*)
let longest_palindrome (s : string) : int =","  0","let () =
  assert (longest_palindrome ""aabbccc"" = 7);
  assert (longest_palindrome ""abccccdd"" = 7);
  assert (longest_palindrome ""zyyzzzzz"" = 8);
  assert (longest_palindrome ""abcdedcba"" = 9);
  assert (longest_palindrome ""aabbbb"" = 6);
  assert (longest_palindrome ""aaaaa"" = 5);
  assert (longest_palindrome ""aabbccddee"" = 10);
;;","easy","easy_142","easy"
"(**A magician has various spells.
 * >>> maximum_total_damage [5; 5; 5; 5; 5]
 * 25
 * >>> maximum_total_damage [1; 10; 19; 28; 37; 46; 55; 64; 73; 82; 91]
 * 506
 * >>> maximum_total_damage [5; 3; 8; 9; 2]
 * 16
*)
let maximum_total_damage (power : int list) : int =","  0","let () =
  assert (maximum_total_damage [5; 5; 5; 5; 5] = 25);
  assert (maximum_total_damage [1; 10; 19; 28; 37; 46; 55; 64; 73; 82; 91] = 506);
  assert (maximum_total_damage [5; 3; 8; 9; 2] = 16);
  assert (maximum_total_damage [5; 11; 17; 23; 29; 35; 41; 47; 53; 59] = 320);
  assert (maximum_total_damage [1; 3; 5; 7; 9; 11; 13; 15; 17; 19] = 55);
  assert (maximum_total_damage [3; 8; 3; 10; 1; 3; 3; 9; 5] = 22);
  assert (maximum_total_damage [10; 20; 30; 40; 50] = 150);
;;","medium","medium_127","medium"
"(**Your friend is typing his name into a keyboard. Sometimes, when typing a character c, the key mig...
 * >>> is_long_pressed_name ""zzzzzzzz"" ""zzzzzzzz""
 * true
 * >>> is_long_pressed_name ""abcd"" ""abcde""
 * false
 * >>> is_long_pressed_name ""test"" ""ttest""
 * true
*)
let is_long_pressed_name (name : string) (typed : string) : bool =","  false","let () =
  assert (is_long_pressed_name ""zzzzzzzz"" ""zzzzzzzz"" = true);
  assert (is_long_pressed_name ""abcd"" ""abcde"" = false);
  assert (is_long_pressed_name ""test"" ""ttest"" = true);
  assert (is_long_pressed_name ""dfuyalc"" ""fuuyallc"" = false);
  assert (is_long_pressed_name ""zzzyyyyy"" ""zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz"" = false);
  assert (is_long_pressed_name ""abcd"" ""abcddcba"" = false);
  assert (is_long_pressed_name ""alex"" ""aaleexa"" = false);
;;","easy","easy_127","easy"
"(**You are given a 2D array points of size n x 2 representing integer coordinates of some points on ...
 * >>> number_of_pairs [[3; 1]; [1; 3]; [1; 1]]
 * 2
 * >>> number_of_pairs [[1; 1]; [2; 2]; [3; 1]; [1; 3]; [2; 1]; [1; 2]]
 * 6
 * >>> number_of_pairs [[1; 1]; [2; 2]; [1; 2]; [2; 1]]
 * 4
*)
let number_of_pairs (points : int list list) : int =","  0","let () =
  assert (number_of_pairs [[3; 1]; [1; 3]; [1; 1]] = 2);
  assert (number_of_pairs [[1; 1]; [2; 2]; [3; 1]; [1; 3]; [2; 1]; [1; 2]] = 6);
  assert (number_of_pairs [[1; 1]; [2; 2]; [1; 2]; [2; 1]] = 4);
  assert (number_of_pairs [[-1; 5]; [0; 0]; [2; 4]; [4; -2]] = 4);
  assert (number_of_pairs [[1; 1]; [1; 2]; [1; 3]; [1; 4]; [1; 5]] = 4);
  assert (number_of_pairs [[0; 0]; [1; 1]; [2; 0]; [2; 2]; [3; 1]] = 5);
  assert (number_of_pairs [[-1; 1]; [1; -1]; [-2; 2]; [2; -2]] = 3);
;;","hard","hard_045","hard"
"(**You're given strings jewels representing the types of stones that are jewels, and stones represen...
 * >>> num_jewels_in_stones ""aA"" ""aAAbbbb""
 * 3
 * >>> num_jewels_in_stones ""xyz"" ""aabbcc""
 * 0
 * >>> num_jewels_in_stones ""xyz"" """"
 * 0
*)
let num_jewels_in_stones (jewels : string) (stones : string) : int =","  0","let () =
  assert (num_jewels_in_stones ""aA"" ""aAAbbbb"" = 3);
  assert (num_jewels_in_stones ""xyz"" ""aabbcc"" = 0);
  assert (num_jewels_in_stones ""xyz"" """" = 0);
  assert (num_jewels_in_stones ""aA"" """" = 0);
  assert (num_jewels_in_stones ""abcdefg"" ""aghfbadcegf"" = 10);
  assert (num_jewels_in_stones ""abcdefg"" ""aghgfedcba"" = 9);
  assert (num_jewels_in_stones """" ""abcdefg"" = 0);
;;","easy","easy_133","easy"
"(**Given an array of prices [p1,p2...,pn] and a target, round each price pi to Roundi(pi) so that th...
 * >>> minimize_error [""5.500""; ""6.500""; ""7.500""] 18
 * 1.500
 * >>> minimize_error [""1.000""; ""2.000""; ""3.000""] 6
 * 0.000
 * >>> minimize_error [""1.100""; ""1.200""; ""1.300""; ""1.400""] 4
 * 1.000
*)
let minimize_error (prices : string list) (target : int) : string =","  """"","let () =
  assert (minimize_error [""5.500""; ""6.500""; ""7.500""] 18 = 1.500);
  assert (minimize_error [""1.000""; ""2.000""; ""3.000""] 6 = 0.000);
  assert (minimize_error [""1.100""; ""1.200""; ""1.300""; ""1.400""] 4 = 1.000);
  assert (minimize_error [""1.100""; ""1.900""; ""2.100""; ""2.900""] 6 = 2.000);
  assert (minimize_error [""1.999""; ""2.999""; ""3.999""] 8 = 1.001);
  assert (minimize_error [""1.100""; ""1.200""; ""1.300""; ""1.400""] 6 = 1.600);
  assert (minimize_error [""999.999""; ""1000.000""; ""0.001""] 2000 = 0.002);
;;","medium","medium_031","medium"
"(**You are given an array points containing the coordinates of points on a 2D plane, sorted by the x...
 * >>> find_max_value_of_equation [[1; 3]; [2; 0]; [5; 10]; [6; -10]] 1
 * 4
 * >>> find_max_value_of_equation [[100000000; 100000000]; [200000000; 200000000]; [300000000; 300000000]] 100000000
 * 600000000
 * >>> find_max_value_of_equation [[1; 5]; [2; 3]; [4; 7]; [8; 10]] 6
 * 21
*)
let find_max_value_of_equation (points : int list list) (k : int) : int =","  0","let () =
  assert (find_max_value_of_equation [[1; 3]; [2; 0]; [5; 10]; [6; -10]] 1 = 4);
  assert (find_max_value_of_equation [[100000000; 100000000]; [200000000; 200000000]; [300000000; 300000000]] 100000000 = 600000000);
  assert (find_max_value_of_equation [[1; 5]; [2; 3]; [4; 7]; [8; 10]] 6 = 21);
  assert (find_max_value_of_equation [[1; 3]; [2; 0]; [5; 10]; [6; -10]; [7; 5]] 4 = 17);
  assert (find_max_value_of_equation [[-10; -10]; [-5; -5]; [0; 0]; [5; 5]; [10; 10]] 15 = 20);
  assert (find_max_value_of_equation [[1; 1]; [2; 2]; [3; 3]; [4; 4]] 2 = 8);
  assert (find_max_value_of_equation [[-1; 1]; [-2; 2]; [-3; 3]] 1 = 4);
;;","hard","hard_066","hard"
"(**Given an array of positive integers nums and a positive integer target, return the minimal length...
 * >>> min_sub_array_len 8 [1; 2; 3; 4; 5]
 * 2
 * >>> min_sub_array_len 9 [4; 3; 3; 2; 1]
 * 3
 * >>> min_sub_array_len 11 [1; 1; 1; 1; 1; 1; 1; 1]
 * 0
*)
let min_sub_array_len (target : int) (nums : int list) : int =","  0","let () =
  assert (min_sub_array_len 8 [1; 2; 3; 4; 5] = 2);
  assert (min_sub_array_len 9 [4; 3; 3; 2; 1] = 3);
  assert (min_sub_array_len 11 [1; 1; 1; 1; 1; 1; 1; 1] = 0);
  assert (min_sub_array_len 100 [10; 20; 30; 40; 50] = 3);
  assert (min_sub_array_len 8 [2; 2; 2; 2; 2; 2; 2; 2] = 4);
  assert (min_sub_array_len 8 [3; 4; 3; 1; 1; 1; 1; 1] = 3);
  assert (min_sub_array_len 7 [2; 3; 1; 2; 4; 3] = 2);
;;","medium","medium_181","medium"
"(**Given a string s, return the length of the longest substring between two equal characters, exclud...
 * >>> max_length_between_equal_characters ""aabbaa""
 * 4
 * >>> max_length_between_equal_characters ""xyzx""
 * 2
 * >>> max_length_between_equal_characters ""a""
 * -1
*)
let max_length_between_equal_characters (s : string) : int =","  0","let () =
  assert (max_length_between_equal_characters ""aabbaa"" = 4);
  assert (max_length_between_equal_characters ""xyzx"" = 2);
  assert (max_length_between_equal_characters ""a"" = -1);
  assert (max_length_between_equal_characters ""aa"" = 0);
  assert (max_length_between_equal_characters ""abcda"" = 3);
  assert (max_length_between_equal_characters ""abcabc"" = 2);
  assert (max_length_between_equal_characters ""abcdabcd"" = 3);
;;","easy","easy_082","easy"
"(**You are given a 0-indexed binary string s of length n on which you can apply two types of operati...
 * >>> minimum_cost ""100100100""
 * 13
 * >>> minimum_cost ""00000000000000000000000000000000000000000000000000""
 * 0
 * >>> minimum_cost ""110011""
 * 4
*)
let minimum_cost (s : string) : int =","  0","let () =
  assert (minimum_cost ""100100100"" = 13);
  assert (minimum_cost ""00000000000000000000000000000000000000000000000000"" = 0);
  assert (minimum_cost ""110011"" = 4);
  assert (minimum_cost ""11110000"" = 4);
  assert (minimum_cost ""1000100010001"" = 20);
  assert (minimum_cost ""111000"" = 3);
  assert (minimum_cost ""101010101010"" = 36);
;;","medium","medium_029","medium"
"(**Given a m * n matrix of ones and zeros, return how many square submatrices have all ones.
 * >>> count_squares [[1; 0; 1; 0; 1]; [1; 1; 1; 1; 1]; [0; 1; 1; 1; 0]; [1; 1; 1; 1; 1]; [1; 0; 1; 0; 1]]
 * 24
 * >>> count_squares [[1]]
 * 1
 * >>> count_squares [[0]]
 * 0
*)
let count_squares (matrix : int list list) : int =","  0","let () =
  assert (count_squares [[1; 0; 1; 0; 1]; [1; 1; 1; 1; 1]; [0; 1; 1; 1; 0]; [1; 1; 1; 1; 1]; [1; 0; 1; 0; 1]] = 24);
  assert (count_squares [[1]] = 1);
  assert (count_squares [[0]] = 0);
  assert (count_squares [[0; 1; 1; 1]; [1; 1; 1; 1]; [0; 1; 1; 1]] = 15);
  assert (count_squares [[0; 0; 0]; [0; 0; 0]; [0; 0; 0]] = 0);
  assert (count_squares [[1; 0; 1]; [1; 1; 0]; [1; 1; 0]] = 7);
  assert (count_squares [[1; 1; 1]; [1; 1; 1]; [1; 1; 1]] = 14);
;;","medium","medium_081","medium"
"(**You are given a 0-indexed binary string target of length n. You have another binary string s of l...
 * >>> min_flips ""00000""
 * 0
 * >>> min_flips ""00110""
 * 2
 * >>> min_flips ""1100110011""
 * 5
*)
let min_flips (target : string) : int =","  0","let () =
  assert (min_flips ""00000"" = 0);
  assert (min_flips ""00110"" = 2);
  assert (min_flips ""1100110011"" = 5);
  assert (min_flips ""000111000111"" = 3);
  assert (min_flips ""001100"" = 2);
  assert (min_flips ""10001"" = 3);
  assert (min_flips ""010101010101010101"" = 17);
;;","medium","medium_019","medium"
"(**You are given a large sample of integers in the range [0, 255]. Since the sample is so large, it ...
 * >>> sample_stats [0; 1; 3; 4; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0]
 * [1; 3; 2.375; 2.5; 3]
 * >>> sample_stats [0; 1; 3; 4; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0]
 * [1; 3; 2.375; 2.5; 3]
 * >>> sample_stats [0; 1; 3; 4; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0]
 * [1; 3; 2.375; 2.5; 3]
*)
let sample_stats (count : int list) : float list =","  []","let () =
  assert (sample_stats [0; 1; 3; 4; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0] = [1; 3; 2.375; 2.5; 3]);
  assert (sample_stats [0; 1; 3; 4; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0] = [1; 3; 2.375; 2.5; 3]);
  assert (sample_stats [0; 1; 3; 4; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0] = [1; 3; 2.375; 2.5; 3]);
  assert (sample_stats [0; 4; 3; 2; 2; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0] = [1; 4; 2.1818181818181817; 2; 1]);
  assert (sample_stats [0; 4; 3; 2; 2; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0] = [1; 4; 2.1818181818181817; 2; 1]);
  assert (sample_stats [0; 4; 3; 2; 2; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0] = [1; 4; 2.1818181818181817; 2; 1]);
  assert (sample_stats [0; 4; 3; 2; 2; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0] = [1; 4; 2.1818181818181817; 2; 1]);
;;","medium","medium_059","medium"
"(**You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connec...
 * >>> max_area_of_island [[0; 0; 1; 0; 0; 0; 0; 1; 0; 0; 0; 0; 0]; [0; 0; 0; 0; 0; 0; 0; 1; 1; 1; 0; 0; 0]; [0; 1; 1; 0; 1; 0; 0; 0; 0; 0; 0; 0; 0]; [0; 1; 0; 0; 1; 1; 0; 0; 1; 0; 1; 0; 0]; [0; 1; 0; 0; 1; 1; 0; 0; 1; 1; 1; 0; 0]; [0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 1; 0; 0]; [0; 0; 0; 0; 0; 0; 0; 1; 1; 1; 0; 0; 0]; [0; 0; 0; 0; 0; 0; 0; 1; 1; 0; 0; 0; 0]]
 * 6
 * >>> max_area_of_island [[1]]
 * 1
 * >>> max_area_of_island [[0]]
 * 0
*)
let max_area_of_island (grid : int list list) : int =","  0","let () =
  assert (max_area_of_island [[0; 0; 1; 0; 0; 0; 0; 1; 0; 0; 0; 0; 0]; [0; 0; 0; 0; 0; 0; 0; 1; 1; 1; 0; 0; 0]; [0; 1; 1; 0; 1; 0; 0; 0; 0; 0; 0; 0; 0]; [0; 1; 0; 0; 1; 1; 0; 0; 1; 0; 1; 0; 0]; [0; 1; 0; 0; 1; 1; 0; 0; 1; 1; 1; 0; 0]; [0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 1; 0; 0]; [0; 0; 0; 0; 0; 0; 0; 1; 1; 1; 0; 0; 0]; [0; 0; 0; 0; 0; 0; 0; 1; 1; 0; 0; 0; 0]] = 6);
  assert (max_area_of_island [[1]] = 1);
  assert (max_area_of_island [[0]] = 0);
  assert (max_area_of_island [[0; 0; 0; 0; 0; 0; 0; 0]] = 0);
  assert (max_area_of_island [[1; 0; 1; 1; 1]; [1; 0; 1; 0; 1]; [1; 0; 1; 1; 1]; [1; 0; 0; 0; 0]] = 8);
  assert (max_area_of_island [[1; 1; 0; 0; 0]; [1; 1; 0; 0; 0]; [0; 0; 0; 1; 1]; [0; 0; 0; 1; 1]] = 4);
  assert (max_area_of_island [[0; 1; 1; 0; 0; 1; 0; 1; 0; 0; 1; 1; 1; 1; 0]; [1; 0; 0; 1; 1; 1; 1; 1; 1; 0; 0; 0; 0; 1; 0]; [0; 0; 1; 0; 0; 0; 0; 0; 0; 1; 1; 1; 0; 0; 0]; [0; 0; 0; 1; 1; 1; 1; 0; 0; 0; 0; 0; 1; 1; 0]; [1; 1; 0; 0; 0; 1; 0; 1; 1; 0; 0; 1; 0; 0; 0]] = 8);
;;","medium","medium_169","medium"
"(**You are given a 0-indexed integer array nums of size n representing the cost of collecting differ...
 * >>> min_cost [10; 20; 30; 40; 50] 10
 * 90
 * >>> min_cost [10; 20; 30; 40] 10
 * 70
 * >>> min_cost [1; 1; 1; 1; 1] 1
 * 5
*)
let min_cost (nums : int list) (x : int) : int =","  0","let () =
  assert (min_cost [10; 20; 30; 40; 50] 10 = 90);
  assert (min_cost [10; 20; 30; 40] 10 = 70);
  assert (min_cost [1; 1; 1; 1; 1] 1 = 5);
  assert (min_cost [7; 7; 7; 7; 7; 7] 2 = 42);
  assert (min_cost [10; 20; 30; 40; 50] 1 = 54);
  assert (min_cost [3; 1; 2] 3 = 6);
  assert (min_cost [100; 200; 300] 50 = 400);
;;","medium","medium_114","medium"
"(**You are given a 0-indexed binary string floor, which represents the colors of tiles on a floor:
 * >>> minimum_white_tiles ""111100001111"" 4 4
 * 0
 * >>> minimum_white_tiles ""110011"" 3 2
 * 0
 * >>> minimum_white_tiles ""11111"" 2 3
 * 0
*)
let minimum_white_tiles (floor : string) (numCarpets : int) (carpetLen : int) : int =","  0","let () =
  assert (minimum_white_tiles ""111100001111"" 4 4 = 0);
  assert (minimum_white_tiles ""110011"" 3 2 = 0);
  assert (minimum_white_tiles ""11111"" 2 3 = 0);
  assert (minimum_white_tiles ""1010101010"" 5 1 = 0);
  assert (minimum_white_tiles ""11001100"" 3 2 = 0);
  assert (minimum_white_tiles ""11010110"" 3 1 = 2);
  assert (minimum_white_tiles ""10110101"" 2 2 = 2);
;;","hard","hard_097","hard"
"(**Given an array nums and an integer target, return the maximum number of non-empty non-overlapping...
 * >>> max_non_overlapping [5; 5; 5; 5; 5] 10
 * 2
 * >>> max_non_overlapping [1; 2; 3; 4; 5] 9
 * 1
 * >>> max_non_overlapping [-1; 3; 5; 1; 4; 2; -9] 6
 * 2
*)
let max_non_overlapping (nums : int list) (target : int) : int =","  0","let () =
  assert (max_non_overlapping [5; 5; 5; 5; 5] 10 = 2);
  assert (max_non_overlapping [1; 2; 3; 4; 5] 9 = 1);
  assert (max_non_overlapping [-1; 3; 5; 1; 4; 2; -9] 6 = 2);
  assert (max_non_overlapping [5; 5; 5; 5; 5; 5] 15 = 2);
  assert (max_non_overlapping [0; 0; 0; 0; 0] 0 = 5);
  assert (max_non_overlapping [1; -1; 2; -2; 3; -3] 0 = 3);
  assert (max_non_overlapping [1; 1; 1; 1; 1] 2 = 2);
;;","medium","medium_187","medium"
"(**Given an integer array nums, find three numbers whose product is maximum and return the maximum p...
 * >>> maximum_product [-10; -10; 5; 2]
 * 500
 * >>> maximum_product [1; 2; 3; 4]
 * 24
 * >>> maximum_product [1; 0; 1; 0; 1; 0; 99]
 * 99
*)
let maximum_product (nums : int list) : int =","  0","let () =
  assert (maximum_product [-10; -10; 5; 2] = 500);
  assert (maximum_product [1; 2; 3; 4] = 24);
  assert (maximum_product [1; 0; 1; 0; 1; 0; 99] = 99);
  assert (maximum_product [0; 2; 3; 5] = 30);
  assert (maximum_product [0; 2; 3; -1; 5] = 30);
  assert (maximum_product [1; 2; 3] = 6);
  assert (maximum_product [-10; -10; 5; 2] = 500);
;;","easy","easy_163","easy"
"(**You are playing a Flip Game with your friend.
 * >>> can_win ""+-+-+--""
 * false
 * >>> can_win ""-+-""
 * false
 * >>> can_win ""++--""
 * true
*)
let can_win (currentState : string) : bool =","  false","let () =
  assert (can_win ""+-+-+--"" = false);
  assert (can_win ""-+-"" = false);
  assert (can_win ""++--"" = true);
  assert (can_win ""++-++"" = false);
  assert (can_win ""++++"" = true);
  assert (can_win ""+++"" = true);
  assert (can_win ""+++++++"" = true);
;;","medium","medium_105","medium"
"(**You are given a string s of lowercase English letters and an integer array shifts of the same len...
 * >>> shifting_letters ""aaa"" [1; 2; 3]
 * gfd
 * >>> shifting_letters ""abc"" [26; 52; 78]
 * abc
 * >>> shifting_letters ""a"" [25]
 * z
*)
let shifting_letters (s : string) (shifts : int list) : string =","  """"","let () =
  assert (shifting_letters ""aaa"" [1; 2; 3] = gfd);
  assert (shifting_letters ""abc"" [26; 52; 78] = abc);
  assert (shifting_letters ""a"" [25] = z);
  assert (shifting_letters ""abcdef"" [0; 0; 0; 0; 0; 0] = abcdef);
  assert (shifting_letters ""abcd"" [10; 20; 30; 40] = wnur);
  assert (shifting_letters ""abcdefghijklmnopqrstuvwxyz"" [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26] = nnmkhdysldukznamxhqyflquxz);
  assert (shifting_letters ""abcdef"" [1; 2; 3; 4; 5; 6] = vvuspl);
;;","medium","medium_087","medium"
"(**You are given a 0-indexed integer array tasks, where tasks[i] represents the difficulty level of ...
 * >>> minimum_rounds [9; 9; 9; 9; 9; 9; 9; 9; 9; 9; 9; 9; 9; 9; 9]
 * 5
 * >>> minimum_rounds [7; 7; 7; 7; 7; 7; 7; 7; 7; 7; 7; 7; 7]
 * 5
 * >>> minimum_rounds [3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3]
 * 7
*)
let minimum_rounds (tasks : int list) : int =","  0","let () =
  assert (minimum_rounds [9; 9; 9; 9; 9; 9; 9; 9; 9; 9; 9; 9; 9; 9; 9] = 5);
  assert (minimum_rounds [7; 7; 7; 7; 7; 7; 7; 7; 7; 7; 7; 7; 7] = 5);
  assert (minimum_rounds [3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3] = 7);
  assert (minimum_rounds [7; 7; 7; 7; 7; 7; 7; 7; 7; 7; 7; 7; 7; 7; 7; 7; 7; 7; 7; 7] = 7);
  assert (minimum_rounds [10; 10; 10; 10; 10; 10; 10; 10; 10; 10] = 4);
  assert (minimum_rounds [5; 5; 5; 5; 5; 5; 5; 5; 5] = 3);
  assert (minimum_rounds [1; 1; 1; 2; 2; 2; 2; 3; 3; 3; 3; 3] = 5);
;;","medium","medium_072","medium"
"(**Given a string s, remove duplicate letters so that every letter appears once and only once. You m...
 * >>> remove_duplicate_letters ""abcdefghijklmnopqrstuvwxyz""
 * abcdefghijklmnopqrstuvwxyz
 * >>> remove_duplicate_letters ""rumeblidofervobenly""
 * rumbidfevonly
 * >>> remove_duplicate_letters ""thesqtitxyetpxooxlqskyae""
 * heitpoxlqskya
*)
let remove_duplicate_letters (s : string) : string =","  """"","let () =
  assert (remove_duplicate_letters ""abcdefghijklmnopqrstuvwxyz"" = abcdefghijklmnopqrstuvwxyz);
  assert (remove_duplicate_letters ""rumeblidofervobenly"" = rumbidfevonly);
  assert (remove_duplicate_letters ""thesqtitxyetpxooxlqskyae"" = heitpoxlqskya);
  assert (remove_duplicate_letters ""thesqquishs"" = tequihs);
  assert (remove_duplicate_letters ""a"" = a);
  assert (remove_duplicate_letters ""russell"" = rusel);
  assert (remove_duplicate_letters ""cbacdcbc"" = acdb);
;;","medium","medium_142","medium"
"(**You are given an array nums consisting of positive integers and an integer k.
 * >>> count_partitions [10; 20; 30; 40] 50
 * 2
 * >>> count_partitions [1; 1; 1; 1] 2
 * 6
 * >>> count_partitions [2; 4; 6; 8; 10] 11
 * 12
*)
let count_partitions (nums : int list) (k : int) : int =","  0","let () =
  assert (count_partitions [10; 20; 30; 40] 50 = 2);
  assert (count_partitions [1; 1; 1; 1] 2 = 6);
  assert (count_partitions [2; 4; 6; 8; 10] 11 = 12);
  assert (count_partitions [5; 5; 5; 5; 5; 5; 5; 5; 5; 5] 25 = 252);
  assert (count_partitions [6; 6] 2 = 2);
  assert (count_partitions [10; 20; 30; 40; 50] 100 = 0);
  assert (count_partitions [100; 200; 300; 400; 500] 600 = 12);
;;","hard","hard_034","hard"
"(**Given 2n balls of k distinct colors. You will be given an integer array balls of size k where bal...
 * >>> get_probability [6; 6]
 * 1.0
 * >>> get_probability [4; 4; 4; 4]
 * 0.820979020979021
 * >>> get_probability [2; 1; 1]
 * 0.6666666666666666
*)
let get_probability (balls : int list) : float =","  0.0","let () =
  assert (get_probability [6; 6] = 1.0);
  assert (get_probability [4; 4; 4; 4] = 0.820979020979021);
  assert (get_probability [2; 1; 1] = 0.6666666666666666);
  assert (get_probability [1; 2; 2; 2; 2; 2; 2] = 0.8571428571428571);
  assert (get_probability [1; 2; 1; 2] = 0.6);
  assert (get_probability [2; 2; 2; 2] = 1.0);
  assert (get_probability [6; 1] = 0.0);
;;","hard","hard_011","hard"
"(**Given a positive integer num, return true if num is a perfect square or false otherwise.
 * >>> is_perfect_square 14
 * false
 * >>> is_perfect_square 9
 * true
 * >>> is_perfect_square 1000000000
 * false
*)
let is_perfect_square (num : int) : bool =","  false","let () =
  assert (is_perfect_square 14 = false);
  assert (is_perfect_square 9 = true);
  assert (is_perfect_square 1000000000 = false);
  assert (is_perfect_square 49 = true);
  assert (is_perfect_square 50 = false);
  assert (is_perfect_square 25 = true);
  assert (is_perfect_square 0 = false);
;;","easy","easy_069","easy"
"(**You are given a 0-indexed 2D integer array transactions, where transactions[i] = [costi, cashbacki].
 * >>> minimum_money [[1; 2]; [3; 4]; [5; 6]]
 * 5
 * >>> minimum_money [[1; 0]; [2; 0]; [3; 0]]
 * 6
 * >>> minimum_money [[1; 2]; [2; 3]; [3; 4]; [4; 5]]
 * 4
*)
let minimum_money (transactions : int list list) : int =","  0","let () =
  assert (minimum_money [[1; 2]; [3; 4]; [5; 6]] = 5);
  assert (minimum_money [[1; 0]; [2; 0]; [3; 0]] = 6);
  assert (minimum_money [[1; 2]; [2; 3]; [3; 4]; [4; 5]] = 4);
  assert (minimum_money [[0; 0]; [0; 0]; [0; 0]] = 0);
  assert (minimum_money [[7; 3]; [2; 1]; [4; 4]] = 9);
  assert (minimum_money [[2; 1]; [5; 0]; [4; 2]] = 10);
  assert (minimum_money [[0; 0]; [1; 1]; [2; 2]] = 2);
;;","hard","hard_061","hard"
"(**A string is good if there are no repeated characters.
 * >>> count_good_substrings ""xyzxyzxyz""
 * 7
 * >>> count_good_substrings ""abcabcabc""
 * 7
 * >>> count_good_substrings ""xyzzaz""
 * 1
*)
let count_good_substrings (s : string) : int =","  0","let () =
  assert (count_good_substrings ""xyzxyzxyz"" = 7);
  assert (count_good_substrings ""abcabcabc"" = 7);
  assert (count_good_substrings ""xyzzaz"" = 1);
  assert (count_good_substrings ""aabbcc"" = 0);
  assert (count_good_substrings ""abacab"" = 2);
  assert (count_good_substrings ""qqqppprrr"" = 0);
  assert (count_good_substrings ""abac"" = 1);
;;","easy","easy_063","easy"
"(**We are given a list nums of integers representing a list compressed with run-length encoding.
 * >>> decompress_rlelist [1; 9; 2; 8; 3; 7]
 * [9; 8; 8; 7; 7; 7]
 * >>> decompress_rlelist [3; 1; 2; 2]
 * [1; 1; 1; 2; 2]
 * >>> decompress_rlelist [2; 5; 3; 1]
 * [5; 5; 1; 1; 1]
*)
let decompress_rlelist (nums : int list) : int list =","  []","let () =
  assert (decompress_rlelist [1; 9; 2; 8; 3; 7] = [9; 8; 8; 7; 7; 7]);
  assert (decompress_rlelist [3; 1; 2; 2] = [1; 1; 1; 2; 2]);
  assert (decompress_rlelist [2; 5; 3; 1] = [5; 5; 1; 1; 1]);
  assert (decompress_rlelist [1; 2; 3; 4] = [2; 4; 4; 4]);
  assert (decompress_rlelist [2; 5; 3; 7] = [5; 5; 7; 7; 7]);
  assert (decompress_rlelist [2; 5; 3; 6] = [5; 5; 6; 6; 6]);
  assert (decompress_rlelist [10; 1; 5; 2] = [1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 2; 2; 2; 2; 2]);
;;","easy","easy_128","easy"
"(**You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connec...
 * >>> num_distinct_islands [[1; 1; 0; 0; 1]; [1; 0; 0; 0; 0]; [0; 0; 1; 1; 0]; [0; 0; 1; 0; 0]]
 * 2
 * >>> num_distinct_islands [[1; 0; 0; 0; 0]; [0; 0; 0; 0; 0]; [0; 0; 0; 0; 0]; [0; 0; 0; 0; 1]]
 * 1
 * >>> num_distinct_islands [[1; 0; 0; 0; 0]; [0; 1; 0; 0; 0]; [0; 0; 1; 0; 0]; [0; 0; 0; 1; 0]; [0; 0; 0; 0; 1]]
 * 1
*)
let num_distinct_islands (grid : int list list) : int =","  0","let () =
  assert (num_distinct_islands [[1; 1; 0; 0; 1]; [1; 0; 0; 0; 0]; [0; 0; 1; 1; 0]; [0; 0; 1; 0; 0]] = 2);
  assert (num_distinct_islands [[1; 0; 0; 0; 0]; [0; 0; 0; 0; 0]; [0; 0; 0; 0; 0]; [0; 0; 0; 0; 1]] = 1);
  assert (num_distinct_islands [[1; 0; 0; 0; 0]; [0; 1; 0; 0; 0]; [0; 0; 1; 0; 0]; [0; 0; 0; 1; 0]; [0; 0; 0; 0; 1]] = 1);
  assert (num_distinct_islands [[0; 0; 0; 0; 0]; [0; 0; 0; 0; 0]; [0; 0; 0; 0; 0]; [0; 0; 0; 0; 0]; [0; 0; 0; 0; 0]] = 0);
  assert (num_distinct_islands [[1; 1; 0; 1; 1]; [1; 0; 0; 0; 0]; [0; 0; 0; 0; 1]; [1; 1; 0; 1; 1]] = 3);
  assert (num_distinct_islands [[0; 0; 0; 0; 0]; [0; 0; 0; 0; 0]; [0; 0; 0; 0; 0]; [0; 0; 0; 0; 0]] = 0);
  assert (num_distinct_islands [[1; 1; 0; 0; 0]; [1; 1; 0; 0; 0]; [0; 0; 0; 1; 1]; [0; 0; 0; 1; 1]] = 1);
;;","medium","medium_086","medium"
"(**You are given a 1-indexed array of distinct integers nums of length n.
 * >>> result_array [1; 3; 2; 4; 5]
 * [1; 3; 2; 4; 5]
 * >>> result_array [7; 6; 5; 4; 3; 2; 1]
 * [7; 5; 3; 1; 6; 4; 2]
 * >>> result_array [3; 1; 2; 5; 4]
 * [3; 2; 5; 4; 1]
*)
let result_array (nums : int list) : int list =","  []","let () =
  assert (result_array [1; 3; 2; 4; 5] = [1; 3; 2; 4; 5]);
  assert (result_array [7; 6; 5; 4; 3; 2; 1] = [7; 5; 3; 1; 6; 4; 2]);
  assert (result_array [3; 1; 2; 5; 4] = [3; 2; 5; 4; 1]);
  assert (result_array [10; 20; 30; 5; 15] = [10; 15; 20; 30; 5]);
  assert (result_array [1; 3; 2; 4; 6; 5] = [1; 3; 2; 4; 6; 5]);
  assert (result_array [5; 4; 3; 8] = [5; 3; 4; 8]);
  assert (result_array [2; 1; 3] = [2; 3; 1]);
;;","easy","easy_026","easy"
"(**A certain bug's home is on the x-axis at position x. Help them get there from position 0.
 * >>> minimum_jumps [2; 4; 6; 8; 10] 2 1 1
 * -1
 * >>> minimum_jumps [] 1 1 0
 * 0
 * >>> minimum_jumps [5; 6; 7] 1 1 10
 * -1
*)
let minimum_jumps (forbidden : int list) (a : int) (b : int) (x : int) : int =","  0","let () =
  assert (minimum_jumps [2; 4; 6; 8; 10] 2 1 1 = -1);
  assert (minimum_jumps [] 1 1 0 = 0);
  assert (minimum_jumps [5; 6; 7] 1 1 10 = -1);
  assert (minimum_jumps [1; 6; 2; 14; 5; 17; 4] 16 9 7 = 2);
  assert (minimum_jumps [8; 3; 16; 6; 12; 20] 15 13 11 = -1);
  assert (minimum_jumps [14; 4; 18; 1; 15] 3 15 9 = 3);
  assert (minimum_jumps [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19] 3 5 20 = -1);
;;","medium","medium_038","medium"
"(**We have two arrays arr1 and arr2 which are initially empty. You need to add positive integers to ...
 * >>> minimize_set 2 7 1 3
 * 4
 * >>> minimize_set 2 4 8 2
 * 15
 * >>> minimize_set 100 101 100000000 100000000
 * 200019803
*)
let minimize_set (divisor1 : int) (divisor2 : int) (uniqueCnt1 : int) (uniqueCnt2 : int) : int =","  0","let () =
  assert (minimize_set 2 7 1 3 = 4);
  assert (minimize_set 2 4 8 2 = 15);
  assert (minimize_set 100 101 100000000 100000000 = 200019803);
  assert (minimize_set 100 200 100000000 100000000 = 201005025);
  assert (minimize_set 5 10 5 5 = 11);
  assert (minimize_set 7 11 10 10 = 20);
  assert (minimize_set 7 13 10 10 = 20);
;;","medium","medium_066","medium"
"(**You are given an integer n representing the length of an unknown array that you are trying to rec...
 * >>> recover_array 5 [0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0]
 * [0; 0; 0; 0; 0]
 * >>> recover_array 3 [-3; -2; -1; 0; 0; 1; 2; 3]
 * [-1; -2; 3]
 * >>> recover_array 2 [0; 0; 0; 0]
 * [0; 0]
*)
let recover_array (n : int) (sums : int list) : int list =","  []","let () =
  assert (recover_array 5 [0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0] = [0; 0; 0; 0; 0]);
  assert (recover_array 3 [-3; -2; -1; 0; 0; 1; 2; 3] = [-1; -2; 3]);
  assert (recover_array 2 [0; 0; 0; 0] = [0; 0]);
  assert (recover_array 1 [0; 5] = [5]);
  assert (recover_array 3 [3; 1; 2; 0; 4; 5; 6; 8] = [1; 2; 4]);
  assert (recover_array 4 [0; 0; 5; 5; 4; -1; 4; 9; 9; -1; 4; 3; 4; 8; 3; 8] = [0; -1; 4; 5]);
  assert (recover_array 1 [0; -1] = [-1]);
;;","hard","hard_059","hard"
"(**We are given n different types of stickers. Each sticker has a lowercase English word on it.
 * >>> min_stickers [""aaa""; ""bbb""] ""aabbbccc""
 * -1
 * >>> min_stickers [""a""; ""b""; ""c""] ""abc""
 * 3
 * >>> min_stickers [""abc""; ""abc""] ""abcabc""
 * 2
*)
let min_stickers (stickers : string list) (target : string) : int =","  0","let () =
  assert (min_stickers [""aaa""; ""bbb""] ""aabbbccc"" = -1);
  assert (min_stickers [""a""; ""b""; ""c""] ""abc"" = 3);
  assert (min_stickers [""abc""; ""abc""] ""abcabc"" = 2);
  assert (min_stickers [""abcd""] ""abcdabcd"" = 2);
  assert (min_stickers [""abc""] ""d"" = -1);
  assert (min_stickers [""notice""; ""possible""] ""basicbasic"" = -1);
  assert (min_stickers [""abc""] ""abcd"" = -1);
;;","hard","hard_012","hard"
"(**Given a string s consisting of lowercase English letters, return the first letter to appear twice.
 * >>> repeated_character ""alphabet""
 * a
 * >>> repeated_character ""finding""
 * i
 * >>> repeated_character ""xyzxyz""
 * x
*)
let repeated_character (s : string) : string =","  """"","let () =
  assert (repeated_character ""alphabet"" = a);
  assert (repeated_character ""finding"" = i);
  assert (repeated_character ""xyzxyz"" = x);
  assert (repeated_character ""zabcdefghijkkl"" = k);
  assert (repeated_character ""first"" = None);
  assert (repeated_character ""second"" = None);
  assert (repeated_character ""abcdefghijkk"" = k);
;;","easy","easy_091","easy"
"(**Given an integer array nums, return the most frequent even element.
 * >>> most_frequent_even [29; 47; 21; 41; 13; 37; 25; 7]
 * -1
 * >>> most_frequent_even [1; 3; 5; 7; 9; 11; 13; 15]
 * -1
 * >>> most_frequent_even [5; 5; 5; 5; 5; 5; 4; 4; 4; 4; 4; 4]
 * 4
*)
let most_frequent_even (nums : int list) : int =","  0","let () =
  assert (most_frequent_even [29; 47; 21; 41; 13; 37; 25; 7] = -1);
  assert (most_frequent_even [1; 3; 5; 7; 9; 11; 13; 15] = -1);
  assert (most_frequent_even [5; 5; 5; 5; 5; 5; 4; 4; 4; 4; 4; 4] = 4);
  assert (most_frequent_even [8; 8; 8; 8; 8; 7; 7; 7; 7; 6; 6; 6; 6] = 8);
  assert (most_frequent_even [10; 20; 20; 10; 10; 20; 20; 10] = 10);
  assert (most_frequent_even [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = 2);
  assert (most_frequent_even [1; 3; 5; 7; 9] = -1);
;;","easy","easy_113","easy"
"(**Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary...
 * >>> build_tree [-1] [-1]
 * [-1]
 * >>> build_tree [1; 2] [2; 1]
 * [1; None; 2]
 * >>> build_tree [3; 2; 1] [3; 2; 1]
 * [1; 2; None; 3]
*)
let build_tree (inorder : int list) (postorder : int list) : 'a option =","  None","let () =
  assert (build_tree [-1] [-1] = [-1]);
  assert (build_tree [1; 2] [2; 1] = [1; None; 2]);
  assert (build_tree [3; 2; 1] [3; 2; 1] = [1; 2; None; 3]);
  assert (build_tree [1; 2; 3; 4; 5] [1; 2; 5; 4; 3] = [3; 2; 4; 1; None; None; 5]);
  assert (build_tree [1; 2; 3; 4] [1; 2; 4; 3] = [3; 2; 4; 1]);
  assert (build_tree [1; 2; 3; 4; 5; 6; 7] [1; 3; 2; 5; 7; 6; 4] = [4; 2; 6; 1; 3; 5; 7]);
  assert (build_tree [9; 3; 15; 20; 7] [9; 15; 7; 20; 3] = [3; 9; 20; None; None; 15; 7]);
;;","medium","medium_018","medium"
"(**You are given an m x n matrix board containing letters 'X' and 'O', capture regions that are surr...
 * >>> solve [[""X""; ""X""; ""X""; ""O""]; [""X""; ""O""; ""O""; ""X""]; [""X""; ""X""; ""O""; ""X""]; [""X""; ""O""; ""X""; ""X""]]
 * None
 * >>> solve [[""O""; ""X""; ""X""; ""O""; ""X""]; [""X""; ""X""; ""X""; ""X""; ""O""]; [""X""; ""X""; ""X""; ""O""; ""X""]; [""O""; ""X""; ""X""; ""X""; ""O""]; [""X""; ""O""; ""O""; ""X""; ""X""]]
 * None
 * >>> solve [[""X""; ""X""; ""X""; ""X""]; [""X""; ""O""; ""O""; ""X""]; [""X""; ""X""; ""O""; ""X""]; [""X""; ""O""; ""X""; ""X""]]
 * None
*)
let solve (board : string list list) : unit =","  failwith ""Not implemented""","let () =
  assert (solve [[""X""; ""X""; ""X""; ""O""]; [""X""; ""O""; ""O""; ""X""]; [""X""; ""X""; ""O""; ""X""]; [""X""; ""O""; ""X""; ""X""]] = None);
  assert (solve [[""O""; ""X""; ""X""; ""O""; ""X""]; [""X""; ""X""; ""X""; ""X""; ""O""]; [""X""; ""X""; ""X""; ""O""; ""X""]; [""O""; ""X""; ""X""; ""X""; ""O""]; [""X""; ""O""; ""O""; ""X""; ""X""]] = None);
  assert (solve [[""X""; ""X""; ""X""; ""X""]; [""X""; ""O""; ""O""; ""X""]; [""X""; ""X""; ""O""; ""X""]; [""X""; ""O""; ""X""; ""X""]] = None);
  assert (solve [[""X""; ""X""; ""X""; ""X""; ""X""]; [""X""; ""O""; ""O""; ""O""; ""X""]; [""X""; ""O""; ""X""; ""O""; ""X""]; [""X""; ""O""; ""O""; ""O""; ""X""]; [""X""; ""X""; ""X""; ""X""; ""X""]] = None);
  assert (solve [[""O""; ""O""; ""O""]; [""O""; ""X""; ""O""]; [""O""; ""O""; ""O""]] = None);
  assert (solve [[""O""; ""X""; ""X""; ""O""; ""X""]; [""X""; ""X""; ""X""; ""X""; ""X""]; [""X""; ""X""; ""X""; ""X""; ""X""]; [""X""; ""X""; ""X""; ""O""; ""O""]; [""X""; ""X""; ""O""; ""X""; ""X""]] = None);
  assert (solve [[""X""; ""O""; ""X""; ""O""]; [""O""; ""X""; ""O""; ""X""]; [""X""; ""O""; ""X""; ""O""]; [""O""; ""X""; ""O""; ""X""]] = None);
;;","medium","medium_199","medium"
"(**A dieter consumes calories[i] calories on the i-th day. 
 * >>> diet_plan_performance [6; 5; 0; 0] 2 1 5
 * 0
 * >>> diet_plan_performance [100; 200; 300; 400; 500; 600; 700] 4 1000 2000
 * 1
 * >>> diet_plan_performance [5000; 5000; 5000; 5000; 5000] 5 20000 25000
 * 0
*)
let diet_plan_performance (calories : int list) (k : int) (lower : int) (upper : int) : int =","  0","let () =
  assert (diet_plan_performance [6; 5; 0; 0] 2 1 5 = 0);
  assert (diet_plan_performance [100; 200; 300; 400; 500; 600; 700] 4 1000 2000 = 1);
  assert (diet_plan_performance [5000; 5000; 5000; 5000; 5000] 5 20000 25000 = 0);
  assert (diet_plan_performance [1; 2; 3; 4; 5] 1 3 3 = 0);
  assert (diet_plan_performance [7; 7; 7; 7; 7; 7; 7] 7 21 21 = 1);
  assert (diet_plan_performance [1; 3; 2; 4; 3; 1] 3 2 4 = 4);
  assert (diet_plan_performance [5; 5; 5; 5; 5; 5; 5; 5; 5; 5] 5 20 30 = 0);
;;","easy","easy_055","easy"
"(**You are given a 0-indexed integer array nums. You can apply the following operation any number of...
 * >>> make_pref_sum_non_negative [-1; 2; -3; 4; -5]
 * 2
 * >>> make_pref_sum_non_negative [1; -1; 1; -1; 1]
 * 0
 * >>> make_pref_sum_non_negative [1; 2; 3; 4; 5; -15]
 * 0
*)
let make_pref_sum_non_negative (nums : int list) : int =","  0","let () =
  assert (make_pref_sum_non_negative [-1; 2; -3; 4; -5] = 2);
  assert (make_pref_sum_non_negative [1; -1; 1; -1; 1] = 0);
  assert (make_pref_sum_non_negative [1; 2; 3; 4; 5; -15] = 0);
  assert (make_pref_sum_non_negative [-1; -2; -3; 4; 5; 6] = 3);
  assert (make_pref_sum_non_negative [-5; -4; -3; -2; -1] = 5);
  assert (make_pref_sum_non_negative [0; 0; 0; 0; 0] = 0);
  assert (make_pref_sum_non_negative [2; 3; -5; 4] = 0);
;;","medium","medium_195","medium"
"(**You are given a tree (i.e. a connected, undirected graph that has no cycles) rooted at node 0 con...
 * >>> longest_path [-1; 0; 0; 2; 2; 2] ""abbccc""
 * 4
*)
let longest_path (parent : int list) (s : string) : int =","  0","let () =
  assert (longest_path [-1; 0; 0; 2; 2; 2] ""abbccc"" = 4);
  assert (longest_path [-1; 0; 0; 0] ""aabc"" = 3);
  assert (longest_path [-1; 0; 0; 1; 1; 2] ""abacbe"" = 3);
  assert (longest_path [-1; 0; 1; 2; 3; 4; 5] ""abcdefg"" = 7);
  assert (longest_path [-1; 0; 0; 0; 0; 0; 0] ""abcdefg"" = 3);
  assert (longest_path [-1; 0; 0; 1; 1; 2; 2; 3; 3; 4; 4; 5; 5; 6; 6; 7; 7; 8; 8; 9; 9; 10; 10; 11; 11; 12; 12; 13; 13; 14; 14] ""aabbaabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz"" = 5);
  assert (longest_path [-1; 0; 0; 1; 1; 2; 2; 3; 3; 4; 4; 5; 5; 6; 6; 7; 7; 8; 8; 9; 9] ""abcdefghijklmnopqrstuvwxyz"" = 8);
;;","hard","hard_041","hard"
"(**Let f(x) be the number of zeroes at the end of x!. Recall that x! = 1 * 2 * 3 * ... * x and by co...
 * >>> preimage_size_fzf 100
 * 5
 * >>> preimage_size_fzf 1
 * 5
 * >>> preimage_size_fzf 10000
 * 5
*)
let preimage_size_fzf (k : int) : int =","  0","let () =
  assert (preimage_size_fzf 100 = 5);
  assert (preimage_size_fzf 1 = 5);
  assert (preimage_size_fzf 10000 = 5);
  assert (preimage_size_fzf 1000000 = 5);
  assert (preimage_size_fzf 3 = 5);
  assert (preimage_size_fzf 0 = 5);
  assert (preimage_size_fzf 1000 = 5);
;;","hard","hard_077","hard"
"(**You are given an alphanumeric string s. (Alphanumeric string is a string consisting of lowercase ...
 * >>> reformat ""a1b1""
 * a1b1
 * >>> reformat ""1229857369""
 * 
 * >>> reformat ""aa1""
 * a1a
*)
let reformat (s : string) : string =","  """"","let () =
  assert (reformat ""a1b1"" = a1b1);
  assert (reformat ""aa1"" = a1a);
  assert (reformat ""abc123def456"" = a1b2c3d4e5f6);
  assert (reformat ""ab123"" = 1a2b3);
;;","easy","easy_003","easy"
"(**Given two positive integers left and right, find the two integers num1 and num2 such that:
 * >>> closest_primes 500 550
 * [521; 523]
 * >>> closest_primes 1000 1100
 * [1019; 1021]
 * >>> closest_primes 10000 10020
 * [10007; 10009]
*)
let closest_primes (left : int) (right : int) : int list =","  []","let () =
  assert (closest_primes 500 550 = [521; 523]);
  assert (closest_primes 1000 1100 = [1019; 1021]);
  assert (closest_primes 10000 10020 = [10007; 10009]);
  assert (closest_primes 1000 1010 = [-1; -1]);
  assert (closest_primes 999983 999999 = [-1; -1]);
  assert (closest_primes 20 30 = [23; 29]);
  assert (closest_primes 100 110 = [101; 103]);
;;","medium","medium_153","medium"
"(**A super ugly number is a positive integer whose prime factors are in the array primes.
 * >>> nth_super_ugly_number 5 [2; 7; 11]
 * 8
 * >>> nth_super_ugly_number 5 [2; 11; 13; 17; 19]
 * 11
 * >>> nth_super_ugly_number 3 [2; 3; 5; 7]
 * 3
*)
let nth_super_ugly_number (n : int) (primes : int list) : int =","  0","let () =
  assert (nth_super_ugly_number 5 [2; 7; 11] = 8);
  assert (nth_super_ugly_number 5 [2; 11; 13; 17; 19] = 11);
  assert (nth_super_ugly_number 3 [2; 3; 5; 7] = 3);
  assert (nth_super_ugly_number 15 [3; 5; 7] = 81);
  assert (nth_super_ugly_number 10 [2; 3; 5] = 12);
  assert (nth_super_ugly_number 20 [2; 11; 13; 17; 19] = 88);
  assert (nth_super_ugly_number 2 [2; 7] = 2);
;;","medium","medium_136","medium"
"(**You are given a 0-indexed integer array nums and a positive integer k.
 * >>> max_sum [1; 2; 3; 4; 5] 5
 * 99
 * >>> max_sum [10; 10; 10; 10] 4
 * 400
 * >>> max_sum [1000000000; 1000000000; 1000000000] 2
 * 98
*)
let max_sum (nums : int list) (k : int) : int =","  0","let () =
  assert (max_sum [1; 2; 3; 4; 5] 5 = 99);
  assert (max_sum [10; 10; 10; 10] 4 = 400);
  assert (max_sum [1000000000; 1000000000; 1000000000] 2 = 98);
  assert (max_sum [10; 10; 10; 10] 2 = 200);
  assert (max_sum [1; 1; 1; 1] 4 = 4);
  assert (max_sum [3; 3; 3; 3; 3; 3] 3 = 27);
  assert (max_sum [2; 6; 5; 8] 2 = 261);
;;","hard","hard_070","hard"
"(**Given an integer array nums containing distinct positive integers, find and return any number fro...
 * >>> find_non_min_or_max [1]
 * -1
 * >>> find_non_min_or_max [1; 3; 2]
 * 2
 * >>> find_non_min_or_max [9; 5; 6]
 * 6
*)
let find_non_min_or_max (nums : int list) : int =","  0","let () =
  assert (find_non_min_or_max [1] = -1);
  assert (find_non_min_or_max [1; 3; 2] = 2);
  assert (find_non_min_or_max [9; 5; 6] = 6);
  assert (find_non_min_or_max [9; 11; 10] = 10);
  assert (find_non_min_or_max [1; 2] = -1);
  assert (find_non_min_or_max [7; 8; 9] = 8);
  assert (find_non_min_or_max [100; 1; 50] = 50);
;;","easy","easy_125","easy"
"(**You are given two arrays of positive integers, boxes and warehouse, representing the heights of s...
 * >>> max_boxes_in_warehouse [10; 9; 8; 7; 6] [1; 2; 3; 4; 5]
 * 0
 * >>> max_boxes_in_warehouse [100; 200; 300] [150; 250; 350]
 * 1
 * >>> max_boxes_in_warehouse [2; 3; 5; 7; 11] [12; 10; 8; 6; 4]
 * 5
*)
let max_boxes_in_warehouse (boxes : int list) (warehouse : int list) : int =","  0","let () =
  assert (max_boxes_in_warehouse [10; 9; 8; 7; 6] [1; 2; 3; 4; 5] = 0);
  assert (max_boxes_in_warehouse [100; 200; 300] [150; 250; 350] = 1);
  assert (max_boxes_in_warehouse [2; 3; 5; 7; 11] [12; 10; 8; 6; 4] = 5);
  assert (max_boxes_in_warehouse [1; 1; 1; 1] [10; 10; 10; 10] = 4);
  assert (max_boxes_in_warehouse [10; 9; 8; 7; 6; 5; 4; 3; 2; 1] [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = 1);
  assert (max_boxes_in_warehouse [1; 1; 1; 1] [1; 1; 1; 1] = 4);
  assert (max_boxes_in_warehouse [10; 20; 30; 40] [40; 30; 20; 10] = 4);
;;","medium","medium_005","medium"
"(**You are given an integer array nums and an integer k. Find the largest even sum of any subsequenc...
 * >>> largest_even_sum [0; 0; 0; 0; 0] 2
 * 0
 * >>> largest_even_sum [0; 0; 0; 0] 2
 * 0
 * >>> largest_even_sum [4; 6; 2] 3
 * 12
*)
let largest_even_sum (nums : int list) (k : int) : int =","  0","let () =
  assert (largest_even_sum [0; 0; 0; 0; 0] 2 = 0);
  assert (largest_even_sum [0; 0; 0; 0] 2 = 0);
  assert (largest_even_sum [4; 6; 2] 3 = 12);
  assert (largest_even_sum [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 5 = 40);
  assert (largest_even_sum [1; 3; 5] 1 = -1);
  assert (largest_even_sum [5; 5; 5; 5; 5; 5; 5; 5; 5; 5] 4 = 20);
  assert (largest_even_sum [1; 2; 3; 4; 5; 6] 4 = 18);
;;","medium","medium_054","medium"
"(**The value of an alphanumeric string can be defined as:
 * >>> maximum_value [""xyz""; ""xyzz""; ""xyzzz""; ""xyzzzz""]
 * 6
 * >>> maximum_value [""a1""; ""b2""; ""c3""; ""1a""; ""2b""; ""3c""]
 * 2
 * >>> maximum_value [""abc""; ""123""; ""a1b2c3""; ""000""]
 * 123
*)
let maximum_value (strs : string list) : int =","  0","let () =
  assert (maximum_value [""xyz""; ""xyzz""; ""xyzzz""; ""xyzzzz""] = 6);
  assert (maximum_value [""a1""; ""b2""; ""c3""; ""1a""; ""2b""; ""3c""] = 2);
  assert (maximum_value [""abc""; ""123""; ""a1b2c3""; ""000""] = 123);
  assert (maximum_value [""123456789""; ""987654321""; ""111111111""; ""222222222""; ""333333333""] = 987654321);
  assert (maximum_value [""a""; ""b""; ""c""; ""d""; ""e""; ""f""; ""g""; ""h""; ""i""; ""j""] = 1);
  assert (maximum_value [""alic3""; ""bob""; ""3""; ""4""; ""00000""] = 5);
  assert (maximum_value [""abc""; ""123""; ""abcd""; ""4567""; ""89""] = 4567);
;;","easy","easy_197","easy"
"(**You are given a 0-indexed integer array costs where costs[i] is the cost of hiring the ith worker.
 * >>> total_cost [10; 10; 10; 10; 10] 4 2
 * 40
 * >>> total_cost [10; 10; 10; 10; 10] 5 5
 * 50
 * >>> total_cost [2; 2; 2; 2; 2; 2; 2; 2; 2; 2] 5 5
 * 10
*)
let total_cost (costs : int list) (k : int) (candidates : int) : int =","  0","let () =
  assert (total_cost [10; 10; 10; 10; 10] 4 2 = 40);
  assert (total_cost [10; 10; 10; 10; 10] 5 5 = 50);
  assert (total_cost [2; 2; 2; 2; 2; 2; 2; 2; 2; 2] 5 5 = 10);
  assert (total_cost [5; 4; 3; 2; 1] 5 1 = 15);
  assert (total_cost [5; 4; 3; 2; 1] 3 1 = 6);
  assert (total_cost [5; 5; 5; 5] 2 2 = 10);
  assert (total_cost [10; 20; 30; 40; 50] 5 5 = 150);
;;","medium","medium_157","medium"
"(**You are given a 0-indexed integer array nums.
 * >>> min_impossible_or [5; 3; 2]
 * 1
 * >>> min_impossible_or [1; 2; 4; 8; 16]
 * 32
 * >>> min_impossible_or [1024; 512; 256; 128; 64; 32; 16; 8; 4; 2; 1]
 * 2048
*)
let min_impossible_or (nums : int list) : int =","  0","let () =
  assert (min_impossible_or [5; 3; 2] = 1);
  assert (min_impossible_or [1; 2; 4; 8; 16] = 32);
  assert (min_impossible_or [1024; 512; 256; 128; 64; 32; 16; 8; 4; 2; 1] = 2048);
  assert (min_impossible_or [2; 1] = 4);
  assert (min_impossible_or [7; 14; 21; 28] = 1);
  assert (min_impossible_or [1; 3; 5; 7; 9] = 2);
  assert (min_impossible_or [3; 6; 9; 12] = 1);
;;","medium","medium_168","medium"
"(**You are given a 0-indexed 2D integer array nums representing the coordinates of the cars parking ...
 * >>> number_of_points [[1; 100]]
 * 100
 * >>> number_of_points [[1; 3]; [5; 8]]
 * 7
 * >>> number_of_points [[1; 1]; [2; 2]; [3; 3]]
 * 3
*)
let number_of_points (nums : int list list) : int =","  0","let () =
  assert (number_of_points [[1; 100]] = 100);
  assert (number_of_points [[1; 3]; [5; 8]] = 7);
  assert (number_of_points [[1; 1]; [2; 2]; [3; 3]] = 3);
  assert (number_of_points [[10; 15]; [20; 25]] = 12);
  assert (number_of_points [[1; 100]; [50; 60]; [60; 90]] = 100);
  assert (number_of_points [[5; 10]; [10; 15]] = 11);
  assert (number_of_points [[10; 15]; [12; 20]; [8; 14]] = 13);
;;","easy","easy_100","easy"
"(**Given an integer n, return the number of prime numbers that are strictly less than n.
 * >>> count_primes 0
 * 0
 * >>> count_primes 5000000
 * 348513
 * >>> count_primes 1000
 * 168
*)
let count_primes (n : int) : int =","  0","let () =
  assert (count_primes 0 = 0);
  assert (count_primes 5000000 = 348513);
  assert (count_primes 1000 = 168);
  assert (count_primes 100 = 25);
  assert (count_primes 30 = 10);
  assert (count_primes 1500000 = 114155);
  assert (count_primes 1000000 = 78498);
;;","medium","medium_095","medium"
"(**You are given an array nums consisting of positive integers.
 * >>> minimum_splits [100; 200; 300; 400]
 * 1
 * >>> minimum_splits [30; 60; 90; 120]
 * 1
 * >>> minimum_splits [2; 3; 5; 7; 11]
 * 5
*)
let minimum_splits (nums : int list) : int =","  0","let () =
  assert (minimum_splits [100; 200; 300; 400] = 1);
  assert (minimum_splits [30; 60; 90; 120] = 1);
  assert (minimum_splits [2; 3; 5; 7; 11] = 5);
  assert (minimum_splits [18; 9; 6; 12] = 1);
  assert (minimum_splits [4; 12; 6; 14] = 1);
  assert (minimum_splits [18; 9; 27; 81; 3] = 1);
  assert (minimum_splits [30; 20; 10; 5] = 1);
;;","medium","medium_123","medium"
"(**Given a string s, consider all duplicated substrings: (contiguous) substrings of s that occur 2 o...
 * >>> longest_dup_substring ""abcabcabc""
 * abcabc
 * >>> longest_dup_substring ""zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz""
 * zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
 * >>> longest_dup_substring ""mississippi""
 * issi
*)
let longest_dup_substring (s : string) : string =","  """"","let () =
  assert (longest_dup_substring ""abcabcabc"" = abcabc);
  assert (longest_dup_substring ""zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz"" = zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz);
  assert (longest_dup_substring ""mississippi"" = issi);
  assert (longest_dup_substring ""banana"" = ana);
  assert (longest_dup_substring ""bananaaa"" = ana);
;;","hard","hard_054","hard"
"(**You are given an array prices where prices[i] is the price of a given stock on the ith day.
 * >>> max_profit [1; 2; 4]
 * 3
 * >>> max_profit [1; 2; 3; 0; 2; 3; 1; 4; 2; 5]
 * 7
 * >>> max_profit [2; 1; 4; 5; 2; 9; 7]
 * 10
*)
let max_profit (prices : int list) : int =","  0","let () =
  assert (max_profit [1; 2; 4] = 3);
  assert (max_profit [1; 2; 3; 0; 2; 3; 1; 4; 2; 5] = 7);
  assert (max_profit [2; 1; 4; 5; 2; 9; 7] = 10);
  assert (max_profit [1] = 0);
  assert (max_profit [3; 2; 6; 5; 0; 3] = 7);
  assert (max_profit [3; 2; 1] = 0);
  assert (max_profit [8; 9; 7; 9; 10; 1; 2; 3; 4; 1; 5] = 8);
;;","medium","medium_013","medium"
"(**You are given an array of people, people, which are the attributes of some people in a queue (not...
 * >>> reconstruct_queue [[9; 0]; [7; 0]; [5; 0]; [6; 1]; [3; 2]; [2; 2]; [1; 4]; [8; 1]]
 * [[5; 0]; [7; 0]; [2; 2]; [3; 2]; [1; 4]; [6; 1]; [9; 0]; [8; 1]]
 * >>> reconstruct_queue [[5; 5]; [5; 4]; [5; 3]; [5; 2]; [5; 1]; [5; 0]]
 * [[5; 0]; [5; 1]; [5; 2]; [5; 3]; [5; 4]; [5; 5]]
 * >>> reconstruct_queue [[1; 0]; [2; 0]; [3; 0]; [4; 0]; [5; 0]]
 * [[1; 0]; [2; 0]; [3; 0]; [4; 0]; [5; 0]]
*)
let reconstruct_queue (people : int list list) : int list list =","  [[]]","let () =
  assert (reconstruct_queue [[9; 0]; [7; 0]; [5; 0]; [6; 1]; [3; 2]; [2; 2]; [1; 4]; [8; 1]] = [[5; 0]; [7; 0]; [2; 2]; [3; 2]; [1; 4]; [6; 1]; [9; 0]; [8; 1]]);
  assert (reconstruct_queue [[5; 5]; [5; 4]; [5; 3]; [5; 2]; [5; 1]; [5; 0]] = [[5; 0]; [5; 1]; [5; 2]; [5; 3]; [5; 4]; [5; 5]]);
  assert (reconstruct_queue [[1; 0]; [2; 0]; [3; 0]; [4; 0]; [5; 0]] = [[1; 0]; [2; 0]; [3; 0]; [4; 0]; [5; 0]]);
  assert (reconstruct_queue [[5; 2]; [7; 0]; [5; 0]; [6; 1]; [3; 2]; [2; 2]; [1; 4]; [8; 1]] = [[5; 0]; [7; 0]; [2; 2]; [3; 2]; [1; 4]; [5; 2]; [6; 1]; [8; 1]]);
  assert (reconstruct_queue [[6; 0]; [5; 0]; [4; 0]; [3; 2]; [2; 2]; [1; 4]] = [[4; 0]; [5; 0]; [2; 2]; [3; 2]; [1; 4]; [6; 0]]);
  assert (reconstruct_queue [[2; 4]; [3; 4]; [9; 0]; [0; 6]; [7; 1]; [3; 1]; [8; 5]; [1; 5]; [4; 2]; [5; 0]] = [[5; 0]; [3; 1]; [9; 0]; [4; 2]; [2; 4]; [1; 5]; [0; 6]; [3; 4]; [7; 1]; [8; 5]]);
  assert (reconstruct_queue [[9; 0]; [7; 0]; [5; 2]; [6; 1]; [3; 3]; [8; 2]; [4; 4]] = [[7; 0]; [6; 1]; [5; 2]; [3; 3]; [9; 0]; [4; 4]; [8; 2]]);
;;","medium","medium_034","medium"
"(**A fancy string is a string where no three consecutive characters are equal.
 * >>> make_fancy_string ""zzzzzzzzz""
 * zz
 * >>> make_fancy_string ""aaabbbccc""
 * aabbcc
 * >>> make_fancy_string ""abcdefghijklmnopqrstuvwxyz""
 * abcdefghijklmnopqrstuvwxyz
*)
let make_fancy_string (s : string) : string =","  """"","let () =
  assert (make_fancy_string ""zzzzzzzzz"" = zz);
  assert (make_fancy_string ""aaabbbccc"" = aabbcc);
  assert (make_fancy_string ""abcdefghijklmnopqrstuvwxyz"" = abcdefghijklmnopqrstuvwxyz);
  assert (make_fancy_string ""aabbaa"" = aabbaa);
  assert (make_fancy_string ""leeetcode"" = leetcode);
  assert (make_fancy_string ""aaaaa"" = aa);
  assert (make_fancy_string ""ccccccaaa"" = ccaa);
;;","easy","easy_038","easy"
"(**Given a string s, find two disjoint palindromic subsequences of s such that the product of their ...
 * >>> max_product ""xyzyx""
 * 6
 * >>> max_product ""aabbcc""
 * 4
 * >>> max_product ""aaaa""
 * 4
*)
let max_product (s : string) : int =","  0","let () =
  assert (max_product ""xyzyx"" = 6);
  assert (max_product ""aabbcc"" = 4);
  assert (max_product ""aaaa"" = 4);
  assert (max_product ""accbcaxxcxx"" = 25);
  assert (max_product ""madam"" = 6);
  assert (max_product ""noon"" = 4);
  assert (max_product ""racecar"" = 12);
;;","medium","medium_194","medium"
"(**You are given an undirected graph. You are given an integer n which is the number of nodes in the...
 * >>> min_trio_degree 4 [[1; 2]; [1; 3]; [2; 3]]
 * 0
 * >>> min_trio_degree 10 [[1; 2]; [1; 3]; [1; 4]; [2; 3]; [2; 4]; [3; 4]; [5; 6]; [6; 7]; [7; 8]; [8; 9]; [9; 10]]
 * 3
 * >>> min_trio_degree 400 [[1; 2]; [2; 3]; [3; 1]]
 * 0
*)
let min_trio_degree (n : int) (edges : int list list) : int =","  0","let () =
  assert (min_trio_degree 4 [[1; 2]; [1; 3]; [2; 3]] = 0);
  assert (min_trio_degree 10 [[1; 2]; [1; 3]; [1; 4]; [2; 3]; [2; 4]; [3; 4]; [5; 6]; [6; 7]; [7; 8]; [8; 9]; [9; 10]] = 3);
  assert (min_trio_degree 400 [[1; 2]; [2; 3]; [3; 1]] = 0);
  assert (min_trio_degree 10 [[1; 2]; [1; 3]; [2; 3]; [4; 5]; [4; 6]; [5; 6]; [7; 8]; [8; 9]; [9; 7]; [10; 1]] = 0);
  assert (min_trio_degree 8 [[1; 2]; [1; 3]; [2; 3]; [4; 5]; [5; 6]; [6; 4]; [7; 8]] = 0);
  assert (min_trio_degree 8 [[1; 2]; [1; 3]; [2; 3]; [4; 5]; [4; 6]; [5; 6]; [7; 8]] = 0);
  assert (min_trio_degree 6 [[1; 2]; [1; 3]; [3; 2]; [4; 1]; [5; 2]; [3; 6]] = 3);
;;","hard","hard_036","hard"
"(**Given two numbers arr1 and arr2 in base -2, return the result of adding them together.
 * >>> add_negabinary [0] [0]
 * [0]
 * >>> add_negabinary [1; 0; 1; 0; 1] [1; 0; 1; 0; 1]
 * [1; 1; 1; 1; 1; 1; 0]
 * >>> add_negabinary [1; 1; 0] [1; 1; 0]
 * [1; 0; 0]
*)
let add_negabinary (arr1 : int list) (arr2 : int list) : int list =","  []","let () =
  assert (add_negabinary [0] [0] = [0]);
  assert (add_negabinary [1; 0; 1; 0; 1] [1; 0; 1; 0; 1] = [1; 1; 1; 1; 1; 1; 0]);
  assert (add_negabinary [1; 1; 0] [1; 1; 0] = [1; 0; 0]);
  assert (add_negabinary [1; 0; 1] [1; 1; 1; 1; 1] = [1; 0; 0; 0; 0]);
  assert (add_negabinary [1; 1; 0; 1] [1; 0; 1; 0] = [1; 1; 0; 1; 1; 1]);
  assert (add_negabinary [1; 0; 0; 1] [1; 1; 0; 1] = [1; 0; 1; 0]);
  assert (add_negabinary [1; 0; 0; 1] [1; 1; 0] = [1; 1; 1; 1]);
;;","medium","medium_113","medium"
"(**You are given an integer array nums.
 * >>> maximum_prime_difference [97; 1; 97; 1; 97]
 * 4
 * >>> maximum_prime_difference [2; 2; 2; 2; 2; 2; 2; 2; 2; 2]
 * 9
 * >>> maximum_prime_difference [100; 97; 94; 91; 88; 85; 82; 79; 76; 73; 70; 67; 64; 61; 58; 55; 52; 49; 46; 43; 40; 37; 34; 31; 28; 25; 22; 19; 16; 13; 10; 7; 4; 1]
 * 30
*)
let maximum_prime_difference (nums : int list) : int =","  0","let () =
  assert (maximum_prime_difference [97; 1; 97; 1; 97] = 4);
  assert (maximum_prime_difference [2; 2; 2; 2; 2; 2; 2; 2; 2; 2] = 9);
  assert (maximum_prime_difference [100; 97; 94; 91; 88; 85; 82; 79; 76; 73; 70; 67; 64; 61; 58; 55; 52; 49; 46; 43; 40; 37; 34; 31; 28; 25; 22; 19; 16; 13; 10; 7; 4; 1] = 30);
  assert (maximum_prime_difference [3; 3; 3; 3; 3; 3; 3; 3; 3; 3] = 9);
  assert (maximum_prime_difference [100; 99; 98; 97; 96; 95; 94] = 0);
  assert (maximum_prime_difference [3; 3; 3; 3] = 3);
  assert (maximum_prime_difference [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = 5);
;;","medium","medium_044","medium"
"(**You are given a 0-indexed integer array nums.
 * >>> find_the_array_conc_val [5; 14; 13; 8; 12]
 * 673
 * >>> find_the_array_conc_val [1; 1; 1; 1]
 * 22
 * >>> find_the_array_conc_val [111; 222; 333; 444; 555]
 * 334332
*)
let find_the_array_conc_val (nums : int list) : int =","  0","let () =
  assert (find_the_array_conc_val [5; 14; 13; 8; 12] = 673);
  assert (find_the_array_conc_val [1; 1; 1; 1] = 22);
  assert (find_the_array_conc_val [111; 222; 333; 444; 555] = 334332);
  assert (find_the_array_conc_val [9; 8; 7; 6; 5; 4; 3; 2; 1] = 315);
  assert (find_the_array_conc_val [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = 280);
  assert (find_the_array_conc_val [9] = 9);
  assert (find_the_array_conc_val [1] = 1);
;;","easy","easy_126","easy"
"(**Given an integer array nums, return the largest integer that only occurs once. If no integer occu...
 * >>> largest_unique_number [0; 0; 1; 1; 2; 2; 3; 3; 4; 4; 5]
 * 5
 * >>> largest_unique_number [1]
 * 1
 * >>> largest_unique_number [1000; 1000; 999; 999; 998]
 * 998
*)
let largest_unique_number (nums : int list) : int =","  0","let () =
  assert (largest_unique_number [0; 0; 1; 1; 2; 2; 3; 3; 4; 4; 5] = 5);
  assert (largest_unique_number [1] = 1);
  assert (largest_unique_number [1000; 1000; 999; 999; 998] = 998);
  assert (largest_unique_number [10; 10; 10; 10] = -1);
  assert (largest_unique_number [10; 10; 20; 20; 30] = 30);
  assert (largest_unique_number [1; 2; 2; 3; 3; 4; 4; 5; 5; 6; 6; 7; 7; 8; 8; 9; 9; 10] = 10);
  assert (largest_unique_number [1; 2] = 2);
;;","easy","easy_024","easy"
"(**Given head, the head of a linked list, determine if the linked list has a cycle in it.
*)
let has_cycle (head : 'a option) : bool =","  false","let () =
  assert (has_cycle [1; 2] = false);
  assert (has_cycle [1] = false);
  assert (has_cycle [] = false);
  assert (has_cycle [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 1] = false);
  assert (has_cycle [3; 2; 0; -4] = false);
  assert (has_cycle [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = false);
;;","easy","easy_013","easy"
"(**Given an array of integers arr, a lucky integer is an integer that has a frequency in the array e...
 * >>> find_lucky [1; 1]
 * -1
 * >>> find_lucky [5; 5; 4; 4; 4]
 * -1
 * >>> find_lucky [5]
 * -1
*)
let find_lucky (arr : int list) : int =","  0","let () =
  assert (find_lucky [1; 1] = -1);
  assert (find_lucky [5; 5; 4; 4; 4] = -1);
  assert (find_lucky [5] = -1);
  assert (find_lucky [5; 5; 5; 5; 5] = 5);
  assert (find_lucky [2; 2; 3; 4] = 2);
  assert (find_lucky [300; 300; 300; 300; 300; 300; 300; 300; 300; 300; 300; 300; 300; 300; 300; 300; 300; 300; 300; 300; 300; 300; 300; 300; 300; 300; 300; 300; 300; 300] = -1);
  assert (find_lucky [500; 500; 500; 500; 500; 500; 500; 500; 500; 500] = -1);
;;","easy","easy_076","easy"
"(**There is a bag that consists of items, each item has a number 1, 0, or -1 written on it.
 * >>> k_items_with_maximum_sum 25 25 0 50
 * 25
 * >>> k_items_with_maximum_sum 0 50 0 10
 * 0
 * >>> k_items_with_maximum_sum 3 2 0 2
 * 2
*)
let k_items_with_maximum_sum (numOnes : int) (numZeros : int) (numNegOnes : int) (k : int) : int =","  0","let () =
  assert (k_items_with_maximum_sum 25 25 0 50 = 25);
  assert (k_items_with_maximum_sum 0 50 0 10 = 0);
  assert (k_items_with_maximum_sum 3 2 0 2 = 2);
  assert (k_items_with_maximum_sum 20 20 10 50 = 10);
  assert (k_items_with_maximum_sum 10 10 10 5 = 5);
  assert (k_items_with_maximum_sum 25 0 25 30 = 20);
  assert (k_items_with_maximum_sum 50 50 50 100 = 50);
;;","easy","easy_102","easy"
"(**You are given a 0-indexed integer array nums of length n. The number of ways to partition nums is...
 * >>> ways_to_partition [1; 2; 3; 4; 5] 3
 * 0
 * >>> ways_to_partition [0; 0; 0] 1
 * 2
 * >>> ways_to_partition [5; 5; 5; 5; 5] 5
 * 0
*)
let ways_to_partition (nums : int list) (k : int) : int =","  0","let () =
  assert (ways_to_partition [1; 2; 3; 4; 5] 3 = 0);
  assert (ways_to_partition [0; 0; 0] 1 = 2);
  assert (ways_to_partition [5; 5; 5; 5; 5] 5 = 0);
  assert (ways_to_partition [100000; -100000; 100000; -100000] 0 = 1);
  assert (ways_to_partition [-1; -2; -3; -4; -5] -3 = 0);
  assert (ways_to_partition [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 5 = 1);
  assert (ways_to_partition [-1; -2; -3; -4; -5; -6; -7; -8; -9; -10] -5 = 1);
;;","hard","hard_013","hard"
"(**Alice has n candies, where the ith candy is of type candyType[i]. Alice noticed that she started ...
 * >>> distribute_candies [1; 2; 1; 3; 1; 2; 1; 3; 1; 2]
 * 3
 * >>> distribute_candies [1; 1; 2; 3]
 * 2
 * >>> distribute_candies [1; 1; 1; 2; 2; 2]
 * 2
*)
let distribute_candies (candyType : int list) : int =","  0","let () =
  assert (distribute_candies [1; 2; 1; 3; 1; 2; 1; 3; 1; 2] = 3);
  assert (distribute_candies [1; 1; 2; 3] = 2);
  assert (distribute_candies [1; 1; 1; 2; 2; 2] = 2);
  assert (distribute_candies [0; 0; 0; 0; 0; 0] = 1);
  assert (distribute_candies [100000; 100000; -100000; -100000; 50000; 50000] = 3);
  assert (distribute_candies [-1; -2; -3; -1; -2; -3] = 3);
  assert (distribute_candies [1; 2; 3; 1; 2; 3; 1; 2; 3; 1] = 3);
;;","easy","easy_116","easy"
"(**There are n houses evenly lined up on the street, and each house is beautifully painted. You are ...
 * >>> max_distance [10; 20; 10; 10; 10]
 * 3
 * >>> max_distance [10; 20; 30; 40; 50]
 * 4
 * >>> max_distance [100; 0; 0; 0; 0; 0; 0; 0; 0; 0]
 * 9
*)
let max_distance (colors : int list) : int =","  0","let () =
  assert (max_distance [10; 20; 10; 10; 10] = 3);
  assert (max_distance [10; 20; 30; 40; 50] = 4);
  assert (max_distance [100; 0; 0; 0; 0; 0; 0; 0; 0; 0] = 9);
  assert (max_distance [3; 1; 3; 3; 3] = 3);
  assert (max_distance [1; 1; 1; 6; 1; 1; 1] = 3);
  assert (max_distance [1; 2; 3; 4; 5] = 4);
  assert (max_distance [5; 5; 5; 5; 1] = 4);
;;","easy","easy_159","easy"
"(**There is an undirected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.
 * >>> reachable_nodes 6 [[0; 1]; [0; 2]; [2; 3]; [2; 4]; [4; 5]] [1; 4]
 * 3
 * >>> reachable_nodes 8 [[0; 1]; [0; 2]; [1; 3]; [1; 4]; [2; 5]; [2; 6]; [3; 7]] [5; 7]
 * 6
 * >>> reachable_nodes 8 [[0; 1]; [0; 2]; [0; 3]; [1; 4]; [1; 5]; [2; 6]; [3; 7]] [2; 4]
 * 5
*)
let reachable_nodes (n : int) (edges : int list list) (restricted : int list) : int =","  0","let () =
  assert (reachable_nodes 6 [[0; 1]; [0; 2]; [2; 3]; [2; 4]; [4; 5]] [1; 4] = 3);
  assert (reachable_nodes 8 [[0; 1]; [0; 2]; [1; 3]; [1; 4]; [2; 5]; [2; 6]; [3; 7]] [5; 7] = 6);
  assert (reachable_nodes 8 [[0; 1]; [0; 2]; [0; 3]; [1; 4]; [1; 5]; [2; 6]; [3; 7]] [2; 4] = 5);
  assert (reachable_nodes 10 [[0; 1]; [0; 2]; [1; 3]; [1; 4]; [2; 5]; [2; 6]; [3; 7]; [4; 8]; [5; 9]] [7; 8] = 8);
  assert (reachable_nodes 8 [[0; 1]; [0; 2]; [1; 3]; [1; 4]; [2; 5]; [2; 6]; [6; 7]] [3; 5] = 6);
  assert (reachable_nodes 7 [[0; 1]; [1; 2]; [3; 1]; [4; 0]; [0; 5]; [5; 6]] [4; 5] = 4);
  assert (reachable_nodes 6 [[0; 1]; [0; 2]; [1; 3]; [1; 4]; [2; 5]] [1; 2] = 1);
;;","medium","medium_145","medium"
"(**Given two integers num1 and num2, return the sum of the two integers.
 * >>> sum 100 -100
 * 0
 * >>> sum -10 4
 * -6
 * >>> sum 25 25
 * 50
*)
let sum (num1 : int) (num2 : int) : int =","  0","let () =
  assert (sum 100 -100 = 0);
  assert (sum -10 4 = -6);
  assert (sum 25 25 = 50);
  assert (sum -50 50 = 0);
  assert (sum 99 1 = 100);
  assert (sum -50 25 = -25);
  assert (sum -30 -70 = -100);
;;","easy","easy_121","easy"
"(**Given two version strings, version1 and version2, compare them. A version string consists of revi...
 * >>> compare_version ""0"" ""0.0.0""
 * 0
 * >>> compare_version ""1.1.1.1"" ""1.1.1.1""
 * 0
 * >>> compare_version ""1.2.3.4"" ""1.2.3""
 * 1
*)
let compare_version (version1 : string) (version2 : string) : int =","  0","let () =
  assert (compare_version ""0"" ""0.0.0"" = 0);
  assert (compare_version ""1.1.1.1"" ""1.1.1.1"" = 0);
  assert (compare_version ""1.2.3.4"" ""1.2.3"" = 1);
  assert (compare_version ""1.1.1.1"" ""1.1.1"" = 1);
  assert (compare_version ""1.0.0"" ""1"" = 0);
  assert (compare_version ""5.0000"" ""5.00000"" = 0);
  assert (compare_version ""0.0.1"" ""0.0.2"" = -1);
;;","medium","medium_185","medium"
"(**You are given a 2D array of strings equations and an array of real numbers values, where equation...
 * >>> check_contradictions [[""a""; ""a""]; [""b""; ""b""]; [""c""; ""c""]] [1; 1; 1]
 * false
 * >>> check_contradictions [[""x""; ""y""]; [""y""; ""z""]; [""z""; ""x""]] [2; 3; 0.5]
 * true
 * >>> check_contradictions [[""a""; ""b""]; [""b""; ""c""]; [""a""; ""c""]] [3; 0.5; 1.5]
 * false
*)
let check_contradictions (equations : string list list) (values : float list) : bool =","  false","let () =
  assert (check_contradictions [[""a""; ""a""]; [""b""; ""b""]; [""c""; ""c""]] [1; 1; 1] = false);
  assert (check_contradictions [[""x""; ""y""]; [""y""; ""z""]; [""z""; ""x""]] [2; 3; 0.5] = true);
  assert (check_contradictions [[""a""; ""b""]; [""b""; ""c""]; [""a""; ""c""]] [3; 0.5; 1.5] = false);
  assert (check_contradictions [[""x""; ""y""]; [""y""; ""z""]; [""x""; ""z""]] [2; 3; 6] = false);
  assert (check_contradictions [[""p""; ""q""]; [""q""; ""r""]; [""p""; ""r""]] [1; 2; 2] = false);
  assert (check_contradictions [[""p""; ""q""]; [""q""; ""r""]; [""r""; ""s""]] [0.5; 0.5; 1] = false);
  assert (check_contradictions [[""m""; ""n""]; [""n""; ""o""]; [""m""; ""o""]] [1.5; 2; 3] = false);
;;","hard","hard_020","hard"
"(**Given a 32-bit integer num, return a string representing its hexadecimal representation. For nega...
 * >>> to_hex 31
 * 1f
 * >>> to_hex 10
 * a
 * >>> to_hex -4294967296
 * 
*)
let to_hex (num : int) : string =","  """"","let () =
  assert (to_hex 31 = 1f);
  assert (to_hex 10 = a);
  assert (to_hex 16777215 = ffffff);
  assert (to_hex -16777215 = ff000001);
  assert (to_hex -1 = ffffffff);
  assert (to_hex 4294967295 = ffffffff);
;;","easy","easy_048","easy"
"(**You are given a 0-indexed array of strings words and a character x.
 * >>> find_words_containing [""abc""; ""bcd""; ""aaaa""; ""cbc""] ""z""
 * []
 * >>> find_words_containing [""python""; ""programming""] ""o""
 * [0; 1]
 * >>> find_words_containing [""ab""; ""cd""; ""ef""] ""g""
 * []
*)
let find_words_containing (words : string list) (x : string) : int list =","  []","let () =
  assert (find_words_containing [""abc""; ""bcd""; ""aaaa""; ""cbc""] ""z"" = []);
  assert (find_words_containing [""python""; ""programming""] ""o"" = [0; 1]);
  assert (find_words_containing [""ab""; ""cd""; ""ef""] ""g"" = []);
  assert (find_words_containing [""aaaaa""; ""bbbbb""; ""ccccc""] ""a"" = [0]);
  assert (find_words_containing [""apple""; ""banana""; ""cherry""] ""a"" = [0; 1]);
  assert (find_words_containing [""hello""; ""world""] ""l"" = [0; 1]);
  assert (find_words_containing [""hello""; ""world""] ""o"" = [0; 1]);
;;","easy","easy_172","easy"
"(**Given n points on a 2D plane, find if there is such a line parallel to the y-axis that reflects t...
 * >>> is_reflected [[0; 0]; [1; 0]; [3; 0]; [4; 0]]
 * true
 * >>> is_reflected [[1; 1]; [-1; 1]]
 * true
 * >>> is_reflected [[0; 0]; [0; 1]; [1; 0]; [1; 1]]
 * true
*)
let is_reflected (points : int list list) : bool =","  false","let () =
  assert (is_reflected [[0; 0]; [1; 0]; [3; 0]; [4; 0]] = true);
  assert (is_reflected [[1; 1]; [-1; 1]] = true);
  assert (is_reflected [[0; 0]; [0; 1]; [1; 0]; [1; 1]] = true);
  assert (is_reflected [[0; 0]; [0; 1]; [0; 2]; [0; 3]] = true);
  assert (is_reflected [[1; 1]; [1; -1]; [-1; -1]; [-1; 1]] = true);
  assert (is_reflected [[1; 1]; [2; 2]; [3; 3]; [4; 5]] = false);
  assert (is_reflected [[1; 1]; [2; 2]; [3; 3]] = false);
;;","medium","medium_118","medium"
"(**Given a binary array data, return the minimum number of swaps required to group all 1’s present i...
 * >>> min_swaps [0; 0; 0; 1; 0]
 * 0
 * >>> min_swaps [0; 1; 0; 1; 0; 1; 0; 1; 0]
 * 2
 * >>> min_swaps [1; 1; 1; 1; 1; 0; 0; 0; 0; 0]
 * 0
*)
let min_swaps (data : int list) : int =","  0","let () =
  assert (min_swaps [0; 0; 0; 1; 0] = 0);
  assert (min_swaps [0; 1; 0; 1; 0; 1; 0; 1; 0] = 2);
  assert (min_swaps [1; 1; 1; 1; 1; 0; 0; 0; 0; 0] = 0);
  assert (min_swaps [1; 1; 1; 1; 0; 0; 0; 0; 1; 1; 1; 1] = 4);
  assert (min_swaps [1; 1; 1; 1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0] = 0);
  assert (min_swaps [0; 1; 0; 1; 0; 1; 0; 1; 0; 1; 0; 1] = 3);
  assert (min_swaps [1; 0; 0; 0; 0; 1; 1; 1; 1; 0; 0; 0; 1] = 2);
;;","medium","medium_125","medium"
"(**You are given an integer array nums. You need to create a 2D array from nums satisfying the follo...
 * >>> find_matrix [1; 2; 2; 3; 3; 3; 4; 4; 4; 4]
 * [[1; 2; 3; 4]; [2; 3; 4]; [3; 4]; [4]]
 * >>> find_matrix [1; 2; 3; 4]
 * [[1; 2; 3; 4]]
 * >>> find_matrix [10; 1; 2; 9; 3; 8; 4; 7; 5; 6]
 * [[10; 1; 2; 9; 3; 8; 4; 7; 5; 6]]
*)
let find_matrix (nums : int list) : int list list =","  [[]]","let () =
  assert (find_matrix [1; 2; 2; 3; 3; 3; 4; 4; 4; 4] = [[1; 2; 3; 4]; [2; 3; 4]; [3; 4]; [4]]);
  assert (find_matrix [1; 2; 3; 4] = [[1; 2; 3; 4]]);
  assert (find_matrix [10; 1; 2; 9; 3; 8; 4; 7; 5; 6] = [[10; 1; 2; 9; 3; 8; 4; 7; 5; 6]]);
  assert (find_matrix [1; 1; 2; 2; 3; 3; 4; 4] = [[1; 2; 3; 4]; [1; 2; 3; 4]]);
  assert (find_matrix [1; 1; 1; 1] = [[1]; [1]; [1]; [1]]);
  assert (find_matrix [1; 2; 1; 3; 4; 2; 3] = [[1; 2; 3; 4]; [1; 2; 3]]);
  assert (find_matrix [5; 3; 3; 2; 1; 2; 4; 5] = [[5; 3; 2; 1; 4]; [5; 3; 2]]);
;;","medium","medium_140","medium"
"(**There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You a...
 * >>> can_finish 2 [[1; 0]; [0; 1]]
 * false
 * >>> can_finish 5 [[1; 4]; [2; 4]; [3; 1]; [3; 2]]
 * true
 * >>> can_finish 4 [[1; 0]; [2; 0]; [3; 1]; [3; 2]]
 * true
*)
let can_finish (numCourses : int) (prerequisites : int list list) : bool =","  false","let () =
  assert (can_finish 2 [[1; 0]; [0; 1]] = false);
  assert (can_finish 5 [[1; 4]; [2; 4]; [3; 1]; [3; 2]] = true);
  assert (can_finish 4 [[1; 0]; [2; 0]; [3; 1]; [3; 2]] = true);
  assert (can_finish 3 [[1; 0]; [2; 1]] = true);
  assert (can_finish 1 [] = true);
  assert (can_finish 2 [[1; 0]] = true);
  assert (can_finish 20 [[1; 0]; [2; 0]; [3; 1]; [4; 1]; [5; 2]; [6; 2]; [7; 3]; [7; 4]; [8; 5]; [8; 6]; [9; 7]; [10; 7]; [11; 8]; [12; 8]; [13; 9]; [14; 10]; [14; 11]; [14; 12]; [15; 13]; [16; 13]; [17; 14]; [18; 15]; [18; 16]; [19; 17]; [19; 18]] = true);
;;","medium","medium_064","medium"
"(**You are given a 0-indexed, strictly increasing integer array nums and a positive integer diff. A ...
 * >>> arithmetic_triplets [1; 3; 5; 7; 9; 11; 13] 2
 * 5
 * >>> arithmetic_triplets [5; 10; 15; 20; 25; 30] 5
 * 4
 * >>> arithmetic_triplets [1; 3; 5; 7; 9; 11; 13; 15; 17; 19] 4
 * 6
*)
let arithmetic_triplets (nums : int list) (diff : int) : int =","  0","let () =
  assert (arithmetic_triplets [1; 3; 5; 7; 9; 11; 13] 2 = 5);
  assert (arithmetic_triplets [5; 10; 15; 20; 25; 30] 5 = 4);
  assert (arithmetic_triplets [1; 3; 5; 7; 9; 11; 13; 15; 17; 19] 4 = 6);
  assert (arithmetic_triplets [4; 5; 6; 7; 8; 9] 2 = 2);
  assert (arithmetic_triplets [1; 3; 5; 7; 9] 2 = 3);
  assert (arithmetic_triplets [0; 3; 6; 9; 12] 3 = 3);
  assert (arithmetic_triplets [0; 1; 4; 6; 7; 10] 3 = 2);
;;","easy","easy_146","easy"
"(**You are given a non-negative integer array nums. In one operation, you must:
 * >>> minimum_operations [0; 1; 2; 3; 4; 5]
 * 5
 * >>> minimum_operations [1; 0; 1; 0; 1]
 * 1
 * >>> minimum_operations [1; 5; 0; 3; 5]
 * 3
*)
let minimum_operations (nums : int list) : int =","  0","let () =
  assert (minimum_operations [0; 1; 2; 3; 4; 5] = 5);
  assert (minimum_operations [1; 0; 1; 0; 1] = 1);
  assert (minimum_operations [1; 5; 0; 3; 5] = 3);
  assert (minimum_operations [0; 1; 0; 1; 0] = 1);
  assert (minimum_operations [1] = 1);
  assert (minimum_operations [1; 0; 2; 0; 3; 0; 4] = 4);
  assert (minimum_operations [100; 0; 50; 50] = 2);
;;","easy","easy_044","easy"
"(**You have n buckets each containing some gallons of water in it, represented by a 0-indexed intege...
 * >>> equalize_water [1; 1; 1; 1; 1; 1] 50
 * 0.9999923706054688
 * >>> equalize_water [1; 1; 1; 1; 1; 1; 1; 1; 1; 1] 0
 * 0.9999923706054688
 * >>> equalize_water [5; 10; 15] 20
 * 9.61538314819336
*)
let equalize_water (buckets : int list) (loss : int) : float =","  0.0","let () =
  assert (equalize_water [1; 1; 1; 1; 1; 1] 50 = 0.9999923706054688);
  assert (equalize_water [1; 1; 1; 1; 1; 1; 1; 1; 1; 1] 0 = 0.9999923706054688);
  assert (equalize_water [5; 10; 15] 20 = 9.61538314819336);
  assert (equalize_water [100; 0; 0] 99 = 0.49750804901123047);
  assert (equalize_water [10; 20; 30; 40; 50] 0 = 29.999995231628418);
  assert (equalize_water [5; 5; 5; 5; 5] 0 = 4.999990463256836);
  assert (equalize_water [5; 5; 5; 5; 5] 99 = 4.999990463256836);
;;","medium","medium_138","medium"
"(**Given an integer array arr, return the mean of the remaining integers after removing the smallest...
 * >>> trim_mean [6; 0; 7; 0; 7; 5; 7; 8; 3; 4; 0; 7; 8; 1; 6; 8; 1; 1; 2; 4; 8; 1; 9; 5; 4; 3; 8; 5; 10; 8; 6; 6; 1; 0; 6; 10; 8; 2; 3; 4]
 * 4.77778
 * >>> trim_mean [1; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 3]
 * 2.0
 * >>> trim_mean [6; 2; 7; 5; 1; 2; 0; 3; 10; 2; 5; 0; 5; 5; 0; 8; 7; 6; 8; 0]
 * 4.0
*)
let trim_mean (arr : int list) : float =","  0.0","let () =
  assert (trim_mean [6; 0; 7; 0; 7; 5; 7; 8; 3; 4; 0; 7; 8; 1; 6; 8; 1; 1; 2; 4; 8; 1; 9; 5; 4; 3; 8; 5; 10; 8; 6; 6; 1; 0; 6; 10; 8; 2; 3; 4] = 4.77778);
  assert (trim_mean [1; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 3] = 2.0);
  assert (trim_mean [6; 2; 7; 5; 1; 2; 0; 3; 10; 2; 5; 0; 5; 5; 0; 8; 7; 6; 8; 0] = 4.0);
  assert (trim_mean [10; 20; 30; 40; 50; 60; 70; 80; 90; 100; 110; 120; 130; 140; 150; 160; 170; 180; 190; 200; 10; 20; 30; 40; 50; 60; 70; 80; 90; 100; 110; 120; 130; 140; 150; 160; 170; 180; 190; 200] = 105.0);
  assert (trim_mean [42; 85; 94; 12; 85; 74; 15; 7; 83; 52; 53; 87; 27; 30; 67; 94; 84; 90; 72; 18; 62; 85; 81; 69; 82; 69; 39; 72; 25; 90; 45; 88; 61; 53; 74; 69; 46; 12; 43; 96; 89; 90; 25; 46; 23; 88; 97; 30; 69; 58; 76; 67; 50; 87; 94; 82; 63; 30; 93; 50; 33; 98; 60; 69; 88; 75; 29; 11; 94; 47; 87; 93; 34; 97; 32; 96; 79; 97; 78; 77; 45; 35; 94; 66; 62; 58; 42; 23; 83; 82; 72; 58; 75; 86; 80; 94; 28; 44; 62; 40; 96; 97; 46; 28; 96; 37; 82; 96; 62; 98; 28; 37; 81; 74; 90; 98; 73; 72; 99; 40; 54; 34; 55; 65; 70; 71; 80; 92; 93] = 65.75);
  assert (trim_mean [10; 20; 30; 40; 50; 60; 70; 80; 90; 100; 110; 120; 130; 140; 150; 160; 170; 180; 190; 200; 210; 220; 230; 240; 250; 260; 270; 280; 290; 300; 310; 320; 330; 340; 350; 360; 370; 380; 390; 400; 410; 420; 430; 440; 450; 460; 470; 480; 490; 500] = 250.0);
  assert (trim_mean [1; 100000; 2; 99999; 3; 99998; 4; 99997; 5; 99996; 6; 99995; 7; 99994; 8; 99993; 9; 99992; 10; 99991; 11; 99990; 12; 99989; 13; 99988; 14; 99987; 15; 99986; 16; 99985; 17; 99984; 18; 99983; 19; 99982; 20; 99981] = 50000.5);
;;","easy","easy_087","easy"
"(**You have some number of sticks with positive integer lengths. These lengths are given as an array...
 * >>> connect_sticks [1; 8; 3; 5]
 * 30
 * >>> connect_sticks [10; 1; 2; 8; 5]
 * 53
 * >>> connect_sticks [5; 4; 3; 2; 1]
 * 33
*)
let connect_sticks (sticks : int list) : int =","  0","let () =
  assert (connect_sticks [1; 8; 3; 5] = 30);
  assert (connect_sticks [10; 1; 2; 8; 5] = 53);
  assert (connect_sticks [5; 4; 3; 2; 1] = 33);
  assert (connect_sticks [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] = 173);
  assert (connect_sticks [10; 10; 10; 10; 10; 10; 10; 10; 10; 10] = 340);
  assert (connect_sticks [1; 1; 1; 1; 1] = 12);
  assert (connect_sticks [100; 200; 300] = 900);
;;","medium","medium_177","medium"
"(**Given the root of a binary search tree, a target value, and an integer k, return the k values in ...
 * >>> closest_kvalues [4; 2; 5; 1; 3] 3.714286 2
 * [3; 4]
 * >>> closest_kvalues [5; 2; 7; 1; 3; 6; 8] 5.15 2
 * [5; 6]
 * >>> closest_kvalues [3; 1; 4; null; 2] 0.275 2
 * [1; 2]
*)
let closest_kvalues (root : 'a option) (target : float) (k : int) : int list =","  []","let () =
  assert (closest_kvalues [4; 2; 5; 1; 3] 3.714286 2 = [3; 4]);
  assert (closest_kvalues [5; 2; 7; 1; 3; 6; 8] 5.15 2 = [5; 6]);
  assert (closest_kvalues [3; 1; 4; null; 2] 0.275 2 = [1; 2]);
  assert (closest_kvalues [10; 5; 15; 3; 7; 13; 18; 1; null; 6] 10.25 3 = [7; 10; 13]);
  assert (closest_kvalues [1] 0.000000 1 = [1]);
  assert (closest_kvalues [100; 50; 150; 25; 75; 125; 175; 10; 40; 60; 90; 110; 140; 160; 190] 130.0 6 = [100; 110; 125; 140; 150; 160]);
  assert (closest_kvalues [75; 37; 112; 18; 56; 93; 130; 9; 28; 47; 65; 82; 105; 115; 135] 72.4 4 = [56; 65; 75; 82]);
;;","hard","hard_008","hard"
"(**You are given a string s and an integer k.
*)
let count_ksubsequences_with_max_beauty (s : string) (k : int) : int =","  0","let () =
  assert (count_ksubsequences_with_max_beauty ""zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz"" 26 = 0);
  assert (count_ksubsequences_with_max_beauty ""zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz"" 2 = 0);
;;","hard","hard_062","hard"
"(**A k-mirror number is a positive integer without leading zeros that reads the same both forward an...
 * >>> k_mirror 2 1
 * 1
 * >>> k_mirror 5 8
 * 638
 * >>> k_mirror 8 15
 * 5818
*)
let k_mirror (k : int) (n : int) : int =","  0","let () =
  assert (k_mirror 2 1 = 1);
  assert (k_mirror 5 8 = 638);
  assert (k_mirror 8 15 = 5818);
  assert (k_mirror 9 5 = 15);
  assert (k_mirror 9 6 = 21);
  assert (k_mirror 8 9 = 158);
  assert (k_mirror 4 8 = 1498);
;;","hard","hard_007","hard"
"(**Given an array nums, you have to get the maximum score starting from index 0 and hopping until yo...
 * >>> max_score [5; 4; 3; 2; 1]
 * 10
 * >>> max_score [3; 4; 5; 6; 7]
 * 28
 * >>> max_score [1; 100; 1; 1; 1; 1; 100]
 * 600
*)
let max_score (nums : int list) : int =","  0","let () =
  assert (max_score [5; 4; 3; 2; 1] = 10);
  assert (max_score [3; 4; 5; 6; 7] = 28);
  assert (max_score [1; 100; 1; 1; 1; 1; 100] = 600);
  assert (max_score [3; 2; 1; 6; 5; 4; 7; 8; 9] = 72);
  assert (max_score [1; 1; 1; 1; 1; 1; 1; 1; 1; 1] = 9);
  assert (max_score [4; 5; 2; 8; 9; 1; 3] = 42);
  assert (max_score [1; 100; 1; 100; 1; 100] = 500);
;;","medium","medium_043","medium"
"(**You are given an integer array banned and two integers n and maxSum. You are choosing some number...
 * >>> max_count [] 10 55
 * 10
 * >>> max_count [1; 2; 3] 5 10
 * 2
 * >>> max_count [5] 5 5
 * 2
*)
let max_count (banned : int list) (n : int) (maxSum : int) : int =","  0","let () =
  assert (max_count [] 10 55 = 10);
  assert (max_count [1; 2; 3] 5 10 = 2);
  assert (max_count [5] 5 5 = 2);
  assert (max_count [1; 4; 6] 6 4 = 1);
  assert (max_count [2; 5; 8] 10 20 = 4);
  assert (max_count [1; 2; 3; 4; 5] 10 30 = 4);
  assert (max_count [10; 20; 30] 50 150 = 16);
;;","medium","medium_062","medium"
"(**You are playing a Flip Game with your friend.
 * >>> generate_possible_next_moves ""--++""
 * ['----']
 * >>> generate_possible_next_moves ""+""
 * []
 * >>> generate_possible_next_moves ""+++++""
 * ['--+++'; '+--++'; '++--+'; '+++--']
*)
let generate_possible_next_moves (currentState : string) : string list =","  []","let () =
  assert (generate_possible_next_moves ""--++"" = ['----']);
  assert (generate_possible_next_moves ""+"" = []);
  assert (generate_possible_next_moves ""+++++"" = ['--+++'; '+--++'; '++--+'; '+++--']);
  assert (generate_possible_next_moves ""+-+--+-+"" = []);
  assert (generate_possible_next_moves ""++--"" = ['----']);
  assert (generate_possible_next_moves ""----"" = []);
  assert (generate_possible_next_moves ""++++++++"" = ['--++++++'; '+--+++++'; '++--++++'; '+++--+++'; '++++--++'; '+++++--+'; '++++++--']);
;;","easy","easy_110","easy"
"(**You are given two integers height and width representing a garden of size height x width. You are...
 * >>> min_distance 6 6 [3; 3] [5; 0] [[3; 3]; [1; 1]; [5; 5]; [0; 0]]
 * 27
 * >>> min_distance 10 10 [5; 5] [0; 0] [[9; 9]; [0; 0]; [5; 5]]
 * 26
 * >>> min_distance 100 100 [50; 50] [99; 99] [[49; 49]; [51; 51]]
 * 102
*)
let min_distance (height : int) (width : int) (tree : int list) (squirrel : int list) (nuts : int list list) : int =","  0","let () =
  assert (min_distance 6 6 [3; 3] [5; 0] [[3; 3]; [1; 1]; [5; 5]; [0; 0]] = 27);
  assert (min_distance 10 10 [5; 5] [0; 0] [[9; 9]; [0; 0]; [5; 5]] = 26);
  assert (min_distance 100 100 [50; 50] [99; 99] [[49; 49]; [51; 51]] = 102);
  assert (min_distance 10 10 [5; 5] [0; 0] [[9; 9]; [5; 5]; [0; 0]] = 26);
  assert (min_distance 10 10 [5; 5] [0; 0] [[9; 9]; [8; 8]; [7; 7]] = 46);
  assert (min_distance 6 8 [3; 4] [0; 0] [[1; 2]; [3; 5]; [5; 6]; [4; 1]] = 25);
  assert (min_distance 1 3 [0; 1] [0; 0] [[0; 2]] = 3);
;;","medium","medium_146","medium"
"(**You are given an integer array nums​​​ and an integer k. You are asked to distribute this array i...
 * >>> minimum_incompatibility [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16] 1
 * 15
 * >>> minimum_incompatibility [1; 1; 2; 2; 3; 3; 4; 4; 5; 5; 6; 6; 7; 7; 8; 8] 8
 * 8
 * >>> minimum_incompatibility [1; 2; 3; 4; 5; 6; 7; 8] 4
 * 4
*)
let minimum_incompatibility (nums : int list) (k : int) : int =","  0","let () =
  assert (minimum_incompatibility [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16] 1 = 15);
  assert (minimum_incompatibility [1; 1; 2; 2; 3; 3; 4; 4; 5; 5; 6; 6; 7; 7; 8; 8] 8 = 8);
  assert (minimum_incompatibility [1; 2; 3; 4; 5; 6; 7; 8] 4 = 4);
  assert (minimum_incompatibility [6; 3; 8; 1; 3; 1; 2; 2] 4 = 6);
  assert (minimum_incompatibility [1; 2; 1; 4] 2 = 4);
  assert (minimum_incompatibility [1; 2; 3; 4; 5; 6; 7; 8] 2 = 6);
  assert (minimum_incompatibility [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16] 4 = 12);
;;","hard","hard_098","hard"
"(**Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.
 * >>> check_inclusion ""abc"" ""bbbccca""
 * false
 * >>> check_inclusion ""adc"" ""dcda""
 * true
 * >>> check_inclusion ""abc"" ""bbbccba""
 * true
*)
let check_inclusion (s1 : string) (s2 : string) : bool =","  false","let () =
  assert (check_inclusion ""abc"" ""bbbccca"" = false);
  assert (check_inclusion ""adc"" ""dcda"" = true);
  assert (check_inclusion ""abc"" ""bbbccba"" = true);
  assert (check_inclusion ""abcde"" ""adecb"" = true);
  assert (check_inclusion ""test"" ""ttewest"" = false);
  assert (check_inclusion ""abc"" ""cbadef"" = true);
  assert (check_inclusion ""abc"" ""defabc"" = true);
;;","medium","medium_027","medium"
"(**You are given an array of strings nums and an integer k. Each string in nums represents an intege...
 * >>> kth_largest_number [""100""; ""200""; ""300""; ""400""; ""500""] 2
 * 400
 * >>> kth_largest_number [""2""; ""21""; ""12""; ""1""] 3
 * 2
 * >>> kth_largest_number [""9""; ""8""; ""7""; ""6""; ""5""; ""4""; ""3""; ""2""; ""1""] 5
 * 5
*)
let kth_largest_number (nums : string list) (k : int) : string =","  """"","let () =
  assert (kth_largest_number [""100""; ""200""; ""300""; ""400""; ""500""] 2 = 400);
  assert (kth_largest_number [""2""; ""21""; ""12""; ""1""] 3 = 2);
  assert (kth_largest_number [""9""; ""8""; ""7""; ""6""; ""5""; ""4""; ""3""; ""2""; ""1""] 5 = 5);
  assert (kth_largest_number [""100""; ""200""; ""300""; ""400""] 2 = 300);
  assert (kth_largest_number [""9""; ""11""; ""8""; ""9""; ""10""] 5 = 8);
  assert (kth_largest_number [""9""; ""11""; ""2""; ""22""] 2 = 11);
  assert (kth_largest_number [""10""; ""20""; ""30""; ""40""; ""50""] 5 = 10);
;;","medium","medium_039","medium"
"(**Given a sentence that consists of some words separated by a single space, and a searchWord, check...
 * >>> is_prefix_of_word ""a ab abc abd"" ""a""
 * 1
 * >>> is_prefix_of_word ""abcde fghij klmno"" ""mnop""
 * -1
 * >>> is_prefix_of_word ""find prefix quickly"" ""qui""
 * 3
*)
let is_prefix_of_word (sentence : string) (searchWord : string) : int =","  0","let () =
  assert (is_prefix_of_word ""a ab abc abd"" ""a"" = 1);
  assert (is_prefix_of_word ""abcde fghij klmno"" ""mnop"" = -1);
  assert (is_prefix_of_word ""find prefix quickly"" ""qui"" = 3);
  assert (is_prefix_of_word ""prefix test"" ""prefix"" = 1);
  assert (is_prefix_of_word ""prefix test"" ""testprefix"" = -1);
  assert (is_prefix_of_word ""hello world"" ""he"" = 1);
  assert (is_prefix_of_word ""a aa aaa aaaa"" ""aaaa"" = 4);
;;","easy","easy_165","easy"
